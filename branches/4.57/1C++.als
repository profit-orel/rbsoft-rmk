{"Shell",
 {"Folder","AST","1C++ 2.0.0.0","",
    {"Item","AST","Введение","",
"Введение",
"",
"ООП - объектно-ориентированное программирование, является на сегодняшний день одной из самых популярных технологий создания программных средств. Данная разработка направлена на устранения недостатка ООП в языке 1С. Как известно ООП базируется на трех основных принципах: полиморфизм, наследование и инкапсуляция, в данной разработке для возможной технической реализации принципов, были добавлены некоторые языковые средства. Также добавлена возможность строгой проверки типов параметров методов классов определяемых пользователем (КОП) и некоторые другие классы для расширения ООП.
@Наследование
Это обобщение объектов за счет выведения общего поведения в логически связанных сущностях проекта. Возможность повторно использовать код и разделение интерфейса объекта от его реализации с целью повышения взаимозаменяемости и расширения частей системы без перепрограммирования и дополнительного тестирования множества модулей. Наследование позволяет представить модель проектирования учетной системы более приближенно к проектируемой области на логическим уровне. Наследование необходимо реализовать для достижения следующих целей: 
• уменьшение зависимостей не связанных между собой логически частей учетной системы; 
• уменьшение написания и тестирование кода для связанных между собой логически понятий объектов системы; 
• возможность расширения существующего функционала; 
• концентрирование кода алгоритма в одном программном модуле с четко определенным интерфейсом его использования, что позволит вносить изменения в алгоритм и его исправление, без необходимости проверки и исправления всего зависящего от него кода.
• для разделения функционала на три логических уровня: уровень интерфейс пользователя, уровень бизнес - логики, уровень сохранения\получения (персистентность) результатов и объектов, другими словами уровень взаимодействия с БД.
• повторяемость кода или наследуемость кода базового класса его наследниками.
В реализации наследования в ВК (внешней компоненте 1С:Предприятия) 1С++ необходимо определить следующий функционал:
1. Возможность наследования классов от встроенных типов, таких как Справочник, Документ и т.д.;
2. Возможность наследования от типов определяемых пользователем (классов 1С++);
3. Возможность вызова переопределенных функций производными классами из функций базового класса;
4. Возможность переопределения  функций базовых классов в классах наследниках;
5. Возможность вызова базовых функций из переопределенных функций наследуемого класса;
@Полиморфизм
Заключается в переопределении поведения объекта с помощью  специализации обобщенного класса, т.е. переопределение методов интерфейсов базового класса (общий класс) его наследником (более специализированным классом). Полиморфизм позволит:
• писать обобщенные алгоритмы для родственных объектов находящихся в одной иерархии;
• добавлять новые классы в семейство логически связанных классов, уточняя и переопределяя поведение заявленное в более абстрактных базовых классах, без внесения изменения в код, который использует интерфейс базового класса для взаимодействия с объектами одной иерархии;
• избавиться от кода, жестко завязанного на конкретные типы родственных объектов, которые возможно расположить в единую иерархию наследования.
@Инкапсуляция
Cокрытие деталей реализации классов за четко определенным интерфейсом, это позволит разрабатывать компоненты и настраивать их взаимодействие с меньшими зависимостями между ними, что в свою очередь, уменьшит время тестирования и уменьшит появление ошибок в алгоритмах программы."
    },
    {"Item","AST","1.1. Состав компоненты.","",
"1.1. Состав компоненты.",
"",
"·      1C:Предприятие, релиз 7.70.17;15;18, Windows98 OSR2, Windows 2000, Window 
XP
·       Файл движка ООП для 1С 1C++.dll, подключается с помощью метода 1С 
«ЗагрузитьВнешнююКомпоненту(Путь)»
·       Файл определения классов пользователя Defcls.prm, обязан находиться в 
каталоге информационной базы (ИБ) в которой используются классы, 
определяемые пользователем компоненты. Синтаксис языка определения 
классов см. ниже.
·       Файл oxy.ini, который необходимо создать в каталоге BIN 1C:Предприятия для 
настройки псевдонимов путей к файлам реализации КОП.
·       Файлы реализации классов могут быть как в текстовом формате, так и в 
формате отчетов с расширением *.ert. Имена файлов и привязки файлов 
реализации к классам задаются в файле определения Defcls.prm.
"
    },
 {"Folder","AST","1.2. Функционал компоненты (стандартные методы классов)","",
    {"Item","AST","Введение","",
"Введение",
"",
"Каждый класс определенный пользователем (КОП) создается в 1С с помощью метода СоздатьОбъект
(<ИмяКласса>).
Для каждого КОП определен стандартный интерфейс состоящий из следующих методов:
"
    },
    {"Item","AST","ПолучитьБазовыйКласс","GetBaseClass",
"ПолучитьБазовыйКласс(<?>)",
"GetBaseClass(<?>)",
"@Синтаксис:
ПолучитьБазовыйКласс(<ИмяБазовогоКласса>)
@Назначение:
Возвращает объект базового класса для класса наследника, имя которого передается в качестве строки в параметр метода ИмяБазовогоКласса. Если объекта базового класса не существует, то метод возвратит 0. Данный метод предназначен для вызова переопределенных методов базовых классов из методов классов наследников и получения/установки атрибутов базовых классов.
@Параметры:
<ИмяБазовогоКласса> - (Строка)  имя базового класса
@Пример:
Имеется следующие справочники Необоротные активы, в котором содержаться общие реквизиты всех необоротных активов предприятия и справочники - спецификаторы, такие как Основные средства, Нематериальные активы, которые в свою очередь добавляют специфические реквизиты сущностей, к общим реквизитам необоротных активов. Исходя из описанной выше идеологии, мы строим, следующую иерархию классов: КОП с рабочим названием ОС наследует от классов 1С: справочника Необоротные активы и Основные средства и переопределяет методы ВыбратьЭлементы() и ПолучитьЭлемент(), т.к у КОП ОС базовые классы имеет такие же методы, программист обязан разрешить неоднозначность вызова, воспользовавшись в реализации методов ВыбатьЭлементы() и ПолучитьЭлемент() класса ОС методом ПолучитьБазовыйКласс(Основные средства) для вызова его функций выборки и итераций и ПолучитьБазовыйКласс(Необоротные активы) для проведения аналогичных операций."
    },
    {"Item","AST","НазначитьБазовыйКласс","AssignBaseClass",
"НазначитьБазовыйКласс(<?>)",
"AssignBaseClass(<?>)",
"@Синтаксис:
НазначитьБазовыйКласс(<ИмяБазовогоКласса>)
@Назначение:
Данный метод позволяет для созданного КОПа назначить динамически базовый класс в модуле, где он используется. Что позволяет строить иерархию базовых классов исходя из логики программы на лету.
@Параметры:
<ИмяБазовогоКласса> - (Строка)  имя базового класса
@Замечание:
Методом возможно создать иерархию глубиной только в один уровень."
    },
    {"Item","AST","ОтправитьСообщениеМодулюХоз","SendMessageOwnMod",
"ОтправитьСообщениеМодулюХоз(<?>)",
"SendMessageOwnMod(<?>)",
"@Синтаксис:
ОтправитьСообщениеМодулюХоз(<КтоОтправил>,<ВидСообщения>,<Данные>)
@Назначение:
Вызывает предопределенную функцию ОбработкаСобытияОтКласса(отКого, стрСобытие, Данные) реализованной в модуле работающим с объектом КОП, возвращает любое значение, которое будет получено после вызова ОтправитьСообщениеМодулюХоз() в модуле КОП.
@Параметры:
<КтоОтправил> - (Строка)  отправитель сообщения
<ВидСообщения> - (Строка)  вид отправляемого сообщения
<Данные> -   отправляемые данные любого типа"
    },
    {"Item","AST","ПолучитьПуть","GetPathName",
"ПолучитьПуть(<?>)",
"GetPathName(<?>)",
"@Синтаксис:
ПолучитьПуть()
@Назначение:
Возвращает полный путь и название файла в котором храниться модуль реализации класса."
    },
    {"Item","AST","ПолучитьКонтекстОкружения","GetEnvContext",
"ПолучитьКонтекстОкружения(<?>)",
"GetEnvContext(<?>)",
"@Синтаксис:
ПолучитьКонтекстОкружения()
@Назначение:
Получить контекст окружения из модуля КОП.
Возвращает контекст из которого получил управление модуль КОП."
    },
    {"Item","AST","ПолучитьСписокПараметров","GetParamsList",
"ПолучитьСписокПараметров(<?>)",
"GetParamsList(<?>)",
"@Синтаксис:
ПолучитьСписокПараметров(<стрИмяМетода>)
@Назначение:
Получить список со значениями неявных параметров переданных в метод. Данным методов возможно пользоваться только для метода класса, который определен с последним параметром … в файле определения КОП.
@Параметры:
<стрИмяМетода> - (Строка)  Название метода в котором необходимо получить список неявных параметров
@Замечание:
Более подробное описание см. в пункте 1.3. раздел Неопределенное количество параметров."
    },
    {"Item","AST","УстановитьПараметрПоИндексу","SetOnIndexParams",
"УстановитьПараметрПоИндексу(<?>)",
"SetOnIndexParams(<?>)",
"@Синтаксис:
УстановитьПараметрПоИндексу(<стрИмяМетода>,<чИнд>,<нЗнач>)
@Назначение:
Метод предназначен для получения ссылки значения неявного параметра по его порядковому номеру и установке нового значения по данной ссылке.
@Возвращаемое значение:
  1 - установка успешно произведена, 0 - произошла ошибка при установке
@Параметры:
<стрИмяМетода> - (Строка)  Имя метода в ссылки на неявные параметры, которого необходимо получить.
<чИнд> - (Число)  номер неявного параметра ссылку на которого надо получить и заменить
<нЗнач> - (Неопределенный)  Новое значение"
    },
    {"Item","AST","ЗаменитьЭксзБазовогоКласса","ReplaceInstBaseClasses",
"ЗаменитьЭксзБазовогоКласса(<?>)",
"ReplaceInstBaseClasses(<?>)",
"@Синтаксис:
ЗаменитьЭксзБазовогоКласса(<стрИмяКласса>,<нЗначениеКласса>)
@Назначение:
Предназначен для замены экземпляра базового класса в уже созданной иерархии классов, изменения базового класса отражаются только на объекте для которого был вызван данный метод.
@Возвращаемое значение:
  1-замена успешно произведена, 0 - произошла ошибка при замене
@Параметры:
<стрИмяКласса> - (Строка)  Имя базового класса экземпляр которого мы собираемся заменять.
<нЗначениеКласса> - (Неопределенный)  новый экземпляр базового класса."
    },
    {"Item","AST","_ПриОткрытии","_OnOpen",
"_ПриОткрытии(<?>)",
"_OnOpen(<?>)",
"@Синтаксис:
_ПриОткрытии()
@Назначение:
Данный метод используется только в целях подключения отладчика для отладки классов 1С++. Подробней см. главу 1.6."
    },
    {"Item","AST","_ВыброситьИскл","_Throw",
"_ВыброситьИскл(<?>)",
"_Throw(<?>)",
"@Синтаксис:
_ВыброситьИскл(<ОбъектИскл>)
@Назначение:
Формирует исключение с объектом исключением. Вызов этого метода в модуле КОП прекращает его выполнение и данное исключение передается дальше в другие модули для поиска обработчика исключения (раскрутка стека), если такой обработчик не будет найден, то выполнение последнего модуля будет прекращено с выводом диагностического сообщения в окно сообщений 1С. Получить объект исключение можно с помощью метода GetExeption()/ПолучитьИсключение() дополнительного класса ExecuteModule/ВыполняемыйМодуль.
@Параметры:
<ОбъектИскл> - (Неопределенный)  Любой объект 1С."
    },
    },
 {"Folder","AST","1.3. Формат файла определения КОП","",
    {"Item","AST","Файл определения классов - DefCls.prm","",
"Файл определения классов - DefCls.prm",
"",
"Файл определения классов должен быть расположен в одном каталоге с файлом 
конфигурации и называться Defcls.prm, если файла с таким именем не обнаружено, 
ВК осуществляет поиск в текущей конфигурации обработки с именем Defcls. 
Синтаксис языка определения классов следующий: 
// - комментарий для программы
класс (class)  имя класса = имя файла класса реализации : <имя базового класса>, 
<имя базового класса> {
Объявления методов класса
};
имя класса - может состоять из любых печатных символов, внимание! 
учитывается регистр имени.
имя файла - <Путь>|<#Псевдоним>Имя файла.* | Имя обработки@MD 
файл реализации класса, если не указан путь, расположенный в каталоге с файлом 
конфигурации текущей ИБ, в котором реализуются методы класса и определяются 
атрибуты. Язык в файле 1С:Предприятия. Путь может быть относительным и 
формируется всегда относительно пути расположения конфигурации ИБ, в не 
зависимости от текущего папки файловой системы. Если указан #Псевдоним пути, 
то данный псевдоним ищется в файле инициализации компоненты, который должен 
находиться в каталоге \Bin 1С:Предприятия и называться oxy.ini В данном файле 
необходимо создать раздел [alias_path], который содержит все псевдонимы путей.
Текст КОП возможно хранить в конфигурации в виде обработок, для этого 
необходимо указать имя обработки и прибавить окончание @MD, с соблюдением 
регистра букв у окончания.
Пример файла инициализации компоненты: 
[alias_path]
Псевдоним1 = С:\Классы1С_1\
Псевдоним2 = С:\Классы1С_2\
Далее в файле определения пути к классам необходимо написать следующее: 
класс МойКласс = #Псевдоним1\ Псевдоним1.ert {};

имя базового класса  - базовые классы класса имя класса. Базовые классы 
могут отсутствовать или их может быть несколько, тогда они разделяются запятой.
объявление методов класса: функции и процедуры. Необязательно 
определять все функции, а только те, для которых необходима проверка типов, 
определение параметров по умолчанию, неявные параметры и передача 
параметров по значению. (все что указанно в угловых скобочках опциональные 
элементы, без них обязательные элементы)
функции: <Тип возвращаемого значения> Имя функции (Val | Знач> 
Тип переменной <Имя переменной = Значение по умолчанию>, <Val | Знач> 
Тип переменной <Имя переменной>, …);
процедуры: void Имя процедуры (Val | Знач> Тип переменной Имя 
переменной = Значение по умолчанию, <Val | Знач> Тип переменной <Имя 
переменной>, …);
Val | Знач - предопределенное слово, означает, что параметр метода 
передается по значению, т.е. в методе используется копия переданного 
параметра. (необязательный)
Любой тип - может быть заменен ключевым словом Неопределенный 
(Undefine), что отключает для данного параметра\возвращаемого значения 
проверку типов. Типом может быть Справочник, что означает возможность 
передавать в параметр метода любой вид справочника, Документ и Регистр - 
смысл аналогичный типу «Справочник» или ГрупповойКонтекст, когда 
типом параметра может быть контекст любого модуля. (обязательный)
Имя формального параметра метода. Обязательно должен быть указан 
при определении значения по умолчанию, во всех остальных случаях - 
необязателен.
Значение по умолчанию - задается после имени параметра и должно 
быть одного типа, что и тип для данного параметра. Возможные типы: Строка 
Пар1 = «Значение по умолчанию»; Число Пар1 = 100; Дата Пар1 = '01.01.2002', 
а также КОП и агрегатные объекты 1С:Предприятия задаются с заключением 
их в кавычки, например МойКласс ПарКласс = «МойКласс» - по умолчанию 
параметр ПарКласс будет содержать в теле метода значение экземпляра класса 
«МойКласс». Значение по умолчанию может быть простое выражение языка 
1С, например значения констант, перечислений, функций без параметров, 
например Дата дПарДата = РабочаяДата(), параметр «дПарДата» примет 
значение по умолчанию возвращенное из метода  РабочаяДата(). Внимание, 
указав в качестве значения по умолчанию “”, тип значения в этом случае не 
учитывается. Значения по умолчанию возможно задать только в последних 
параметрах метода.
Неопределенное количество параметров - метод объявленный с 
параметром «…» может принимать любое количество параметров во время 
вызова. Параметры метода, которые определенны стандартным образом, 
называются явными параметрами. Параметры, которые получены в ходе 
вызова метода в месте определения троеточия и далее за ним, называются 
неявными. Пример: void Метод1(Строка стрПар1, Число чПар2, …);, где 
параметры стрПар1, чПар2 являются явными и при вызове метода в них 
обязательно необходимо передавать значения их типов. Пример вызова 
данного метода может выглядеть так: МойКласс.Метод1(«{Пар3, Пар4, 
Пар5}», 200, «Значение параметра 3», «Значение параметра 4», «Значение 
параметра 5»); , где значения неявных параметров равны следующим строкам 
«Значение параметра 3», «Значение параметра 4», «Значение параметра 5», 
количество таких значений в нашем примере равно 3, но оно может быть 
любым и зависит только от потребностей алгоритма. И в то же время явные 
параметры стрПар1 и чПар2 в нашем примере, соответственно получат 
значения «{Пар3, Пар4, Пар5}» и 200. В реализации метода «Метод1»  
необходимо написать процедуру со следующей сигнатурой: Процедура Метод
(стрПар1, чПар2) //Тело процедуры КонецПроцедуры. Значения неявных 
параметров можно получить вызвав общий метод класса 
«ПолучитьСписокПараметров(ИмяМетода) (GetParamsList
(NameOfMethod))», который возвращает список значений содержащий 
неявные значения параметров переданных в метод. В одном из явных 
параметров вы можете передать строку, заключенную в фигурные скобки ({}) 
и содержащую названия ключей разделенных запятыми. Данные ключи 
сопоставляются с неявными параметрами в списке значений, которые в 
реализации метода класса можно получить использовав метод списка 
«Получить(Строка)». В нашем примере таким строковым, явным параметром 
является первый параметр метода «стрПар1», значение которого при вызове 
метода равно «{Пар3, Пар4, Пар5}», что означает в списке значений неявных 
параметров содержатся значения «Значение параметра 3» строковый ключ 
которого равен «Пар3», следующее значение «Значение параметра 4», а ключ 
для него «Пар4» и т.д.

        Примеры:
класс Базовый_1=Base_1.txt
{
        void Метод1(Число пар1, Строка пар2);
        Число Метод2(Число пар1, Дата пар2);
};
класс Производный_1=Derive_1.txt: Базовый_1, Справочник.Спр1, ТаблицаЗначений
{
        void Метод1(Число пар1, Строка пар2); // Данный метод переопределяет 
метод //базового класса
        Число КоличествоСтрок (Число Колич); // В данном случае мы 
переопределили 
//метод базового класса ТаблицаЗначений и добавили проверку типов. В реализации 
этого 
//метода можно переадресовать вызов базовому классу
        void Метод3(ОС ОС); // в этот метод мы должны передаем передавать КОП 
«ОС»
};
класс ОС=OC.txt : Справочник.ОсновныеСредства, 
Справочник.НематериальныеАктивы
{
        void Метод1(Базовый_1 пар1); // В данном случае в пар1 можно передавать 
//объекты типа «Базовый_1» и его производный класс «Производный_1»
        void Метод2(Производный_1 пар1); // в отличие от предыдущего случае в 
пар1 мы 
//можем передавать объекты типа «Производный_1», но не «Базовый_1»
Число ВыбратьЭлементы(Число чРежим);
        Число ПолучитьЭлемент(Число чРежим);
};
Внимание: проверка типов может быть отключена по требованию пользователя, об 
этом см. ниже.
"
    },
    {"Item","AST","oxy.ini","",
"oxy.ini",
"",
"Файл oxy.ini должен находиться в каталоге Bin 1С:Предприятия. В данном файле необходимо создать раздел [alias_path], который содержит все псевдонимы путей.
@Пример файла инициализации компоненты:
[alias_path]
Псевдоним1 = С:\Классы1С_1\
Псевдоним2 = С:\Классы1С_2
Далее в файле определения пути к классам необходимо написать следующее: 
класс МойКласс = #Псевдоним1\ Псевдоним1.ert {};"
    },
    {"Item","AST","Объявление функций класса","",
"Объявление функций класса",
"",
"Необязательно определять все функции, а только те, для которых необходима проверка типов, а также для которых необходимо определить параметры по умолчанию и передачу параметров по значению.
• Функции: <Тип возвращаемого значения> Имя функции (<Val | Знач> Тип переменной <Имя переменной = Значение по умолчанию>, <Val | Знач> Тип переменной <Имя переменной>, …);
• Процедуры: void Имя процедуры (<Val | Знач> Тип переменной Имя переменной = Значение по умолчанию, <Val | Знач> Тип переменной <Имя переменной>, …);
· Val | Знач - предопределенное слово, означает, что параметр метода передается по значению, т.е. в методе используется копия переданного параметра.
· Любой тип - может быть заменен ключевым словом Неопределенный (Undefine), что отключает для данного параметра\возвращаемого значения проверку типов. Типом может быть Справочник, что означает возможность передавать в параметр метода любой вид справочника, Документ и Регистр - смысл аналогичный типу Справочник или ГрупповойКонтекст, когда типом параметра может быть контекст модуля.
· Значение по умолчанию - задается после имени параметра и должно быть одного типа, что и тип для данного параметра. Возможные типы: Строка Пар1 = Значение по умолчанию; Число Пар1 = 100; Дата Пар1 = '01.01.2002'; также КОП и агрегатные объекты 1С:Предприятия. Значения по умолчанию возможно задать только в последних параметрах метода."
    },
    {"Item","AST","Неопределенное количество параметров","",
"Неопределенное количество параметров",
"",
"Метод объявленный с параметром … может принимать любое количество параметров при своем вызове. Параметры метода, которые определенны стандартным образом называются явными параметрами, а параметры, которые получены в ходе вызова метода в месте  определения троеточия и далее называются неявными.
@Пример:
void Метод1(Строка стрПар1, Число чПар2, …); , где параметры стрПар1, чПар2 являются явными и при вызове метода в них обязательно необходимо передавать значения их типов. Пример вызова данного метода может выглядеть так: МойКласс.Метод1({Пар3, Пар4, Пар5}, 200, Значение параметра 3, Значение параметра 4, Значение параметра 5); , где значения неявных параметров равны следующим строкам Значение параметра 3, Значение параметра 4, Значение параметра 5, количество таких значений в нашем примере равно 3, но оно может быть любым и зависит только от потребностей алгоритма. И в то же время явные параметры стрПар1 и чПар2 в нашем примере, соответственно получат значения {Пар3, Пар4, Пар5} и 200. В реализации метода Метод1  необходимо написать процедуру со следующей сигнатурой: Процедура Метод(стрПар1, чПар2) //Тело процедуры КонецПроцедуры. Значения неявных параметров можно получить вызвав общий метод класса ПолучитьСписокПараметров() (GetParamsList()), который возвращает список значений содержащий неявные значения параметров переданных в метод. В одном из явных параметров вы можете передать строку заключенную в фигурные скобки ({}) и содержащую названия ключей разделенных запятыми. Данные ключи сопоставляются с неявными параметрами в списке значений, которые в реализации метода класса можно получить использовав метод списка Получить(<Строка>). В нашем примере таким строковым, явным параметром является первый параметр метода стрПар1, значение которого при вызове метода равно {Пар3, Пар4, Пар5}, что означает в списке значений неявных параметров содержатся значения Значение параметра 3 строковый ключ которого равен Пар3, следующее значение Значение параметра 4, а ключ для него Пар4 и т.д."
    },
    },
 {"Folder","AST","1.4. Формат файлов реализации КОП","",
 {"Folder","AST","Описание формата","Format description",
    {"Item","AST","Описание формата","",
"Описание формата",
"",
"1.4.1. Для каждого КОП необходим отдельный файл реализации (как текстовый, так и отчет 1С) расположенный в каталоге БД или в папке указанной в определении имени файла класса, либо папке указанной в псевдониме пути. С именем класса связывается файл реализации КОП в файле определения Defcls.prm см. выше.
1.4.2. Синтаксис языка файла реализации КОП полностью соответствует синтаксису языка 1С:Предприятия плюс возможно использовать препроцессорные директивы.
1.4.3. Открытые атрибуты КОП определяются как общие переменные в модуле с ключевым словом Экспорт.
1.4.4. Закрытые атрибуты КОП определяются как общие переменные в модуле без ключевого слова Экспорт.
1.4.5. Обращения к методам компоненты из файлы реализации КОП (модуля КОП), таких как: ПолучитьБазовыйКласс и НазначитьБазовыйКласс, осуществляется через Контекст данного модуля. См. пример GetThis.
1.4.6. В каждой реализации класса можно создать процедуры Конструктор() англ. Constructor() и Деструктор() англ. Destructor(), которые вызываются соответственно в моменты создания экземпляра класса и его уничтожения (Конструктор() - объект создан, Деструктор() - объект уничтожен). Реализация данных процедур не обязательна.
1.4.7. Для контроля установки/записи атрибутов необходимо определить предопределенные методы (Процедура) в модуле реализации КОП (слово Экспорт к данным методам применять не обязательно):
• При чтении атрибута класса вызывается метод ПриПолучении_ИмяАтрибута(ЗначениеАтрибута) англ. OnGet_, где ИмяАтрибута - имя атрибута определенного в модуле КОП из которого выполняют считывание, ЗначениеАтрибута - текущее значение атрибута, также сам атрибут доступен из кода данного метода. Данный метод не изменяет состояние самого атрибута по умолчанию.
• При записи в атрибут класса вызывается метод ПриЗаписи_ИмяАтрибута(ЗначениеДляУст) англ. OnWrite_, где ИмяАтрибута - имя атрибута определенного в модуле КОП для которого устанавливают значение передаваемое в параметре ЗначениеДляУст. Атрибут доступен в коде данного метода и для установки его необходимо присвоить атрибуту полученный параметр метода. Данные метод не изменяет состояние самого атрибута по умолчанию.
• Динамические атрибуты класса, реализуются посредством написания предопределенных методов класса: 
o При чтении динамического атрибута класса вызывается предопределенная функция _ПриЧтенииСвойства(стрИмяАтрибута) англ. _OnReadProperty(strNameOfAttr) в параметр стрИмяАтрибута передается название атрибута, как оно было указано в вызывающем коде. Возвращать данный метод обязан значение считанного атрибута с названием, полученным из параметра метода стрИмяАтрибута.
o При установке значения атрибута экземпляра класса вызывается предопределенная процедура _ПриЗаписиСвойства(стрИмяАтрибута,  НовоеЗначениеАтриб), где стрИмяАтрибута имя записываемого свойства, а в параметре НовоеЗначениеАтриб содержится новое значение атрибута, т.е. правая часть выражения присваивания нового значения свойству класса.

Отладчик: Для получения информации в отладчике по динамическим свойствам класса, необходимо определить следующие функции:
1.      _GetNDynamicProps() / _ПолучитьКолвоДСвойств - возвращает количество динамических свойств.
2.      _GetPropDynamicName(nNPar) / _ПолучитьИмяДСвойства(чНомерПар) - должна возвратить имя по номеру динамического свойства, номер лежит в пределах от 1 до _GetNDynamicProps() включительно.
Внимание: Методы обязательно должны реализоваться оба, нельзя реализовать только один из них. Если вы определили данные методы, то отключаются: автоматическая установка/чтение статических атрибутов класса и не вызываются определенные методы обработки  установки/чтения ПриЗаписи_ИмяАтрибута и ПриПолучении_ИмяАтрибута. 
Вся обработка по сохранению/возврату значений атрибутов (свойств) ложиться на разработчика класса.

1.4.8. В базовых классах иерархии возможно вызывать методы производных классов, воспользовавшись для этого контекстом модуля базового класса, так же с помощью контекста возможно получить название конечного созданного класса с помощью СоздатьОбъект.
1.4.9. Экземпляры создаваемых классов можно сохранять в строку, а затем восстанавливать из неё (сериализация КОП). Для этого в классе необходимо определить следующие методы:
1.      IsSerializable() рус. КлассСохраняемый() /Функция/, метод который должен возвращать 1, если класс может быть восстановлен или записан в строку.
2.      SaveToString() рус. СохранитьКлассВСтроку() /Функция/, метод должен возвращать строку, по которой потом можно будет восстановить состояние экземпляра класса. Реализация данной функции производиться создателем класса.
3.      LoadFromString(str) рус. ЗагрузитьИзСтроки(стр) /Процедура/, в данный метод передается строка ранее полученная из метода СохранитьКлассВСтроку(), по которой можно восстановить состояние класса, существовавшее на момент сохранения. Данный метод необходимо реализовать с модификатором доступа Экспорт.
Если в классе реализован метод КлассСохраняемый(), который возвращает значение не равное 0, и реализован метод СохранитьКлассВСтроку(), то при использовании функции 1С ЗначениеВСтрокуВнутр(ЭкзКласса), вернет строку сформированную в классе ЭкзКласса методом СохранитьКлассВСтроку(). Внимание! Для восстановления классов КОП, поддерживающих сериализацию, необходимо напрямую вызывать его метод ЗагрузитьИзСтроки(), функция 1С ЗначениеИзСтрокиВнутр не может создавать экземпляры классов КОП. Поэтому можно реализовать вспомогательную функцию, которая бы создавала экз. классов КОП и вызывала их метод десериализации. Код мог быть следующим:
Функция глКлассИзСтрокиВнутр(стрЗнач) Экспорт
        сз = СоздатьОбъект(СписокЗначений);
        сз.ИзСтрокиСРазделителями(стрЗнач);
        Если сз.РазмерСписка() > 0 Тогда
                стрНазваниеКласса = сз.ПолучитьЗначение(1);
                Если ПустоеЗначение(стрНазваниеКласса)=1 Тогда
                  Возврат -2;
                КонецЕсли;  
                Попытка
                о = СоздатьОбъект(стрНазваниеКласса);
                        бКлассСохр = 0;
                        Попытка
                                бКлассСохр = о.IsSerializable();
                        Исключение
                                Попытка
                                        бКлассСохр = о.КлассСохраняемый();
                                Исключение
                                                Возврат -4;
                                КонецПопытки;   
                        КонецПопытки;
                        Если бКлассСохр = 0 Тогда
                          Возврат -4;
                        КонецЕсли;                              
                        Попытка
                                о.LoadFromString(сз.ВСтрокуСРазделителями());
                        Исключение
                                Попытка
                                  о.ЗагрузитьИзСтроки(сз.ВСтрокуСРазделителями());
                                Исключение
                                        Возврат -5;
                                КонецПопытки;
                        КонецПопытки;
                        Возврат о;
                Исключение
                        Возврат -3;
                КонецПопытки;
        Иначе
                Возврат -1;
        КонецЕсли;
КонецФункции //глКлассИзСтрокиВнутр
Примечание: Автоматическое групповое сохранение и восстановление экземпляров классов возможно выполнять с помощью класса DynaValue глава 3.6., см. описание методов ВыгрузитьВСтроку, ЗагрузитьИзСтроки, ВыгрузитьВФайл, ЗагрузитьИзФайла."
    },
    {"Item","AST","1.4.1. Введение","",
"1.4.1. Введение",
"",
"Для каждого КОП необходим отдельный файл реализации (как текстовый, так и отчет 1С) расположенный 
в каталоге БД или в папке указанной в определении имени файла класса, либо папке указанной в псевдониме 
пути. С именем класса связывается файл реализации КОП в файле определения Defcls.prm см. выше.
Синтаксис языка файла реализации КОП полностью соответствует синтаксису языка 1С:Предприятия плюс 
возможно использовать препроцессорные директивы.
"
    },
    {"Item","AST","1.4.2. Открытые атрибуты","",
"1.4.2. Открытые атрибуты",
"",
"Открытые атрибуты КОП определяются как общие переменные в модуле с ключевым словом Экспорт.
Закрытые атрибуты КОП определяются как общие переменные в модуле без ключевого слова Экспорт.
"
    },
    {"Item","AST","1.4.3. Обращения к методам компоненты","",
"1.4.3. Обращения к методам компоненты",
"",
"1.4.3. Обращения к методам компоненты из файлы реализации КОП (модуля КОП), таких как: 
ПолучитьБазовыйКласс и НазначитьБазовыйКласс, осуществляется через Контекст данного модуля. См. 
пример GetThis.
"
    },
    {"Item","AST","1.4.4. Конструкторы и Деструкторы.","",
"1.4.4. Конструкторы и Деструкторы.",
"",
"В каждой реализации класса можно создать процедуры Конструктор() англ. Constructor() и Деструктор() англ. 
Destructor(), которые вызываются соответственно в моменты создания экземпляра класса и его уничтожения 
(Конструктор() - объект создан, Деструктор() - объект уничтожен). Реализация данных процедур не обязательна.
"
    },
    {"Item","AST","1.4.5. Контроль за установкой/чтением атрибутов","",
"1.4.5. Контроль за установкой/чтением атрибутов",
"",
"Для контроля установки/чтения атрибутов необходимо определить предопределенные методы (Процедура) в 
модуле реализации КОП (слово Экспорт к данным методам применять не обязательно):
• При чтении атрибута класса вызывается метод ПриПолучении_ИмяАтрибута(ЗначениеАтрибута) англ. 
OnGet_, где ИмяАтрибута - имя атрибута определенного в модуле КОП из которого выполняют считывание, 
ЗначениеАтрибута - текущее значение атрибута, также сам атрибут доступен из кода данного метода. Данный 
метод не изменяет состояние самого атрибута по умолчанию.
• При записи в атрибут класса вызывается метод ПриЗаписи_ИмяАтрибута(ЗначениеДляУст) англ. OnWrite_, 
где ИмяАтрибута - имя атрибута определенного в модуле КОП для которого устанавливают значение 
передаваемое в параметре ЗначениеДляУст. Атрибут доступен в коде данного метода и для установки его 
необходимо присвоить атрибуту полученный параметр метода. Данные метод не изменяет состояние самого 
атрибута по умолчанию.
• Динамические атрибуты класса, реализуются посредством написания предопределенных методов класса: 
o При чтении динамического атрибута класса вызывается предопределенная функция _ПриЧтенииСвойства
(стрИмяАтрибута) англ. _OnReadProperty(strNameOfAttr) в параметр стрИмяАтрибута передается название 
атрибута, как оно было указано в вызывающем коде. Возвращать данный метод обязан значение считанного 
атрибута с названием, полученным из параметра метода стрИмяАтрибута.
o При установке значения атрибута экземпляра класса вызывается предопределенная процедура 
_ПриЗаписиСвойства(стрИмяАтрибута,  НовоеЗначениеАтриб), где стрИмяАтрибута имя записываемого 
свойства, а в параметре НовоеЗначениеАтриб содержится новое значение атрибута, т.е. правая часть 
выражения присваивания нового значения свойству класса.

Отладчик: Для получения информации в отладчике по динамическим свойствам класса, необходимо определить 
следующие функции:
1.      _GetNDynamicProps() / _ПолучитьКолвоДСвойств - возвращает количество динамических свойств.
2.      _GetPropDynamicName(nNPar) / _ПолучитьИмяДСвойства(чНомерПар) - должна возвратить имя по номеру 
динамического свойства, номер лежит в пределах от 1 до _GetNDynamicProps() включительно.
Внимание: Методы обязательно должны реализоваться оба, нельзя реализовать только один из них. Если вы 
определили данные методы, то отключаются: автоматическая установка/чтение статических атрибутов класса и 
не вызываются определенные методы обработки  установки/чтения ПриЗаписи_ИмяАтрибута и 
ПриПолучении_ИмяАтрибута. 
Вся обработка по сохранению/возврату значений атрибутов (свойств) ложиться на разработчика класса.
"
    },
    {"Item","AST","1.4.6. Обращение к методам производных классов","",
"1.4.6. Обращение к методам производных классов",
"",
"В базовых классах иерархии возможно вызывать открытые методы производных классов (объявленные со 
словом Экспорт), воспользовавшись для этого 
контекстом модуля базового класса, так же с помощью контекста возможно получить название конечного 
созданного класса с помощью СоздатьОбъект.
"
    },
    {"Item","AST","1.4.7. Сериализация экземпляров КОП","",
"1.4.7. Сериализация экземпляров КОП",
"",
"Экземпляры создаваемых классов можно сохранять в строку, а затем восстанавливать из неё (сериализация 
КОП). Для этого в классе необходимо определить следующие методы:
1.      IsSerializable() рус. КлассСохраняемый() /Функция/, метод который должен возвращать 1, если класс 
может быть восстановлен или записан в строку.
2.      SaveToString() рус. СохранитьКлассВСтроку() /Функция/, метод должен возвращать строку, по которой 
потом можно будет восстановить состояние экземпляра класса. Реализация данной функции производиться 
создателем класса.
3.      LoadFromString(str) рус. ЗагрузитьИзСтроки(стр) /Процедура/, в данный метод передается строка ранее 
полученная из метода СохранитьКлассВСтроку(), по которой можно восстановить состояние класса, 
существовавшее на момент сохранения. Данный метод необходимо реализовать с модификатором доступа 
Экспорт.
Если в классе реализован метод КлассСохраняемый(), который возвращает значение не равное 0, и реализован 
метод СохранитьКлассВСтроку(), то при использовании функции 1С ЗначениеВСтрокуВнутр(ЭкзКласса), вернет 
строку сформированную в классе ЭкзКласса методом СохранитьКлассВСтроку(). Внимание! Для 
восстановления классов КОП, поддерживающих сериализацию, необходимо напрямую вызывать его метод 
ЗагрузитьИзСтроки(), функция 1С ЗначениеИзСтрокиВнутр не может создавать экземпляры классов КОП. 
Поэтому можно реализовать вспомогательную функцию, которая бы создавала экз. классов КОП и вызывала 
их метод десериализации. Код мог быть следующим:
Функция глКлассИзСтрокиВнутр(стрЗнач) Экспорт
        сз = СоздатьОбъект(СписокЗначений);
        сз.ИзСтрокиСРазделителями(стрЗнач);
        Если сз.РазмерСписка() > 0 Тогда
                стрНазваниеКласса = сз.ПолучитьЗначение(1);
                Если ПустоеЗначение(стрНазваниеКласса)=1 Тогда
                  Возврат -2;
                КонецЕсли;  
                Попытка
                о = СоздатьОбъект(стрНазваниеКласса);
                        бКлассСохр = 0;
                        Попытка
                                бКлассСохр = о.IsSerializable();
                        Исключение
                                Попытка
                                        бКлассСохр = о.КлассСохраняемый();
                                Исключение
                                                Возврат -4;
                                КонецПопытки;   
                        КонецПопытки;
                        Если бКлассСохр = 0 Тогда
                          Возврат -4;
                        КонецЕсли;                              
                        Попытка
                                о.LoadFromString(сз.ВСтрокуСРазделителями());
                        Исключение
                                Попытка
                                  о.ЗагрузитьИзСтроки(сз.ВСтрокуСРазделителями());
                                Исключение
                                        Возврат -5;
                                КонецПопытки;
                        КонецПопытки;
                        Возврат о;
                Исключение
                        Возврат -3;
                КонецПопытки;
        Иначе
                Возврат -1;
        КонецЕсли;
КонецФункции //глКлассИзСтрокиВнутр
Примечание: Автоматическое групповое сохранение и восстановление экземпляров классов возможно 
выполнять с помощью класса DynaValue глава 3.6., см. описание методов ВыгрузитьВСтроку, 
ЗагрузитьИзСтроки, ВыгрузитьВФайл, ЗагрузитьИзФайла.
"
    },
    {"Item","AST","1.4.8. Хранение нескольких классов в одном модуле","",
"1.4.8. Хранение нескольких классов в одном модуле",
"",
"Для хранения кода нескольких классов в одном модуле необходимо перед началом 
кода класса вставить строку
//# ClassBegin <ClassName>;
а после окончания кода класса - строку
//# ClassEnd <ClassName>;
где вместо <ClassName> нужно указать имя класса (без угловых скобок). Пробелы имеют значение.
Ограничения:
-Текст одного класса обязательно должен идти одним куском.
-Штатный синтаксис-контроль подобных модулей не работает.
-Формирование ALS-файлов для таких классов - невозможно.
"
    },
    },
 {"Folder","AST","Примеры","Examples",
    {"Item","AST","Пример","",
"Пример",
"",
"Иерархия классов выглядит так:
class База = base.ert
{
        void Метод1(); // Этот метод мы не переопределяем, а вызываем здесь 
                                      // Метод2 производного класса
        void Метод2();  
};    
class Производный = derive.ert : Тест14_База
{
        void Метод2(); // переопределяем метод базового класса
};  

Модуль реализации класса База:

Функция GetThis(Конт) Возврат Конт; КонецФункции 

Процедура Метод2() Экспорт
        Сообщить(База::Метод2); 
КонецПроцедуры
Процедура Метод1() Экспорт
        Сообщить(ТипзначенияСтр(Контекст) = +ТипзначенияСтр(GetThis(Контекст))); // получаем название текущего класса
        GetThis(Контекст).Метод2(); // вызываем переопределенный метод
КонецПроцедуры

Модуль реализации класса Производный:

Процедура Метод2() Экспорт
        Сообщить(Производный::Метод2); 
КонецПроцедуры
        
Модуль:
Сообщить(Создали Производный класс);
копПрозв = СоздатьОбъект(Производный);
копПрозв. Метод1();
Сообщить(Создали База класс);
копБаза = СоздатьОбъект(База);
копБаза. Метод1();

Вывод на экран будет следующим:
Создали Производный класс
        Производный
Производный::Метод2
Создали База класс
        База
        База::Метод2"
    },
    {"Item","AST","Пример GetThis","",
"Пример GetThis",
"",
"// В начале каждого модуля определяем закрытую функцию для получения
// контекста.
Функция GetThis(Конт) Возврат Конт; КонецФункции

// Реализация метода Метод1 класса Производный_1 см. предыдущий пример
Процедура Метод1 (пар1, пар2) Экспорт
Конт = GetThis(Контекст);
        Базовый_1 = Конт.ПолучитьБазовыйКласс(Базовый_1);
        Если Базовый_1 <> 0 Тогда
                
КонецЕсли;
КонецПроцедуры
        
@Внимание!!!
Предупреждение: нельзя сохранять контекст класса в его атрибуте, т.е. запрещен следующий алгоритм: 
Перем конт;
Функция GetThis(Конт) Возврат Конт; КонецФункции
……………
Конт = GetThis(Контекст);
……………
Если Вы будете использовать такое присваивание, объекты класса созданные Вами в алгоритмах с помощью конструкции СоздатьОбъект(ИмяКлассаКОП) никогда не уничтожаться (memory leaks), из-за циклической ссылки на объект внутри модуля реализации КОП."
    },
    {"Item","AST","Пример хранения нескольких классов в одном модуле","",
"Пример хранения нескольких классов в одном модуле",
"",
"@defcls.prm
class theOne = Only.txt
{};
class theTwo = Only.txt
{};

@Only.txt
//# ClassBegin theOne;
Перем Переменная;

Процедура Конструктор()
    Переменная = 1;
КонецПроцедуры

Процедура Тест() Экспорт
    Сообщить(Переменная);
КонецПроцедуры
//# ClassEnd theOne;

//# ClassBegin theTwo;
Перем Переменная;

Процедура Конструктор()
    Переменная = 2;
КонецПроцедуры

Процедура Тест() Экспорт
    Сообщить(Переменная);
КонецПроцедуры
//# ClassEnd theTwo;

@код клиента
Один = СоздатьОбъект(""theOne"");
Два = СоздатьОбъект(""theTwo"");
Один.Тест();
Два.Тест();

сообщит нам
1
2
"
    },
    },
    },
 {"Folder","AST","1.5 Препроцессор","",
    {"Item","AST","Введение","",
"Введение",
"",
"Директивы препроцессора 1С++ могут быть в файлах объявления интерфейсов классов (Defcls.prm), а также в файлах реализации КОП. Символы препроцессора объявленные в файле объявления класса действительны в области видимости реализации класса, т.е. доступны в файлах реализации КОП. Внимание, из-за раздельной интерпретации файла Defcls.prm и файлов реализации КОП изменения, определение и отключение символов препроцессора, осуществляются независимо. Работа препроцессора гарантируется в следующей последовательности: сначала обрабатывается файл Defcls.prm, затем в неопределенной последовательности обрабатываются файлы реализации КОП. Внимание! Все директивы препроцессора должны начинаться с новой строки и тело ее не должно переноситься на следующую строку."
    },
    {"Item","AST","//#if symbol [operator symbol]...","//#if symbol [operator symbol]...",
"//#if symbol [operator symbol]...",
"//#if symbol [operator symbol]...",
"@Синтаксис:
//#if symbol [operator symbol]...
@Назначение:
Если символ определен, что равнозначно истине или символы объеденные логическими операторами дают в результате истину, то код заключенный между директивами //#if  и //#elif  или  //#else или  //#endif буден включен на выполнение. 
Symbol - это символ, который будет тестироваться на определенность ранее директивой //#define. Перед символом можно использовать знак ! -  логическое отрицание. 
Operator:
 =      (равно);
!=      (не равно);
&       (И);
|       (ИЛИ);
@Замечание:
Тело с кодом открытое директивой //#if должно закрываться директивами //#elif , //#else , //#endif ."
    },
    {"Item","AST","//#else","//#else",
"//#else",
"//#else",
"@Синтаксис:
//#else
@Назначение:
Директива, тело которой получает управление, если выражение равно ложь в предшествующей ей директивах //#if или //#elif.
@Замечание:
Тело с кодом должно заканчиваться директивой //#endif."
    },
    {"Item","AST","//#elif symbol [operator symbol]...","//#elif symbol [operator symbol]...",
"//#elif symbol [operator symbol]...",
"//#elif symbol [operator symbol]...",
"@Синтаксис:
//#elif symbol [operator symbol]...
@Назначение:
Директива, управление на которую передается, если в предыдущих директивах //#elif и //#if была получена ложь. Проверяется условия указанные symbol [operator symbol]… и если получена истина, код заключенный в блоке между //#elif  и следующим за ним директивой //#elif  или #else или //#endif  включается в код модуля КОП.
@Замечание:
Описание symbol [operator symbol]... см. у директивы //#if"
    },
    {"Item","AST","//#define symbol","//#define symbol",
"//#define symbol",
"//#define symbol",
"@Синтаксис:
//#define symbol
@Назначение:
Определяет символ условной компиляции, использование этого символа в условных директивах даст истину, с условием отсутствия снятия этого символа ранее директивой //#undef"
    },
    {"Item","AST","//#undef symbol","//#undef symbol",
"//#undef symbol",
"//#undef symbol",
"@Синтаксис:
//#undef symbol
@Назначение:
Убирает определенный ранее символ.
@Замечание:
Символ используется для условной интерпретации  кода в директивах //#if, //#elif, //#else."
    },
    {"Item","AST","//#warning text","//#warning text",
"//#warning text",
"//#warning text",
"@Синтаксис:
//#warning text
@Назначение:
Выводит text в окно сообщений 1С.
@Замечание:
В Defcls.prm данная директива отключена."
    },
    {"Item","AST","//#error text","//#error text",
"//#error text",
"//#error text",
"@Синтаксис:
//#error text
@Назначение:
Останавливает выполнение кода программы в этом месте с выводом text в окно сообщений 1С.
@Замечание:
В Defcls.prm данная директива отключена."
    },
    {"Item","AST","//#preprocessor off","//#preprocessor off",
"//#preprocessor off",
"//#preprocessor off",
"@Синтаксис:
//#preprocessor off
@Назначение:
Данная директива должна располагаться в первой строке модуля и служит для выключения препроцессорной обработки кода модуля."
    },
    {"Item","AST","//#exinfo","//#exinfo",
"//#exinfo",
"//#exinfo",
"@Синтаксис:
//#exinfo
@Назначение:
//#exinfo - данная директива может быть использована только в модулях реализации КОП. Директива выводит информацию пользователю о месте вызова метода, в котором она расположена и строку кода, который осуществил вызов метода. В основном используется в отладочных целях."
    },
    {"Item","AST","//#include <#alias></pathname/>namefile.ext","//#include <#alias></pathname/>namefile.ext",
"//#include <#alias></pathname/>namefile.ext",
"//#include <#alias></pathname/>namefile.ext",
"@Синтаксис:
//#include <#alias></pathname/>namefile.ext
@Назначение:
директива служит для вкладывание других файлов определения в основной файл проекта (ИБ) Defcls.prm. В пути к файлу может быть использован псевдоним, определенный в OXY.INI, относительный путь или полный путь к файлу определения. Каталогом по умолчанию считается каталог ИБ. Расширение файла может быть txt, prm - обычные текстовые файлы и ert - модуль отчета 1С
@Замечание:
Следует крайне осторожно использовать данную директиву в модулях КОП!
@Пример:
//#include ОбщиеКлассы\РасширеннаяТаблицаЗначений.prm
Включает в текущий текст определения классов, текст файла РасширеннаяТаблицаЗначений.prm расположенного  в подкаталоге \ОбщиеКлассы\ каталога ИБ."
    },
    {"Item","AST","//#curmeth","",
"//#curmeth",
"",
"@Синтаксис:
//#curmeth
@Назначение:
директива выводит на экран текущий исполняемый метод класса и его параметры с актуальными значениями и типами в месте появления данной директивы. Примечание: в Defcls.prm данная директива отключена."
    },
    },
    {"Item","AST","1.6. Отладка классов 1C++","",
"1.6. Отладка классов 1C++",
"",
"Для отладки модулей классов необходимо выполнить следующие действия:
1.      В настройках компоненты 1С++ нажать кнопку Отладка;
2.      В глобальном модуле конфигурации прописать экспортную переменную Перем Форма Экспорт;
3.      Если модуль класса расположен в текстовом файле, то следует сохранить его в модуле отчета;
4.      Форма отчета, в котором храниться модуль класса обязана иметь хотя бы один диалоговый элемент.
5.      В модуле класса прописать предопределенную функцию ПриОткрытии и вставить туда следующий код: 
Процедура ПриОткрытии()
      Форма.Параметр._ПриОткрытии();
КонецПроцедуры
Внимание! Не допускается использование функции СтатусВозврата(0) в теле процедура ПриОткрытии()
Внимание! Рекомендуется, в клиентском режиме 1С:Предприятия, выключать режим Отладки."
    },
    {"Item","AST","1.8. Проводник для 1С++ (Visual 1C++ 1.0 by Alex Orefkov)","",
"1.8. Проводник для 1С++ (Visual 1C++ 1.0 by Alex Orefkov)",
"",
"Проводник для классов предназначен облегчить задачу разработки и поддержки классов. Данный продукт 
реализован в виде плагина к стандартному редактору 1С:Предприятия. Данный продукт является неотъемлемой 
частью проекта Открытый конфигуратор автора Александра Орефкова, с ним можно связаться по адресу: 
orefkov@ezmail.ru. Описание возможностей данного проекта вы найдете в комплекте поставки папка OpenConfig 
файл ReadMe.txt.
1.      Установка проводника.
Для установки проводника необходимо выполнить следующие шаги:
a.      Закройте все открытые программы семейства 1С:Предприятие.
b.      Перепишите каталог CONFIG из комплекта поставки в каталог BIN программы 1С:Предприятие;
c.      Из каталога BIN перенесите файл config.dll в каталог BIN/CONFIG 1С:Предприятия;
d.      Из комплекта поставки перепишите в каталог BIN 1С:Предприятия файл config.dll.
e.      После осуществления всех перечисленных выше шагов, запустите 1С:Предприятие в режиме 
конфигуратора, откройте конфигурацию и, если вы все сделали правильно, у вас должна появиться 
дополнительная закладка в нижней части экрана под названием 1С++ с пиктограммой  .
2.      Дерево классов расположено в окне конфигурации на закладке с названием 1С++
"
    },
    {"Item","AST","1.7. Настройка 1C++","",
"1.7. Настройка 1C++",
"",
"Настройка компоненты осуществляется с помощью настройки параметров 1С, Сервис -> Параметры … -> Закладка Настройка 1C++. Данная закладка появляется только после загрузки компоненты методом 1С ЗагрузитьВнешнююКомпоненту см. выше.
На данной закладке присутствуют два флажка в виде кнопок: Проверка типов и Оптимизация:
• Проверка типов включает, строгую проверку типов во время выполнения кода, при этом несколько увеличивается время вызова метода, в финальной версии программного продукта рекомендуется отключать;
• Оптимизация представляет собой метод отложенных вычислений, который реализован в следующем виде: если в системе не разу не инстанцировался (создавался экземпляр КОП) класс, то его реализация (модуль КОП) не считывается с диска и не компилируется в P-код. При первом создании объекта КОП происходит считывание с диска модуля и его компиляция, далее откомпилированный модуль сохраняется в репозитории модулей КОП и в последующих созданиях объектов, этапы по считыванию с диска и компиляции не производятся. Данная оптимизация позволяет существенно увеличить время создания объектов КОП, за счет увеличения используемой памяти компьютера, что не существенно для данного вида оптимизации. Это режим рекомендуется включать в финальной версии продукта. При отключенной оптимизации при каждом создании объекта происходит считывание с диска и компиляция модуля КОП, что позволяет вносить изменения в модуль без закрытия\открытия 1С в режиме 1С:Предприятие. По аналогии с #LoadFromFile для модулей 1С."
    },
    {"Item","AST","2. Обратная связь и соглашение на использование компоненты","",
"2. Обратная связь и соглашение на использование компоненты",
"",
"1. Все пожелания, предложения и ошибки присылайте по почте debbuger@yandex.ru
2. Все права на компоненту 1C++ принадлежат разработчику - Гусеву Дмитрию Андреевичу и фирме OXY.
3. Данная компонента является бесплатным, открытым проектом и может использоваться свободно в целях: обучения принципам ООП, использования на практике в реальных проектах. 
4. Техническая поддержка в полной мере осуществляется только для клиентов заключивших договор на обслуживание на данную компоненту. Положение в пункте 3 не означает о полном отсутствии технической поддержи со стороны разработчика.
5. Ответственность за финансовые (включая все, без исключений, случаи упущенной выгоды, нарушение хозяйственной деятельности, потери информации или других убытков), временные и любые другие потери разработчик не несет. Кроме пункта 3 данного соглашения, ответственность и обязательства, которые несет разработчик, определяются в договоре на обслуживание.
6. Все классы, реализованные с помощью 1C++ принадлежат пользователю, создавшему их."
    },
 {"Folder","AST","3. Дополнительные классы компоненты","",
 {"Folder","AST","РаботаСРегистромWin","WorkAsRegisterWin",
    {"Item","AST","Назначение","",
"Назначение",
"",
"Предназначен для работы с реестром Windows в стиле языка 1С:Предприятия.
@Позволяет:
• создавать, открывать ключи реестра, подключаться к реестру удаленного компьютера;
• добавляет в ключи строковые и числовые значения, удалять значения из ключей реестра;
• перебирать ключи и значения ключей;
• организовывать поиск ключа или значения по имени."
    },
    {"Item","AST","СоздатьКлюч","CreateKey",
"СоздатьКлюч(<?>)",
"CreateKey(<?>)",
"@Синтаксис:
СоздатьКлюч(<Ключ>,<Имя>,<Режим>)
@Возвращаемое значение:
(Число)  
-1 - ошибка
0 - ключ с таким название уже существует и будет просто открыт
1 - ключ успешно создан
@Параметры:
<Ключ> - (Строка)  строка с названием ветви реестра. Названия строго определены и бывают следующих видов:
• HKEY_CLASSES_ROOT
• HKEY_CURRENT_CONFIG
• HKEY_CURRENT_USER
• HKEY_LOCAL_MACHINE
• HKEY_USERS
<Имя> - (Строка)  строка с названием ключа реестра (например: Software\1C\1Cv7\7.7)
<Режим> - (Строка)  Desired - строка с режимом создания ключа. Названия строго определены и бывают следующих видов:
• KEY_CREATE_LINK                       Permission to create a symbolic link.
• KEY_CREATE_SUB_KEY            Permission to create subkeys.
• KEY_ENUMERATE_SUB_KEYS        Permission to enumerate subkeys.
• KEY_EXECUTE                   Permission for read access.
• KEY_NOTIFY                    Permission for change notification.
• KEY_QUERY_VALUE               Permission to query subkey data.
• KEY_SET_VALUE                 Permission to set subkey data.
• KEY_ALL_ACCESS                        Combines the KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, KEY_NOTIFY, KEY_CREATE_SUB_KEY, KEY_CREATE_LINK, and KEY_SET_VALUE access rights, plus all the standard access rights except SYNCHRONIZE. 
• KEY_READ                      Combines the STANDARD_RIGHTS_READ, KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY access rights.
• KEY_WRITE                     Combines the STANDARD_RIGHTS_WRITE, KEY_SET_VALUE, and KEY_CREATE_SUB_KEY access rights."
    },
    {"Item","AST","ОкрытьКлюч","OpenKey",
"ОкрытьКлюч(<?>)",
"OpenKey(<?>)",
"@Синтаксис:
ОкрытьКлюч(<Ключ>,<Имя>,<Режим>)
@Возвращаемое значение:
(Число)  
0 - ошибка
1 - ключ с открыт
@Параметры:
<Ключ> - (Строка)  строка с названием ветви реестра. Названия строго определены и бывают следующих видов:
• HKEY_CLASSES_ROOT
• HKEY_CURRENT_CONFIG
• HKEY_CURRENT_USER
• HKEY_LOCAL_MACHINE
• HKEY_USERS
<Имя> - (Строка)  строка с названием ключа реестра. Например Software\1C\1Cv7\7.7
<Режим> - (Строка)  строка с режимом создания ключа. Названия строго определены и бывают следующих видов:
• KEY_CREATE_LINK                       Permission to create a symbolic link.
• KEY_CREATE_SUB_KEY            Permission to create subkeys.
• KEY_ENUMERATE_SUB_KEYS        Permission to enumerate subkeys.
• KEY_EXECUTE                   Permission for read access.
• KEY_NOTIFY                    Permission for change notification.
• KEY_QUERY_VALUE               Permission to query subkey data.
• KEY_SET_VALUE                 Permission to set subkey data.
• KEY_ALL_ACCESS                        Combines the KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, KEY_NOTIFY, KEY_CREATE_SUB_KEY, KEY_CREATE_LINK, and KEY_SET_VALUE access rights, plus all the standard access rights except SYNCHRONIZE. 
• KEY_READ                      Combines the STANDARD_RIGHTS_READ, KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY access rights.
• KEY_WRITE                     Combines the STANDARD_RIGHTS_WRITE, KEY_SET_VALUE, and KEY_CREATE_SUB_KEY access rights."
    },
    {"Item","AST","ПодключитьРегистр","ConnectRegistry",
"ПодключитьРегистр(<?>)",
"ConnectRegistry(<?>)",
"@Синтаксис:
ПодключитьРегистр(<ИмяУдаленногоКомпьютера>,<Ключ>)
@Назначение:
Метод используется для подключения к реестру удаленного компьютера.
@Возвращаемое значение:
(Число)  
0 - ошибка
1 - соединение установлено
@Параметры:
<ИмяУдаленногоКомпьютера> - (Строка)  сетевое имя компьютера к реестру которого необходимо подключиться (например: \\computername). Если указать пустую строку, то метод подключиться к локальной машине.
<Ключ> - (Строка)  строка с названием ветви реестра. Названия строго определены и бывают следующих видов:
• HKEY_LOCAL_MACHINE
• HKEY_USERS
@Замечание:
Для возможности успешного подключения к компьютеру с установленной операционной системой Windows 95 необходимо инсталлировать на нем Microsoft Remote Registry service."
    },
    {"Item","AST","УдалитьКлюч","DeleteKey",
"УдалитьКлюч(<?>)",
"DeleteKey(<?>)",
"@Синтаксис:
УдалитьКлюч(<ИмяПодКлюча>)
@Назначение:
Удаляет подключ указанный в параметре NameSubKey , открытого  ранее ключа функцией ОткрытьКлюч() или СоздатьКлюч().
@Возвращаемое значение:
(Число)  
0 - была ошибка;
1 - удаление закончено успешно
@Параметры:
<ИмяПодКлюча> - (Строка)"
    },
    {"Item","AST","УдалитьЗначение","DeleteValue",
"УдалитьЗначение(<?>)",
"DeleteValue(<?>)",
"@Синтаксис:
УдалитьЗначение(<ИмяЗначения>)
@Назначение:
Удаляет значение указанное в параметре NameSubValue,открытого  ранее ключа функцией ОткрытьКлюч() или СоздатьКлюч().
@Возвращаемое значение:
(Число)  
0 - была ошибка;
1 - удаление закончено успешно.
@Параметры:
<ИмяЗначения> - (Строка)"
    },
    {"Item","AST","УстановитьЗначение","SetValue",
"УстановитьЗначение(<?>)",
"SetValue(<?>)",
"@Синтаксис:
УстановитьЗначение(<ИмяЗначения>,<ТипЗначения>,<Значение>)
@Назначение:
Устанавливает значение указанное в параметре NameValue, открытого  ранее ключа функцией ОткрытьКлюч() или СоздатьКлюч().
@Возвращаемое значение:
(Число)  
0 - была ошибка;
1 - установка закончена успешно.
@Параметры:
<ИмяЗначения> - (Строка)  название значения в ключе
<ТипЗначения> - (Строка)  может принимать только два значения:
• REG_SZ - тип значения строка
• REG_DWORD - тип значения целое число
<Значение> -   значение которое необходимо установить, зависит от типа установленного в предыдущем параметре."
    },
    {"Item","AST","ЗапроситьЗначение","QueryValue",
"ЗапроситьЗначение(<?>)",
"QueryValue(<?>)",
"@Синтаксис:
ЗапроситьЗначение(<ИмяЗначения>,<Значение>)
@Назначение:
Запросить значение указанное в параметре NameValue, открытого  ранее ключа функцией ОткрытьКлюч() или СоздатьКлюч(). Если операция выполнена успешно, то результат будет в Value. Тип значений которые можно получить может быть только REG_SZ или REG_DWORD.
@Возвращаемое значение:
(Число)  
0 - была ошибка;
1 - запрос закончен успешно
@Параметры:
<ИмяЗначения> - (Строка)  название значения в ключе
<Значение> -   полученное значение"
    },
    {"Item","AST","ВыбратьКлючи","ChooseKeys",
"ВыбратьКлючи(<?>)",
"ChooseKeys(<?>)",
"@Синтаксис:
ВыбратьКлючи()
@Назначение:
Открывает выборку подключей ключа установленного функцией ОткрытьКлюч() или СоздатьКлюч().
@Возвращаемое значение:
(Число)  
0 - неудачная попытка получить подключи;
Количество - подключей в выборке."
    },
    {"Item","AST","ПолучитьКлюч","GetKey",
"ПолучитьКлюч(<?>)",
"GetKey(<?>)",
"@Синтаксис:
ПолучитьКлюч(<ИмяПодКлюча>)
@Возвращаемое значение:
(Число)  
0 - выборка пуста;
1 - в выборке еще есть подключи.
@Параметры:
<ИмяПодКлюча> - (Строка)  строка в которой возвращается название подключа полученного из выборки открытой ранее методом ВыбратьКлючи()"
    },
    {"Item","AST","ВыбратьЗначения","ChooseValues",
"ВыбратьЗначения(<?>)",
"ChooseValues(<?>)",
"@Синтаксис:
ВыбратьЗначения()
@Назначение:
Открывает выборку значений ключа установленного функцией ОткрытьКлюч() или СоздатьКлюч().
@Возвращаемое значение:
(Число)  
0 - неудачная попытка получить значения;
Количество - значений в выборке."
    },
    {"Item","AST","ПолучитьЗначение","GetValue",
"ПолучитьЗначение(<?>)",
"GetValue(<?>)",
"@Синтаксис:
ПолучитьЗначение(<ИмяЗначения>)
@Возвращаемое значение:
(Число)  
0 - выборка пуста;
1 - в выборке еще есть значения
@Параметры:
<ИмяЗначения> - (Строка)  строка в которой возвращается название значения полученного из выборки открытой ранее методом ВыбратьЗначения()"
    },
    {"Item","AST","ОтладочныеСообщения","EnableDebug",
"ОтладочныеСообщения(<?>)",
"EnableDebug(<?>)",
"@Синтаксис:
ОтладочныеСообщения(<Включить>)
@Назначение:
Включает/отключает отладочные сообщения при возникновения ошибок работы с реестром
@Параметры:
<Включить> - (Число)  1 включить, 0 - отключить"
    },
    {"Item","AST","ЗаписатьВсеАтрибуты","Flash",
"ЗаписатьВсеАтрибуты(<?>)",
"Flash(<?>)",
"@Синтаксис:
ЗаписатьВсеАтрибуты()
@Назначение:
Немедленно записать изменения внесенные ранее в реестр."
    },
    },
 {"Folder","AST","ВыполняемыйМодуль","ExecuteModule",
    {"Item","AST","Назначение","",
"Назначение",
"",
"Предназначен для работы с динамическими модулями, передаваемые в параметр метода в виде строки."
    },
    {"Item","AST","УстановитьМодуль","AssignSource",
"УстановитьМодуль(<?>)",
"AssignSource(<?>)",
"@Синтаксис:
УстановитьМодуль(<стрТекстМодуля>)
@Назначение:
Устанавливает текст модуля на выполнение. В модуле возможно определять любые функция, процедуры и параметры доступ к которым возможно осуществлять, через оператор селектор .(точка) объекта класса ВыполняемыйМодуль, после компилирования и запуска.
@Параметры:
<стрТекстМодуля> - (Строка)"
    },
    {"Item","AST","НазначитьКонтекст","AssignContext",
"НазначитьКонтекст(<?>)",
"AssignContext(<?>)",
"@Синтаксис:
НазначитьКонтекст(<Контекст>)
@Назначение:
Устанавливает контекст модуля.
@Параметры:
<Контекст> - (Групповой контекст)"
    },
    {"Item","AST","ПрисоединитьТекущийМодуль","AssignFriendModule",
"ПрисоединитьТекущийМодуль(<?>)",
"AssignFriendModule(<?>)",
"@Синтаксис:
ПрисоединитьТекущийМодуль()
@Назначение:
Присоединяет модуль, который в данный момент выполняется (т.е. модуль в котором идет работа в данный момент с объекта класса ВыполняемыйМодуль), что позволяет в установленном модуле объекта обращаться на прямую к параметрам и методам текущего модуля."
    },
    {"Item","AST","КомпилироватьМодуль","Compile",
"КомпилироватьМодуль(<?>)",
"Compile(<?>)",
"@Синтаксис:
КомпилироватьМодуль()
@Назначение:
Компилирует модуль установленный с помощью метода класса ВыполняемыйМодуль::УстановитьМодуль(<стрТекстМодуля>).
@Возвращаемое значение:
(Число)  1, если компиляция прошла успешно, 0 в случае не удачи."
    },
    {"Item","AST","ВыполнитьМодуль","Execute",
"ВыполнитьМодуль(<?>)",
"Execute(<?>)",
"@Синтаксис:
ВыполнитьМодуль()
@Назначение:
Выполняет модуль установленный с помощью метода класса ВыполняемыйМодуль::УстановитьМодуль(<стрТекстМодуля>) и откомпилированный методом ВыполняемыйМодуль::КомпилироватьМодуль().
@Возвращаемое значение:
(Число)  1, если выполнение начато успешно, 0 в случае не удачи."
    },
    {"Item","AST","GetMethOfContext","GetMethOfContext",
"GetMethOfContext(<?>)",
"GetMethOfContext(<?>)",
"@Синтаксис:
GetMethOfContext(<Object>)
@Назначение:
Выводит в окно сообщений все методы переданного в параметре Object объекта.
@Параметры:
<Object> - (Объект)"
    },
    {"Item","AST","СформироватьОшибку","RaiseError",
"СформироватьОшибку(<?>)",
"RaiseError(<?>)",
"@Синтаксис:
СформироватьОшибку(<ТекстОшибки>)
@Назначение:
Останавливает выполнение текущего модуля с сообщением об ошибке переданным в параметре метода ТекстОшибки.
@Параметры:
<ТекстОшибки> - (Строка)"
    },
    {"Item","AST","ОчиститьПозициюПроведения","ErasePostState",
"ОчиститьПозициюПроведения(<?>)",
"ErasePostState(<?>)",
"@Синтаксис:
ОчиститьПозициюПроведения()
@Назначение:
Очищает позицию проведения и сохраняет текущую в объекте. Далее в модуле документа можно проводить другие документы и отменять проведение других документов, после выполнения этих операций необходимо восстановить позицию с помощью метода RestorePostState() описанного ниже.
@Замечание:
Внимание!
Проверка работоспособности метода была произведена только на релизе 1С 7.70.017."
    },
    {"Item","AST","ВосстановитьПозициюПроведения","RestorePostState",
"ВосстановитьПозициюПроведения(<?>)",
"RestorePostState(<?>)",
"@Синтаксис:
ВосстановитьПозициюПроведения()
@Назначение:
Восстанавливает позицию проведения текущего документа очищенную с помощью метода ErasePostState().
@Замечание:
Внимание!
Метод ErasePostState() и RestorePostState() необходимо вызывать всегда в паре в указанной последовательности!!!
Проверка работоспособности метода была произведена только на релизе 1С 7.70.017."
    },
    {"Item","AST","ВыброситьИскл","Throw",
"ВыброситьИскл(<?>)",
"Throw(<?>)",
"@Синтаксис:
ВыброситьИскл(<ОбъектИскл>,<ТекстИскл>)
@Назначение:
Формирует исключение с объектом, который можно получить при перехвате/обработке исключения с помощью метода GetExeption()/ПолучитьИсключение()
@Параметры:
<ОбъектИскл> - (Неопределенный)  Любой объект 1С
<ТекстИскл> - (Строка)  Необязательный параметр.   Текст исключения, которое можно получить с помощью глобально функции ОписаниеОшибки() или которое выведется в окно сообщений, если исключение не будет обработано"
    },
    {"Item","AST","ПолучитьИсключение","GetExeption",
"ПолучитьИсключение(<?>)",
"GetExeption(<?>)",
"@Синтаксис:
ПолучитьИсключение()
@Назначение:
Метод использует в обработчиках исключений для получения объекта исключения сформированного с помощью метода Throw()/ВыброситьИскл() или метода функционала класса _ Throw()/_ВыброситьИскл описание которого см. в разделе 1.2.
@Возвращаемое значение:
(Неопределенный)  Объект-исключение."
    },
    },
 {"Folder","AST","Делегат","Delegate",
    {"Item","AST","Назначение","",
"Назначение",
"",
"Данный представляет собой хранилище ссылок на методы экземпляров агрегатных объектов 1С. С помощью этого класса возможно вызывать группу методов с одинаковой сигнатурой (возвращаемый параметр, количество параметров или их отсутствие). Использование делегата позволяет писать обобщенные алгоритмы и делать групповые вызовы методов."
    },
    {"Item","AST","ОпределитьТип","DefineType",
"ОпределитьТип(<?>)",
"DefineType(<?>)",
"@Синтаксис:
ОпределитьТип(<чКолПарам>,<чЕстьВозврат>)
@Назначение:
Метод определяет количество параметров у методов и тип методов (функция/процедура) ссылки на которые будет содержать делегат (сигнатура метода для вызова).
@Параметры:
<чКолПарам> - (Число)  количество параметров, которые будут передаваться в методы делегата;
<чЕстьВозврат> - (Число)  1 - методы в делегате есть функции, 0 - методы в делегате есть процедуры;"
    },
    {"Item","AST","Добавить","AddMethod",
"Добавить(<?>)",
"AddMethod(<?>)",
"@Синтаксис:
Добавить(<ЭкземплярАрегатногоОбъекта>,<стрИмяМетода>,<стрКлюч>)
@Назначение:
Метод предназначен для установки/добавления в делегат ссылки на метод агрегатного объекта для его дальнейшего вызова. Сигнатура метода объекта для установки должна соответствовать указанной в DefineType();
@Возвращаемое значение:
(Число)  
1 - добавление метода прошло успешно;
0 - указанный метод уже существует в делегате.
@Параметры:
<ЭкземплярАрегатногоОбъекта> -   объект созданный инструкцией языка СоздатьОбъект() или Контекст окружения;
<стрИмяМетода> - (Строка)  имя метода, который будет вызван;
<стрКлюч> - (Строка)  Необязательный параметр.   необязательный параметр, но, если указан можно вызывать метод по указанному ключу с помощью метода делегата ВызватьПоКлючу/ InvokeByKey"
    },
    {"Item","AST","Удалить","RemMethod",
"Удалить(<?>)",
"RemMethod(<?>)",
"@Синтаксис:
Удалить(<ЭкземплярАрегатногоОбъекта>,<стрИмяМетода>)
@Назначение:
Удалить ссылку на метод агрегатного объекта;
@Возвращаемое значение:
(Число)  
1 - удаление метода прошло успешно;
0 - указанного метода не существует в делегате.
@Параметры:
<ЭкземплярАрегатногоОбъекта> -   объект созданный инструкцией языка СоздатьОбъект() или Контекст окружения;
<стрИмяМетода> - (Строка)  имя метода;"
    },
    {"Item","AST","Вызвать","Invoke",
"Вызвать(<?>)",
"Invoke(<?>)",
"@Синтаксис:
Вызвать(<...>)
@Назначение:
Метод вызывает методы находящиеся в делегате.
@Возвращаемое значение:
  Возвращает или нет значение этот метод определяется методом ОпределитьТип() делегата, вызванным ранее.
@Параметры:
<...> -   Необязательный параметр.   количество параметров или их отсутствие определяется методом ОпределитьТип() делегата, вызванным ранее."
    },
    {"Item","AST","Очистить","Erase",
"Очистить(<?>)",
"Erase(<?>)",
"@Синтаксис:
Очистить()
@Назначение:
Метод удаляет из делегата все установленные в нем ранее методы."
    },
    {"Item","AST","Пустой","IsEmpty",
"Пустой(<?>)",
"IsEmpty(<?>)",
"@Синтаксис:
Пустой()
@Назначение:
Метод проверяет, есть ли методы в делегате, которые необходимо вызвать
@Возвращаемое значение:
(Число)  возвращает 0, если делегат не содержит ссылок на методы, 1 - содержит"
    },
    {"Item","AST","ВызватьПоКлючу","InvokeByKey",
"ВызватьПоКлючу(<?>)",
"InvokeByKey(<?>)",
"@Синтаксис:
ВызватьПоКлючу(<стрКлюч>,<<0…n>>)
@Назначение:
метод вызывает метод находящийся в делегате по указанному ключу, если такой ссылки с ключом нем ничего не вызывается.
@Возвращаемое значение:
  Возвращает или нет значение этот метод определяется методом ОпределитьТип() делегата, вызванным ранее
@Параметры:
<стрКлюч> - (Строка)  ключ по которому происходит поиск ссылки
<<0…n>> -   количество параметров или их отсутствие определяется методом ОпределитьТип() делегата, вызванным ранее."
    },
    },
 {"Folder","AST","МенеджерСобытий","EventManager",
    {"Item","AST","Назначение","",
"Назначение",
"",
"Данный класс предназначен для обработки событий возникающих в классах КОП и других контекстах использования менеджера.
@Например:
Есть класс, который формирует различные события и называется он ФабрикаСобытий (издатель событий), предположим, что обращение к его открытым методам Событие_1 и  Событие_2 приводят к возникновению событий в системе от этого класса. Далее у нас есть несколько классов, которые хотят подписаться на события (подписчики событий) формируемые классом ФабрикаСобытий, и назовем их ОбработчикСобытий_1 и ОбработчикСобытий_2. Экземпляры классов - обработчиков событий (подписчиков) определяют свои методы, которые будут вызываться при возникновении в экземпляре класса ФабрикаСобытий определенных событий. Далее я опишу методы класса МенеждерСобытий и ниже приведу пример кода, с краткими пояснениями реализующий описанную схему."
    },
    {"Item","AST","Пустой","IsEmpty",
"Пустой(<?>)",
"IsEmpty(<?>)",
"@Синтаксис:
Пустой()
@Назначение:
Метод проверяет наличие в менеджере событий подписчиков.
@Возвращаемое значение:
(Число)  1, если подписчиков нет и 0 - когда такие подписчики есть;"
    },
    {"Item","AST","ДобавитьОбработчикСобытия","AddEventHandle",
"ДобавитьОбработчикСобытия(<?>)",
"AddEventHandle(<?>)",
"@Синтаксис:
ДобавитьОбработчикСобытия(<копПодписчик>,<стрИмяМетода>)
@Назначение:
Метод предназначен для подписки на событие экземплярами классов - подписчиков.
@Возвращаемое значение:
(Число)  
1 - добавление подписчика прошло успешно;
0 - данный подписчик с таким методом уже зарегистрирован в менеджере событий.
@Параметры:
<копПодписчик> -   ссылка на экземпляр класса - подписчика;
<стрИмяМетода> - (Строка)  имя метода класса - подписчика, который будет вызываться при возникновении событий, управляемых классом - менеджером, и определенный в виде функции-члена  класса-подписчика, принимающей два параметра по умолчанию: 
- Publisher или Издатель, в этот параметр передается экземпляр класса - издателя; 
- ExtParametrs или ДопПараметры в этот параметр передается любая информация посланная с помощью метода класса МенеджерСобытий SendEvent/ ПослатьСобытие() описанного ниже. Количество параметров заданных по умолчанию возможно изменить с помощью установки отдельно созданного делегата передать его в качестве параметра метода УстановитьДелегата() или передать число параметров в метод УстановитьКоличествоПараметров(), оба метода описаны ниже; 
- Каждая функция обязана возвращать числовое значение. Если функция возвращает 0, то цепочка обработки события прерывается на данном подписчике, т.е. если у нас есть менеджер событий в котором зарегистрировано 5 подписчиков и 2-ой по счету, в своей функции возвращает 0, то 3 последующих подписчика не получать данное событие, другими словами рассылка будет прервана на подписчике с номером 2. Если же функция возвращает любое другое числовое значение отличное от нуля, то рассылка события менеджером не прерывается."
    },
    {"Item","AST","УдалитьОбработчикСобытия","RemEventHandle",
"УдалитьОбработчикСобытия(<?>)",
"RemEventHandle(<?>)",
"@Синтаксис:
УдалитьОбработчикСобытия(<копПодписчик>,<стрИмяМетода>)
@Назначение:
Данный метод служит для снятия с подписки на событие, подписчика раннее подписавшегося на него с помощью метода AddEventHandle/ДобавитьОбработчикСобытия.
@Возвращаемое значение:
(Число)  
1 - с подписки снят;
0 - нет, данный подписчик ранее не был зарегистрирован методом AddEventHandle/ДобавитьОбработчикСобытия.
@Параметры:
<копПодписчик> -   экземпляр класса - подписчика;
<стрИмяМетода> - (Строка)  имя метода класса - подписчика;"
    },
    {"Item","AST","ПослатьСобытие","SendEvent",
"ПослатьСобытие(<?>)",
"SendEvent(<?>)",
"@Синтаксис:
ПослатьСобытие(<Издатель>,<ДопПараметр>)
@Назначение:
Метод посылает событие всем зарегистрировавшимся подписчикам на него.
@Возвращаемое значение:
(Число)  1 - цепочка рассылки событий пройдена полностью, 0 - рассылка была прервана одним из подписчиков.
@Параметры:
<Издатель> -   контекст окружения в котором возникло событие или контекст экземпляра класса - издателя;
<ДопПараметр> -   любая дополнительная информация, которая будет доступна в методе экземпляра класса - подписчика во втором параметре."
    },
    {"Item","AST","УстановитьДелегата","SetDelegate",
"УстановитьДелегата(<?>)",
"SetDelegate(<?>)",
"@Синтаксис:
УстановитьДелегата(<ЭкземплярДелегата>)
@Назначение:
Устанавливает делегата.
@Возвращаемое значение:
  возвращает старый установленный раннее делегат или делегат по умолчанию, содержащийся в текущем менеджере событий.
@Параметры:
<ЭкземплярДелегата> -   экземпляр делегата, через который будет осуществляться вызов методов подписчиков;"
    },
    {"Item","AST","Очистить","Clear",
"Очистить(<?>)",
"Clear(<?>)",
"@Синтаксис:
Очистить()
@Назначение:
Очистить менеджер событий от подписчиков."
    },
    {"Item","AST","УстановитьКоличествоПараметров","SetCountOfParams",
"УстановитьКоличествоПараметров(<?>)",
"SetCountOfParams(<?>)",
"@Синтаксис:
УстановитьКоличествоПараметров(<чКолвоПарам>)
@Назначение:
Устанавливает количество параметров, которые должны принимать подписчики и количество параметров, которые необходимо передавать в метод ПослатьСобытие().
@Параметры:
<чКолвоПарам> - (Число)
@Замечание:
Данный метод удаляет все подписчиков установленных ранее в менеджере событий."
    },
    {"Item","AST","Пример","Example",
"Пример",
"Example",
"Определение класса ФабрикаСобытий
класс ФабрикаСобытий=EventFactory.ert 
{
        void Событие_1();
        void Событие_2();
};
Реализация класса ФабрикаСобытий файл EventFactory.ert
Перем МенеджерСобытий1 Экспорт;
Перем МенеджерСобытий2 Экспорт;

Функция GetThis(Конт) Возврат Конт; КонецФункции

Процедура Конструктор()
        МенеджерСобытий1 = СоздатьОбъект(МенеджерСобытий);
        МенеджерСобытий2 = СоздатьОбъект(МенеджерСобытий);
КонецПроцедуры

Процедура Событие_1()
        Если МенеджерСобытий1.Пустой() = 0 Тогда
                МенеджерСобытий1.ПослатьСобытие(GetThis(Контекст), Событие произошло!);
        КонецЕсли;
КонецПроцедуры
Процедура Событие_2()
        Если МенеджерСобытий2.Пустой() = 0 Тогда
                сз = СоздатьОбъект(СписокЗначений);
                сз.ДобавитьЗначение(100, Парам1);
сз.ДобавитьЗначение(200, Парам2);
сз.ДобавитьЗначение(300, Парам3);
                МенеджерСобытий2.ПослатьСобытие(GetThis(Контекст), сз);
        КонецЕсли;
КонецПроцедуры

Определим классы подписчики ОбработчикСобытий_1 и ОбработчикСобытий_2, в нашем примере определение этих классов будет одинаковой.

класс ОбработчикСобытий_1=TreaterEvetns_1.ert 
{
        Число ОбработкаСобытия_1(Неопределенный, Строка);
Число ОбработкаСобытия_2(Неопределенный, СписокЗначений);
};
Реализация этих классов может быть любая, в нашем примере она тривиальна и описание ее я опущу.

В любо модуле системы для запуска механизма обработки событий пишем следующий код:
ОбрСобытий_1 = СоздатьОбъект(ОбработчикСобытий_1);
ОбрСобытий_2 = СоздатьОбъект(ОбработчикСобытий_2);
ФабрикаСобытий = СоздатьОбъект(ФабрикаСобытий);

// Регистрируем подписчиков и их методы - обработчики событий
ФабрикаСобытий.МенеджерСобытий1.ДобавитьОбработчикСобытия(ОбрСобытий_1, ОбработкаСобытия_1);
ФабрикаСобытий.МенеджерСобытий1.ДобавитьОбработчикСобытия(ОбрСобытий_2, ОбработкаСобытия_1);

ФабрикаСобытий.МенеджерСобытий2.ДобавитьОбработчикСобытия(ОбрСобытий_1, ОбработкаСобытия_2);
ФабрикаСобытий.МенеджерСобытий2.ДобавитьОбработчикСобытия(ОбрСобытий_2, ОбработкаСобытия_2);

// Вызываем методы, которые формирую событие (издают)
ФабрикаСобытий.Событие_1();
ФабрикаСобытий.Событие_2();
// Далее происходит вызов всех методов зарегистрированных в менеджере экземпляров классов - подписчиков."
    },
    },
 {"Folder","AST","Структура","Struct",
    {"Item","AST","Назначение","",
"Назначение",
"",
"Данный класс предназначен, для имитирования структуры данных других языков. Структура является динамическим объектом, что означает возможность программного управления количеством и названиями свойств структуры."
    },
 {"Folder","AST","Методы","Methods",
    {"Item","AST","Вставить","Insert",
"Вставить(<?>)",
"Insert(<?>)",
"@Синтаксис:
Вставить(<стрКлюч>,<нЗначение>,<чРежим>)
@Назначение:
метод добавляет свойство в структуру
@Параметры:
<стрКлюч> - (Строка)  Строка название свойства структуры, если такое свойство уже существует, то его значение изменяется, если не существует создается новое
<нЗначение> - (Неопределенный)  Необязательный параметр.   Значение свойства, которое необходимо установить (необязательный)
<чРежим> - (Строка)  Необязательный параметр.   0 - нЗначение сохраняется в структуре по ссылке, 1 - нЗначение сохраняется в структуре по значению (необязательный), по умолчанию - 1"
    },
    {"Item","AST","Количество","Count",
"Количество(<?>)",
"Count(<?>)",
"@Синтаксис:
Количество()
@Назначение:
возвращает количество свойств структуры
@Возвращаемое значение:
(Число)  Количество свойств структуры"
    },
    {"Item","AST","Очистить","Clear",
"Очистить(<?>)",
"Clear(<?>)",
"@Синтаксис:
Очистить()
@Назначение:
Удаляет все свойства структуры"
    },
    {"Item","AST","Свойство","Property",
"Свойство(<?>)",
"Property(<?>)",
"@Синтаксис:
Свойство(<стрКлюч>,<нЗначение>)
@Назначение:
Позволяет получить значение элемента по указанному имени, а также проверить имеется ли указанное свойство
@Возвращаемое значение:
(Число)  1 - свойство с ключом найдено, 0 - не найдено
@Параметры:
<стрКлюч> - (Строка)  Строка название для поиска свойства структуры
<нЗначение> - (Неопределенно)  Необязательный параметр.   В данный параметр возвращается найденное значение. Если ключа нет в структуре, то возвращается Неопределенно (Необязательный)."
    },
    {"Item","AST","Удалить","Remove",
"Удалить(<?>)",
"Remove(<?>)",
"@Синтаксис:
Удалить(<стрКлюч>)
@Назначение:
Удаляет элемент структуры с заданным ключом
@Параметры:
<стрКлюч> - (Строка)  Ключ  элемента, который требуется удалить"
    },
    {"Item","AST","Получить","Get",
"Получить(<?>)",
"Get(<?>)",
"@Синтаксис:
Получить(<чИндекс>,<стрИмяСвойства>)
@Назначение:
метод позволяет получать по индексу значение свойства и его имя
@Возвращаемое значение:
  значение свойства, полученное по его номеру
@Параметры:
<чИндекс> - (Число)  номер поля по порядку от 1 до Количество()
<стрИмяСвойства> - (Строка)  Необязательный параметр.   необязательный параметр, в него записывается имя свойства полученное по его номеру"
    },
    },
 {"Folder","AST","Атрибуты","",
    {"Item","AST","<Свойство>","<Property>",
"<Свойство>",
"<Property>",
"@Синтаксис:
<Свойство>
@Назначение:
Программно определяемые свойства, имя которых определяется параметром стрКлюч в методе Вставить.
Свойста можно читать и записывать. Значения записанных свойств копируются при присваивании/вставке"
    },
    },
    },
 {"Folder","AST","DynaValue","DynaValue",
 {"Folder","AST","Методы","",
    {"Item","AST","ДобавитьСвойство","AddProp",
"ДобавитьСвойство(<?>)",
"AddProp(<?>)",
"@Синтаксис:
ДобавитьСвойство(<стрИмя>,<нЗначение>)
@Назначение:
Добавляет новое свойство. Возвращает добавленное значение.
@Параметры:
<стрИмя> - (Строка)  имя свойства
<нЗначение> - (Неопределенный)  значение свойства"
    },
    {"Item","AST","ВыбратьСвойства","SelectProps",
"ВыбратьСвойства(<?>)",
"SelectProps(<?>)",
"@Синтаксис:
ВыбратьСвойства()
@Назначение:
Открывает выборку свойств
@Возвращаемое значение:
(Число)  1 если выбрано хоть одно свойство, иначе 0."
    },
    {"Item","AST","ПолучитьСвойство","GetProp",
"ПолучитьСвойство(<?>)",
"GetProp(<?>)",
"@Синтаксис:
ПолучитьСвойство(<нЗначение>,<стрИмя>)
@Назначение:
Получить следующее свойство из открытой выборки (ВыбратьСвойства())
@Возвращаемое значение:
(Число)  1 - если свойство получено или 0 - если выборка кончилась
@Параметры:
<нЗначение> - (Неопределенный)  переменная для получения значения
<стрИмя> - (Строка)  переменная для получения имени"
    },
    {"Item","AST","КоличествоСвойств","GetNProps",
"КоличествоСвойств(<?>)",
"GetNProps(<?>)",
"@Синтаксис:
КоличествоСвойств()
@Назначение:
получить количество свойств
@Возвращаемое значение:
(Число)  размер объекта."
    },
    {"Item","AST","ВыгрузитьВСтроку","SaveToString",
"ВыгрузитьВСтроку(<?>)",
"SaveToString(<?>)",
"@Синтаксис:
ВыгрузитьВСтроку()
@Назначение:
Возвращает строку с содержимым объекта для хранения в таблицах (справочниках) и последующего восстановления.
@Возвращаемое значение:
(Строка)  строка состояние объекта.
@Замечание:
Примечания: 
- выгружается абсолютно все содержимое независимо от количества уровней вложенности. 
- Для возможного сохранения классов КОП, которые могут содержаться в DynaValue, необходимо чтобы эти классы соответствовали требованиям, описанным в 1.4.9."
    },
    {"Item","AST","ВыгрузитьВФайл","SaveToFile",
"ВыгрузитьВФайл(<?>)",
"SaveToFile(<?>)",
"@Синтаксис:
ВыгрузитьВФайл(<стрИмяФайла>)
@Назначение:
Сохраняет состояние объекта в файл.
@Возвращаемое значение:
(Число)  1 - произошла ошибка, 1 - выгрузка произведена успеш
@Параметры:
<стрИмяФайла> - (Строка)  имя файла, в который производится выгрузка состояния"
    },
    {"Item","AST","ЗагрузитьИзСтроки","LoadFromString",
"ЗагрузитьИзСтроки(<?>)",
"LoadFromString(<?>)",
"@Синтаксис:
ЗагрузитьИзСтроки(<стрСтрока>)
@Назначение:
Восстанавливает значение объекта из выгрузки в строку. Предыдущее состояние объекта не сохранятся.
@Параметры:
<стрСтрока> - (Строка)  Восстанавливает значение объекта из выгрузки в строку. Предыдущее состояние объекта не сохранятся.
@Замечание:
- восстанавливаются значения всех элементов, включая агрегатные.
- категорически запрещается передавать методу LoadFromString в качестве параметра, что-либо кроме строк выгруженных методом SaveToString по причине невозможности проконтролировать целостность данных. В случае неверной строки происходит немедленное прекращение работы программы 1С с потерей всех, не сохраненных на данный момент, данных.
- Запрещены циклические ссылки между элементами объектов, один из которых подлежит выгрузке в строку. В этом случае произойдет зацикливание программы 1С и со временем прекращение работы программы 1С с потерей всех, не сохраненных на данный момент, данных.
- Для восстановления состояния классов КОП вызывается их метод ЗагрузитьИзСтроки, за более подробной информацией обращайтесь в 1.4.9."
    },
    {"Item","AST","ЗагрузитьИзФайла","LoadFromFile",
"ЗагрузитьИзФайла(<?>)",
"LoadFromFile(<?>)",
"@Синтаксис:
ЗагрузитьИзФайла(<стрИмяФайла>)
@Назначение:
Восстанавливает значения объектов из файла. Предыдущее состояние объекта не сохранятся. См. примечание у метода ЗагрузитьИзСтроки.
@Возвращаемое значение:
(Строка)  1 - произошла ошибка, 1 - загрузка произведена успешно
@Параметры:
<стрИмяФайла> - (Строка)  имя файла, из которого производится загрузка"
    },
    {"Item","AST","НайтиПоИмени","FindByName",
"НайтиПоИмени(<?>)",
"FindByName(<?>)",
"@Синтаксис:
НайтиПоИмени(<стрИмя>)
@Назначение:
Поиск свойства по имени.
@Возвращаемое значение:
(Число)  номер свойства (от нуля) или -1 если не найдено
@Параметры:
<стрИмя> - (Строка)  имя свойства, которое ищем"
    },
    {"Item","AST","ПолучитьПоИмени","GetByName",
"ПолучитьПоИмени(<?>)",
"GetByName(<?>)",
"@Синтаксис:
ПолучитьПоИмени(<стрИмя>)
@Назначение:
Получение свойства по имени
@Возвращаемое значение:
(Неопределенный)  значение свойства (или значения для DynaValueList) по номеру (от нуля).
@Параметры:
<стрИмя> - (Строка)  имя свойства"
    },
    {"Item","AST","УстановитьПоИмени","SetByName",
"УстановитьПоИмени(<?>)",
"SetByName(<?>)",
"@Синтаксис:
УстановитьПоИмени(<стрИмя>,<нЗначение>)
@Назначение:
Устанавливает значение свойства по имени свойства.
@Параметры:
<стрИмя> - (Строка)  имя свойства
<нЗначение> - (Неопределенный)  новое значение"
    },
    {"Item","AST","УстановитьПоНомеру","SetByNum",
"УстановитьПоНомеру(<?>)",
"SetByNum(<?>)",
"@Синтаксис:
УстановитьПоНомеру(<чНомер>,<нЗначение>)
@Параметры:
<чНомер> - (Число)  порядковый номер свойства, нумерация начинается с 0 и заканчивается КоличествоСвойств() - 1;
<нЗначение> - (Неопределенный)  новое значение"
    },
    {"Item","AST","УдалитьПоНомеру","DeleteByNum",
"УдалитьПоНомеру(<?>)",
"DeleteByNum(<?>)",
"@Синтаксис:
УдалитьПоНомеру(<чНомер>)
@Назначение:
удаляет свойство по указанному номеру
@Параметры:
<чНомер> - (Число)  порядковый номер свойства, нумерация начинается с 0 и заканчивается КоличествоСвойств() - 1;"
    },
    {"Item","AST","УдалитьПоИмени","DeleteByName",
"УдалитьПоИмени(<?>)",
"DeleteByName(<?>)",
"@Синтаксис:
УдалитьПоИмени(<стрИмя>)
@Назначение:
удаляет свойство по указанному названию.
@Параметры:
<стрИмя> - (Строка)  имя удаляемого свойства"
    },
    {"Item","AST","Очистить","Clear",
"Очистить(<?>)",
"Clear(<?>)",
"@Синтаксис:
Очистить()
@Назначение:
удаляет все свойства"
    },
    {"Item","AST","СвойстваВСписокЗначений","PropsToValueList",
"СвойстваВСписокЗначений(<?>)",
"PropsToValueList(<?>)",
"@Синтаксис:
СвойстваВСписокЗначений(<сз>)
@Назначение:
метод выгружает в список значений все значения свойств и имена свойств
@Параметры:
<сз> - (СписокЗначений)  переменная, в которую возвращается заполненный список значений"
    },
    {"Item","AST","НайтиПоЗначению","FindByValue",
"НайтиПоЗначению(<?>)",
"FindByValue(<?>)",
"@Синтаксис:
НайтиПоЗначению(<нЗнач>,<чИндекс>)
@Назначение:
метод ищет значение в объекте и если находит, возвращает значение и индекс в чИндекс
@Возвращаемое значение:
(Неопределенный)  если значение найдено, возвращается оно же, иначе пустой объект
@Параметры:
<нЗнач> - (Неопределенный)  значение которое ищем в объекте
<чИндекс> - (Число)  индекс найденного значения в объекте, если не найдено устанавливается в -1"
    },
    {"Item","AST","НайтиПоЗначениюАтрибута","FindByAtributeValue",
"НайтиПоЗначениюАтрибута(<?>)",
"FindByAtributeValue(<?>)",
"@Синтаксис:
НайтиПоЗначениюАтрибута(<стрИмяАтрибута>,<нЗнач>,<чИндекс>)
@Назначение:
ищет свойство у которого есть атрибут с указанным именем стрИмяАтрибута и содержащее указанное значение нЗнач.
@Возвращаемое значение:
(Неопределенный)  если значение найдено, возвращается значение свойства у которого был обнаружен атрибут, иначе возвращается пустой объект.
@Параметры:
<стрИмяАтрибута> - (Строка)  имя для поиска атрибута в объекте, который хранится в свойстве DynaValue
<нЗнач> - (Неопределенный)  значение которое ищем в атрибуте значения свойства
<чИндекс> - (Число)  индекс найденного свойства, в котором храниться другой объект, имеющий атрибут с именем стрИмяАтрибута и содержащий значение указанное в нЗнач, если не найдено устанавливается в -1."
    },
    },
    {"Item","AST","Назначение","",
"Назначение",
"",
"@Синтаксис:
Назначение
@Назначение:
Объект DynaValue представляет собой массив поименованных свойств или иными словами составное значение. Свойства принимают тип значения переданного параметром при добавлении свойства. Чтение/Установка свойства осуществляется через точку по имени свойства."
    },
    },
 {"Folder","AST","MetaInfoClasses","MetaInfoClasses",
    {"Item","AST","Назначение","",
"Назначение",
"",
"@Синтаксис:
Назначение
@Назначение:
3.7. Класс MetaInfoClasses
        Класс позволяет получить мета - информацию по классам, методам, параметрам методов, определенным символам препроцессора, псевдонимам путей, версию 1С++, текущие настройки 1С++, вложенным файлам (директивой #include). А также формировать по специальным комментариям в файлах определения классов (*.prm) XML - документацию и ALS - документацию по классам. Все специальные комментарии формируются в виде XML текста и определяются наличием трех знаков /// перед их началом. Например:
///<class name = МойКласс Version = 1.0 LastDate =  
///descr = Мой первый класс с XML - комментариями
///depends =  use =  author = Гусев Д.А. firm = OXY base =  
///example =  remark = >
// А это обычный комментарий, которые не проверяется XML - парсером
class МойКласс=МойКласс.ert 
{
};       
///</class>
Для возможности формирования ALS - файла из XML комментариев определены 6 специальных тэгов названия, которых можно изменять:
·       Пространство имен (по умолчанию namespace). Этот тэг формирует папку в синтаксис помощнике 1С
·       Класс (по умолчанию class)
·       Метод (по умолчанию method)
·       Параметр метода (по умолчанию param)
·       Возвращаемое значение (по умолчанию returns)
·       Свойство (по умолчанию property)
·       У всех выше описанных тэгов, кроме возвращаемого значения, обязан быть атрибут имя (по умолчанию name)
Пример в примере жирным выделенных все необходимые тэги и атрибуты:
/// <namespace name=Мои супер классы>
//****************************************************************************
///<class name = МойКласс Version = 1.0 LastDate =  
///descr = 
///depends =  use =  author = Гусев Д.А. firm = OXY base =  
///example =  remark = >
class МойКласс=МойКласс.ert 
{
//*********************************************************************
        /// <property name=Атрибут1 access=Public type=Строка>
        /// Атрибут первый
        /// </property>
        //**********************************************************************
        /// <method name=Метод access=Public>
        /// <summary></summary>
        /// <example></example>
        /// <remark></remark>
        /// <param name=Число mod=[in] | [out] type=чПарам1 defaultValue = 1>Параметр первый</param>
        /// <returns type=Число>Что </returns>
        /// <sig>
        Число Метод(Число чПарам1 = 1);
        /// </sig> 
        /// </method>
};       
///</class>
/// </namespace>
В поставку с ВК включен демонстрационный пример формирования als-файла для класса. И предложен шаблоны заполнения для 1C редактора, где есть сокращения: класс\ мет\ пар\ св\ прим\ и их англ. эквиваленты."
    },
    {"Item","AST","НастройкаALS","TuningALS",
"НастройкаALS(<?>)",
"TuningALS(<?>)",
"@Синтаксис:
НастройкаALS(<strNameSpace>,<strNameClass>,<strNameMethod>,<strNameProperty>,<strNameNames>,<strNameParam>,<strNameReturns>)
@Назначение:
настраивает названия тэгов для выгрузки XML-описании классов в als-файл
@Параметры:
<strNameSpace> - (Строка)  Пространство имен (по умолчанию namespace). Этот тэг формирует папку в синтаксис помощнике 1С;
<strNameClass> - (Строка)  Класс (по умолчанию class) Этот тэг формирует папку в синтаксис помощнике 1С
<strNameMethod> - (Строка)  Метод (по умолчанию method)
<strNameProperty> - (Строка)  Свойство (по умолчанию property);
<strNameNames> - (Строка)  У всех выше описанных тэгов, кроме возвращаемого значения, обязан быть атрибут имя (по умолчанию name);
<strNameParam> - (Строка)  Параметр метода (по умолчанию param)
<strNameReturns> - (Строка)  Возвращаемое значение (по умолчанию returns)"
    },
    {"Item","AST","УстФильтрПоКлассам","SetFilterClasses",
"УстФильтрПоКлассам(<?>)",
"SetFilterClasses(<?>)",
"@Синтаксис:
УстФильтрПоКлассам(<стрФильтр>)
@Назначение:
устанавливает фильтр по выгружаемым классам в als-файл содержащихся в текущей конфигурации.
@Параметры:
<стрФильтр> - (Строка)  имена классов, разделенные запятой, которые необходимо выгружать в als-файл. Пустая строка - фильтр отключен и выгружаться будут все комментированные классы"
    },
    {"Item","AST","УстФильтрПоПростИмен","SetFilterNamespace",
"УстФильтрПоПростИмен(<?>)",
"SetFilterNamespace(<?>)",
"@Синтаксис:
УстФильтрПоПростИмен(<стрФильтр>)
@Назначение:
устанавливает фильтр по пространству имен для выгрузки в als-файл.
@Параметры:
<стрФильтр> - (Строка)  имена пространст имен, разделенные запятой, которые необходимо выгружать в als-файл. Пустая строка - фильтр отключен и выгружаться будут все"
    },
    {"Item","AST","СоздатьALS","CreateALS",
"СоздатьALS(<?>)",
"CreateALS(<?>)",
"@Синтаксис:
СоздатьALS(<стрИмяФайлаALS>,<стрИмяКорня>)
@Назначение:
формирует по XML - описаниям классов специального формата, описанного выше, als - файл помощника 1С. И формирует XML-файл описаний. Настройки для этого метода осуществляются с помощью следующих методов: TuningALS, SetFilterClasses, SetFilterNamespace, описание которых см. выше.
@Параметры:
<стрИмяФайлаALS> - (Строка)  имя файла als
<стрИмяКорня> - (Строка)  имя корневой папки в синтаксис помощнике, в которой будут помещаться описания классов."
    },
    {"Item","AST","ПолучитьЗагрВложФайлы","GetLoadIncludeFiles",
"ПолучитьЗагрВложФайлы(<?>)",
"GetLoadIncludeFiles(<?>)",
"@Синтаксис:
ПолучитьЗагрВложФайлы()
@Назначение:
возвращает список с именами вложенных файлов - загруженных с помощью препроцессорной директивы #include
@Возвращаемое значение:
(СписокЗначений)  Список значений, значения в котором есть имена файлов."
    },
    {"Item","AST","ПолучитьОпрСимволыПрепроц","GetDefSymbolOfPreproc",
"ПолучитьОпрСимволыПрепроц(<?>)",
"GetDefSymbolOfPreproc(<?>)",
"@Синтаксис:
ПолучитьОпрСимволыПрепроц()
@Назначение:
возвращает список определенных препроцессорной директивой #define символов.
@Возвращаемое значение:
(СписокЗначений)  Список значений, значения в котором есть имена символов."
    },
    {"Item","AST","ПолучитьВсеИменаКлассов","GetAllClassesNames",
"ПолучитьВсеИменаКлассов(<?>)",
"GetAllClassesNames(<?>)",
"@Синтаксис:
ПолучитьВсеИменаКлассов()
@Назначение:
возвращает список имен классов и полных путей до них
@Возвращаемое значение:
(СписокЗначений)  Список значений, значения в котором есть имена классов, а в символьном представлении полный путь к его реализации."
    },
    {"Item","AST","ПолучитьПсевдИ_Пути","GetAllAliasAndPath",
"ПолучитьПсевдИ_Пути(<?>)",
"GetAllAliasAndPath(<?>)",
"@Синтаксис:
ПолучитьПсевдИ_Пути()
@Назначение:
возвращает список псевдонимов и путей которые они определяют
@Возвращаемое значение:
(СписокЗначений)  Список значений, значения в котором есть имена псевдонимов, а в символьном представлении их содержимое"
    },
    {"Item","AST","ПолучитьИменаМетодовКласса","GetNamesMethOfClass",
"ПолучитьИменаМетодовКласса(<?>)",
"GetNamesMethOfClass(<?>)",
"@Синтаксис:
ПолучитьИменаМетодовКласса(<стрИмяКласса>)
@Назначение:
возвращает список имен методов у класса.
@Возвращаемое значение:
(СписокЗначений)  Список значений, значения в котором есть имена методов.
@Параметры:
<стрИмяКласса> - (Строка)  Имя класса, имена методов которого мы желаем получить.
@Замечание:
Внимание! метод работает, только для тех методов, которые были определенных в файлах - определений классов (*.prm)."
    },
    {"Item","AST","ПолучитьИнфоПоПар","GetInfoParamMeth",
"ПолучитьИнфоПоПар(<?>)",
"GetInfoParamMeth(<?>)",
"@Синтаксис:
ПолучитьИнфоПоПар(<стрИмяКласса>,<стрИмяМетода>)
@Назначение:
возвращает список предопределенных структур параметров метода класса с полями: Имя - имя параметра, Имя - тип параметра, Значение - значение по умолчанию для параметра, Режим - имеет два состояния ПоЗначению и ПоСылке.
@Возвращаемое значение:
(СписокЗначений)  Список значений, значения в котором есть структуры с предопределенными полями.
@Параметры:
<стрИмяКласса> - (Строка)  Имя класса
<стрИмяМетода> - (Строка)  Имя метода
@Замечание:
Внимание! метод работает, только для тех методов, которые были определенных в файлах - определений классов (*.prm)."
    },
    {"Item","AST","КлассСуществует","IsClassExist",
"КлассСуществует(<?>)",
"IsClassExist(<?>)",
"@Синтаксис:
КлассСуществует(<стрИмяКласса>)
@Назначение:
определяет, существует ли в системе зарегистрированный класс с таким именем.
@Возвращаемое значение:
(Число)  1 - существует, 0 - не существует.
@Параметры:
<стрИмяКласса> - (Строка)  Имя класса."
    },
    {"Item","AST","МетодСуществует","IsMethExist",
"МетодСуществует(<?>)",
"IsMethExist(<?>)",
"@Синтаксис:
МетодСуществует(<стрИмяКласса>,<стрИмяМетода>)
@Назначение:
определяет, существует ли в системе зарегистрированный класс с таким именем и методом
@Возвращаемое значение:
  1 - существует, 0 - не существует.
@Параметры:
<стрИмяКласса> - (Строка)  Имя класса
<стрИмяМетода> - (Строка)  Имя метода
@Замечание:
Внимание! метод работает, только для тех методов, которые были определенных в файлах - определений классов (*.prm)."
    },
    {"Item","AST","ПолучитьВерсию","GetVersion",
"ПолучитьВерсию(<?>)",
"GetVersion(<?>)",
"@Синтаксис:
ПолучитьВерсию()
@Назначение:
возвращает номер текущей версии ВК 1С++
@Возвращаемое значение:
(Число)  Номер версии, число без точек. Пример: если версия ВК 1.1.1.0, то метод вернет 1110"
    },
    {"Item","AST","ПолучитьТекУстановки","GetCurSettings",
"ПолучитьТекУстановки(<?>)",
"GetCurSettings(<?>)",
"@Синтаксис:
ПолучитьТекУстановки(<бВклОптимимзация>,<бВклПроверкаТипов>,<бВклРежимОтладки>)
@Назначение:
метод возвращает установки ВК, которые настраиваются в параметрах на закладке Настройки 1С++ почитать о которых можно в разделе 1.7.
@Параметры:
<бВклОптимимзация> - (Число)  выходной параметр: 1 - включена, 0 - выключена.
<бВклПроверкаТипов> - (Число)  выходной параметр: 1 - включена, 0 - выключена.
<бВклРежимОтладки> - (Число)  выходной параметр: 1 - включен, 0 - выключен."
    },
    {"Item","AST","УстановитьТекУстановки","SetCurSettings",
"УстановитьТекУстановки(<?>)",
"SetCurSettings(<?>)",
"@Синтаксис:
УстановитьТекУстановки(<бВклОптимимзация>,<бВклПроверкаТипов>,<бВклРежимОтладки>)
@Назначение:
метод изменяет установки ВК, которые настраиваются в параметрах на закладке Настройки 1С++ почитать о которых можно в разделе 1.7.
@Параметры:
<бВклОптимимзация> - (Число)  входной параметр: 1 - включена, 0 - выключена, любое другое число не изменяет текущее значение.
<бВклПроверкаТипов> - (Число)  входной параметр: 1 - включена, 0 - выключена, любое другое число не изменяет текущее значение.
<бВклРежимОтладки> - (Число)  входной параметр: 1 - включен, 0 - выключен, любое другое число не изменяет текущее значение."
    },
    {"Item","AST","ЭтоSQL_Версия","ThisIsSQL_Ver",
"ЭтоSQL_Версия(<?>)",
"ThisIsSQL_Ver(<?>)",
"@Синтаксис:
ЭтоSQL_Версия()
@Назначение:
Возвращает 1, если текущая версия 1С работает с SQL сервером Майкрософт, 0 - иначе.
@Возвращаемое значение:
(Число)"
    },
    },
 {"Folder","AST","DynaCrypt","DynaCrypt",
    {"Item","AST","Назначение","",
"Назначение",
"",
"@Синтаксис:
Назначение
@Назначение:
Класс предназначен для зашифровки/расшифровки текста с помощью алгоритма RC6"
    },
    {"Item","AST","РашифроватьСтроку","EncryptString",
"РашифроватьСтроку(<?>)",
"EncryptString(<?>)",
"@Синтаксис:
РашифроватьСтроку(<стрИсточник>,<стрКлюч>)
@Назначение:
Метод шифрует строку переданную в параметре и возвращает ее
@Возвращаемое значение:
(Строка)  Зашифрованная строка.
@Параметры:
<стрИсточник> - (Строка)  Строка, которую необходимо зашифровать.
<стрКлюч> - (Строка)  Ключ с помощью, которого будет производиться шифровка."
    },
    {"Item","AST","ДешифроватьСтроку","DecryptString",
"ДешифроватьСтроку(<?>)",
"DecryptString(<?>)",
"@Синтаксис:
ДешифроватьСтроку(<стрИсточник>,<стрКлюч>)
@Назначение:
Метод расшифровывает ранее зашифрованную строку с помощью ключа. При не совпадении ключей шифровки/расшифровки метод не производит сообщений об ошибке.
@Возвращаемое значение:
(Число)  1 - все прошло успешно, -1 - пустая строка, -2 - ошибка в строке, -3 - ошибка в CRC.
@Параметры:
<стрИсточник> - (Строка)  Строка, которую необходимо зашифровать, сюда же возвращается расшифрованная строка.
<стрКлюч> - (Строка)  Ключ с помощью, которого будет производиться расшифровка."
    },
    },
 {"Folder","AST","GUID","GUID",
    {"Item","AST","Назначение","",
"Назначение",
"",
"@Назначение:
Класс предназначен для работы с глобальным уникальным идентификатором (GUID). После создания объект содержит значение пустого идентификатора."
    },
    {"Item","AST","ИзСтроки","FromString",
"ИзСтроки(<?>)",
"FromString(<?>)",
"@Синтаксис:
ИзСтроки(<strGUID>)
@Назначение:
процедура позволяет загрузить объект из строки.
@Параметры:
<strGUID> - (Строка) строка для загрузки, должна быть в каноническом виде для представления идентификатора.
"
    },
    {"Item","AST","ВСтроку","ToString",
"ВСтроку()",
"ToString()",
"@Синтаксис:
ВСтроку()
@Назначение:
конвертирует содержимое объекта в строку.
@Возвращаемое значение:
строка, которая содержит строковое представление идентификатора в каноническом виде.
"
    },
    {"Item","AST","Пустой","IsNil",
"Пустой()",
"IsNil()",
"@Синтаксис:
Пустой()
@Назначение:
позволяет проверить содержимое объекта, пустой или нет.
@Возвращаемое значение:
1 - пустой, 0 - не пустой.
"
    },
    {"Item","AST","УстПустой","SetNil",
"УстПустой()",
"SetNil()",
"@Синтаксис:
УстПустой()
@Назначение:
процедура формирует пустой идентификатор в объекте.
"
    },
    {"Item","AST","Равны","IsEqual",
"Равны()",
"IsEqual()",
"@Синтаксис:
Равны(<obGUID>)
@Назначение:
функция позволяет сравнить два идентификатора.
@Параметры:
obGUID - объект типа GUID или строка с каноническим представлением идентификатора.
@Возвращаемое значение:
1 - равны, 0 - не равны.
"
    },
    {"Item","AST","Новый","New",
"Новый()",
"New()",
"@Синтаксис:
Новый()
@Назначение:
процедура создает новый идентификатор в объекте.
"
    },
    },
 {"Folder","AST","BinaryData","BinaryData",
    {"Item","AST","Назначение","",
"Назначение",
"",
"@Назначение:
Класс предназначен для работы с двоичными данными. Объект может хранить данные в памяти или в файловой системе (в общем случае на диске). После создания объекта он находится в таком состоянии, когда не содержит никаких данных. Все методы работы с объектом, кроме AttachToFile(), неявно переводят объект в состояние работы с памятью (если он находился в состоянии отсутствия данных).
Объект имеет внутренний указатель текущей позиции в данных, чтение и запись идут всегда по текущей позиции. После исполнения методов чтения/записи текущая позиция перемещается на размер прочитанных/записанных байтов. После исполнения остальных методов текущая позиция неопределена, если не оговорено особо.
"
    },
	{"Item","AST","Кодировка","Encoding",
"Кодировка",
"Encoding",
"(чтение/запись) - Число
Содержит текущую кодировку, в которой будет происходить чтение и запись строк.
0 - ANSI (по умолчанию);
1 - OEM;
2 - UTF-16(LE);
3 - UTF-8.
"
    },
    {"Item","AST","ЗагрузитьИзФайла","LoadFromFile",
"ЗагрузитьИзФайла(<?>)",
"LoadFromFile(<?>)",
"@Синтаксис:
ЗагрузитьИзФайла(<strFileName>,<bCompress>)
@Назначение:
функция загружает объект данными из файла.
@Параметры:
<strFileName> имя файла - источника данных.
<bCompress> 0 - загрузка данными как есть, 1 - при загрузке данные будут сжаты внутренним архиватором 1С (zip), после этого объект будет содержать данные файла в сжатом виде. По умолчанию 0.
@Возвращаемое значение:
1 - удачно, 0 - неудачно.
"
    },
    {"Item","AST","СохранитьВФайл","SaveToFile",
"СохранитьВФайл(<?>)",
"SaveToFile(<?>)",
"@Синтаксис:
СохранитьВФайл(<strFileName>,<bCompress>)
@Назначение:
функция выгружает данные объекта в файл.
@Параметры:
<strFileName> имя файла - приемника данных.
<bCompress> выгрузка данных как есть, 1 - при выгрузке данные будут расжаты внутренним архиватором 1С (zip), и файл приемник будет содержать исходные данные. По умолчанию 0.
@Возвращаемое значение:
1 - удачно, 0 - неудачно.
"
    },
    {"Item","AST","ПодключитьсяКФайлу","AttachToFile",
"ПодключитьсяКФайлу(<?>)",
"AttachToFile(<?>)",
"@Синтаксис:
ПодключитьсяКФайлу(<strFileName>,<nShareMode>,<nDesiredAccess>)
@Назначение:
функция подключает объект к файлу. После этого объект хранит свои данные в файле. Файл блокируется эксклюзивно. Если файла не существует, он создается с длиной равной нулю.
@Параметры:
<strFileName> имя файла, к которому необходимо подключиться.
<nMode> режим открытия файла 0 - эксклюзивно, 1 - разделенно, другим процессам разрешены чтение и запись, 2 - разделенно, другим процессам разрешено только чтение, 3 - разделенно, другим процессам разрешена только запись.
<nDesiredAccess> режим открытия файла, желаемый доступ 0 - чтение и запись, 1 -только чтение, 2 - только запись.
@Возвращаемое значение:
1 - удачно, 0 - неудачно.
"
    },
    {"Item","AST","ЗаписатьСтроку","WriteString",
"ЗаписатьСтроку(<?>)",
"WriteString(<?>)",
"@Синтаксис:
ЗаписатьСтроку(<strData>,<bMode>)
@Назначение:
процедура записывает строку в данные объекта.
@Параметры:
<strData> строка, которую необходимо записать.
<bMode> режим записи; 0 - запись строки добавляя символы конца строки CR LF. 1 - запись строки как есть (без терминатора). По умолчанию 0.
"
    },
    {"Item","AST","ЗаписатьДанные","WriteData",
"ЗаписатьДанные(<?>)",
"WriteData(<?>)",
"@Синтаксис:
ЗаписатьДанные(<nData>,<bMode>)
@Назначение:
число, которое необходимо записать.
@Параметры:
<nData> строка, которую необходимо записать.
<bMode> режим записи;
0 - записывать число в 1 байт,
1 - записывать число в 2 байта,
2 - записывать число в 4 байта. По умолчанию 0.
"
    },
    {"Item","AST","ПрочитатьСтроку","ReadString",
"ПрочитатьСтроку(<?>)",
"ReadString(<?>)",
"@Синтаксис:
ПрочитатьСтроку(<strData>,<nLen>)
@Назначение:
функция читает строку из данных объекта.
@Параметры:
<strData> строка, для приема прочитанных данных.
<nLen> режим чтения или длина;
0 - чтение строки, с терминатором CR LF, при этом чтение может завершиться, если встретится байт со значением 0; текущая позиция внутреннего указателя будет всегда за терминатором; также может произойти чтение до конца данных, при этом в strData будет прочитанная строка, и функция вернет 1 (0 функция вернет при следующем вызове).
Иначе - чтение строки указанной длины. Если данных не достаточно или на этой длине встречается байт со значением 0, происходит исключение. По умолчанию 0.
@Возвращаемое значение
1 - строка прочитана, 0 - достигнут конец файла.
"
    },
    {"Item","AST","ПрочитатьДанные","ReadData",
"ПрочитатьДанные(<?>)",
"ReadData(<?>)",
"@Синтаксис:
ПрочитатьДанные(<nData>,<bMode>)
@Назначение:
функция читает число из данных объекта. Если данных недостаточно для чтения числа - происходит исключение.
@Параметры:
<nData> число, для приема прочитанных данных.
<bMode> режим чтения;
0 - прочитать число в 1 байт,
1 - прочитать число в 2 байта,
2 - прочитать число в 4 байта. По умолчанию 0.
@Возвращаемое значение
1 - число прочитано, 0 - достигнут конец файла.
"
    },
    {"Item","AST","Перейти","Seek",
"Перейти(<?>)",
"Seek(<?>)",
"@Синтаксис:
Перейти(<nMove>,<nMode>)
@Назначение:
функция перемещает внутренний указатель текущей позиции.
@Параметры:
<nMove> количество байт на которое нужно переместить указатель.
<bMode> режим перемещения;
0 - относительно начала,
1 - относительно текущей позиции,
2 - относительно конца. По умолчанию 1.
@Возвращаемое значение
число - новая текущая позиция внутреннего указателя.
"
    },
    {"Item","AST","Размер","Size",
"Размер(<?>)",
"Size(<?>)",
"@Синтаксис:
Размер(<nNewSize>)
@Назначение:
функция устанавливает новый размер данных или, если пустое значение - возвращает текущий размер. В случае установки нового размера, длина данных может быть уменьшена или увеличена. При увеличениии, содержимое байтов на которые увеличиваются данные неопределено.
@Параметры:
<nNewSize> новый размер в байтах. По умолчанию пустое значение.
@Возвращаемое значение
число, размер в байтах.
"
    },
    {"Item","AST","УстБлокировку","Lock",
"УстБлокировку(<?>)",
"Lock(<?>)",
"@Синтаксис:
УстБлокировку(<nOffset>,<nLength>,<nTimeout>)
@Назначение:
устанавливает блокировку на указанный диапазон в файле (когда объект работает с памятью - смысла не имеет). Блокируемые участки не должны пересекаться. Блокирование за концом файла не является ошибкой.
@Параметры:
<nOffset> смещение блокируемого диапазона относительно начала файла в байтах;
<nLength> длина блокируемого диапазона в байтах;
<nTimeout> таймаут для установки блокировки в миллисекундах, по умолчанию 0.
@Возвращаемое значение
1 - удачно (блокировка установлена), 0 - неудачно (блокировку установить не удалось).
"
    },
    {"Item","AST","СнятьБлокировку","Unlock",
"СнятьБлокировку(<?>)",
"Unlock(<?>)",
"@Синтаксис:
СнятьБлокировку(<nOffset>,<nLength>)
@Назначение:
снимает блокировку с участка файла. Смежные заблокированные участки не могут рассматриваться как один (снимать блокировку нужно с обоих).
@Параметры:
<nOffset> смещение блокируемого диапазона относительно начала файла в байтах;
<nLength> длина блокируемого диапазона в байтах;
"
    },
    {"Item","AST","ЗаписатьМПБ","WriteBOM",
"ЗаписатьМПБ()",
"WriteBOM()",
"@Синтаксис:
ЗаписатьМПБ()
@Назначение:
записывает в файл метку порядка байтов (byte order mark). В зависимости от текущей кодировки:
- UTF-16 {0xFF, 0xFE};
- UTF-8 {0xEF, 0xBB, 0xBF};
- для остальных ничего не происходит.
"
    },
    {"Item","AST","ПрочитатьМПБ","ReadBOM",
"ReadBOM()",
"ПрочитатьМПБ()",
"@Синтаксис:
ПрочитатьМПБ()
@Назначение:
читает из файла метку порядка байтов, и определяет по ней кодировку, устанавливая свойство Кодировка. Кодировка может быть определена только для UTF-16 и UTF-8, в этом случае внутренний указатель будет установлен сразу за МПБ, если же прочитанные байты не совпадают ни с тем, ни с другим значением МПБ - свойство Кодировка не изменяется и внутренний указатель возвращается в положение до вызова метода.
"
    },
    {"Item","AST","Закрыть","Close",
"Close()",
"Закрыть()",
"@Синтаксис:
Закрыть()
@Назначение:
переводит объект в режим отсутствия данных. Если он работал с памятью - данные теряются, если с файлом - файл освобождается. Действия этого метода неявно выполняются при разрушении объекта.
"
    },
    },
    },
 {"Folder","AST","4. Работа с SQL","",
 {"Folder","AST","MetaDataWork","MetaDataWork",
    {"Item","AST","MetaDataWork","MetaDataWork",
"MetaDataWork",
"MetaDataWork",
"@Синтаксис:
MetaDataWork
@Назначение:
Данный класс предназначен для конвертирования метаданных 1С во внутреннее представление, для возможного использования в SQL - запросах."
    },
    {"Item","AST","ИДКонстанты","GetConstID",
"ИДКонстанты(<?>)",
"GetConstID(<?>)",
"@Синтаксис:
ИДКонстанты(<НомИмяКонстанты>)
@Назначение:
возвращает внутренний номер константы по его идентификатору или порядковому номеру.
@Возвращаемое значение:
(Число)  внутренний ид константы.
@Параметры:
<НомИмяКонстанты> - (строка/число)  идентификатор константы или порядковый номер определяется от 1 до Метаданные.Константа();"
    },
    {"Item","AST","ИДСправочника","GetRefID",
"ИДСправочника(<?>)",
"GetRefID(<?>)",
"@Синтаксис:
ИДСправочника(<НомИмяСпр>)
@Назначение:
возвращает внутренний номер справочника по его идентификатору или порядковому номеру.
@Возвращаемое значение:
(Число)  внутренний ид справочника.
@Параметры:
<НомИмяСпр> - (строка/число)  идентификатор справочника или порядковый номер, определяется от 1 до Метаданные.Справочник();"
    },
    {"Item","AST","ИДРеквизитаСправочника","GetRefFieldID",
"ИДРеквизитаСправочника(<?>)",
"GetRefFieldID(<?>)",
"@Синтаксис:
ИДРеквизитаСправочника(<НомИмяСпр>,<НомИмяРекв>)
@Назначение:
возвращает внутренний номер реквизита справочника по его идентификатору или порядковому номеру.
@Возвращаемое значение:
(Число)  внутренний ид реквизита справочника.
@Параметры:
<НомИмяСпр> - (строка/число)  идентификатор справочника или порядковый номер определяется от 1 до Метаданные.Справочник();
<НомИмяРекв> - (строка/число)  идентификатор реквизита или порядковый номер определяется от 1 до Метаданные.Справочник(х).Реквизит();"
    },
    {"Item","AST","ИмяТаблицыСправочника","GetRefTableName",
"ИмяТаблицыСправочника(<?>)",
"GetRefTableName(<?>)",
"@Синтаксис:
ИмяТаблицыСправочника(<НомИмя>)
@Назначение:
возвращает имя таблицы справочника по его идентификатору или порядковому номеру.
@Возвращаемое значение:
(Строка)  имя таблицы справочника.
@Параметры:
<НомИмя> - (строка/число)  идентификатор справочника или порядковый номер определяется от 1 до Метаданные.Справочник();"
    },
    {"Item","AST","ИДДокумента","GetDocID",
"ИДДокумента(<?>)",
"GetDocID(<?>)",
"@Синтаксис:
ИДДокумента(<НомИмяДок>)
@Назначение:
возвращает внутренний номер документа по его идентификатору или порядковому номеру.
@Возвращаемое значение:
(Число)  внутренний ид документа.
@Параметры:
<НомИмяДок> - (строка/число)  идентификатор документа или порядковый номер, определяется от 1 до Метаданные.Документ();"
    },
    {"Item","AST","ИДРеквизитаШапки","GetDocHeadFieldID",
"ИДРеквизитаШапки(<?>)",
"GetDocHeadFieldID(<?>)",
"@Синтаксис:
ИДРеквизитаШапки(<НомИмяДок>,<НомИмяРекв>)
@Назначение:
возвращает внутренний номер реквизита шапки документа по его идентификатору или порядковому номеру.
@Возвращаемое значение:
(Число)  внутренний ид реквизита шапки документа.
@Параметры:
<НомИмяДок> - (строка/число)  идентификатор документа или порядковый номер определяется от 1 до Метаданные. Документ ();
<НомИмяРекв> - (строка/число)  идентификатор реквизита или порядковый номер определяется от 1 до Метаданные.Документ(х).РеквизитШапки()"
    },
    {"Item","AST","ИмяТаблицыШапки","GetDocHeadTableName",
"ИмяТаблицыШапки(<?>)",
"GetDocHeadTableName(<?>)",
"@Синтаксис:
ИмяТаблицыШапки(<НомИмя>)
@Назначение:
- возвращает имя таблицы шапки документа по его идентификатору или порядковому номеру.
@Возвращаемое значение:
(Строка)  имя таблицы шапки документа.
@Параметры:
<НомИмя> - (строка/число)  идентификатор документа или порядковый номер определяется от 1 до Метаданные.Документ();"
    },
    {"Item","AST","ИДРеквизитаТабличнойЧасти","GetDocTblFieldID",
"ИДРеквизитаТабличнойЧасти(<?>)",
"GetDocTblFieldID(<?>)",
"@Синтаксис:
ИДРеквизитаТабличнойЧасти(<НомИмяДок>,<НомИмяРекв>)
@Назначение:
возвращает внутренний номер реквизита табличной части документа по его идентификатору или порядковому номеру.
@Возвращаемое значение:
(Число)  внутренний ид реквизита табличной части документа
@Параметры:
<НомИмяДок> - (строка/число)  идентификатор документа или порядковый номер определяется от 1 до Метаданные.Документ();
<НомИмяРекв> - (строка/число)  идентификатор реквизита или порядковый номер определяется от 1 до Метаданные.Документ(х).РеквизитТабличнойЧасти()"
    },
    {"Item","AST","ИмяТаблицыТабличнойЧасти","GetDocTblTableName",
"ИмяТаблицыТабличнойЧасти(<?>)",
"GetDocTblTableName(<?>)",
"@Синтаксис:
ИмяТаблицыТабличнойЧасти(<НомИмя>)
@Назначение:
возвращает имя таблицы табличной части документа по его идентификатору или порядковому номеру.
@Возвращаемое значение:
(Строка)  имя таблицы табличной части документа.
@Параметры:
<НомИмя> - (строка/число)  идентификатор документа или порядковый номер определяется от 1 до Метаданные.Документ();"
    },
    {"Item","AST","ИДЖурналаРасчетов","GetCJID",
"ИДЖурналаРасчетов(<?>)",
"GetCJID(<?>)",
"@Синтаксис:
ИДЖурналаРасчетов(<НомИмяДок>)
@Назначение:
возвращает внутренний номер журнала расчетов по его идентификатору или порядковому номеру.
@Возвращаемое значение:
(Число)  внутренний ид документа.
@Параметры:
<НомИмяДок> - (строка/число)  идентификатор журнала или порядковый номер, определяется от 1 до Метаданные.ЖурналРасчетов();"
    },
    {"Item","AST","ИДРеквизитаЖР","GetCJFieldID",
"ИДРеквизитаЖР(<?>)",
"GetCJFieldID(<?>)",
"@Синтаксис:
ИДРеквизитаЖР(<НомИмяДок>,<НомИмяРекв>)
@Назначение:
возвращает внутренний номер реквизита журнала расчетов по его идентификатору или порядковому номеру.
@Возвращаемое значение:
(Число)  внутренний ид реквизита журнала документа
@Параметры:
<НомИмяДок> - (строка/число)  идентификатор журнала или порядковый номер определяется от 1 до Метаданные. ЖурналРасчетов ();
<НомИмяРекв> - (строка/число)  идентификатор реквизита или порядковый номер определяется от 1 до Метаданные. ЖурналРасчетов(х).Реквизит()"
    },
    {"Item","AST","ИмяТаблицыЖР","GetCJTableName",
"ИмяТаблицыЖР(<?>)",
"GetCJTableName(<?>)",
"@Синтаксис:
ИмяТаблицыЖР(<НомИмя>)
@Назначение:
возвращает имя таблицы журнала расчетов по его идентификатору или порядковому номеру.
@Возвращаемое значение:
(Строка)  имя таблицы журнала документа.
@Параметры:
<НомИмя> - (строка/число)  идентификатор журнала или порядковый номер определяется от 1 до Метаданные. ЖурналРасчетов();"
    },
    {"Item","AST","ИДРегистра","GetRegID",
"ИДРегистра(<?>)",
"GetRegID(<?>)",
"@Синтаксис:
ИДРегистра(<НомИмяДок>)
@Назначение:
возвращает внутренний номер регистра по его идентификатору или порядковому номеру.
@Параметры:
<НомИмяДок> - (строка/число)  идентификатор регистра или порядковый номер, определяется от 1 до Метаданные.Регистр();"
    },
    {"Item","AST","ИДИзмеренияРегистра","GetRegDimensionID",
"ИДИзмеренияРегистра(<?>)",
"GetRegDimensionID(<?>)",
"@Синтаксис:
ИДИзмеренияРегистра(<НомИмяДок>,<НомИмя>)
@Назначение:
возвращает внутренний номер измерения регистра по его идентификатору или порядковому номеру.
@Возвращаемое значение:
(Число)  внутренний ид измерения регистра.
@Параметры:
<НомИмяДок> - (строка/число)  идентификатор регистра или порядковый номер, определяется от 1 до Метаданные.Регистр();
<НомИмя> - (строка/число)  идентификатор измерения или порядковый номер определяется от 1 до Метаданные. Регистр (х).Измерение()"
    },
    {"Item","AST","ИДРесурсаРегистра","GetRegResourceID",
"ИДРесурсаРегистра(<?>)",
"GetRegResourceID(<?>)",
"@Синтаксис:
ИДРесурсаРегистра(<НомИмяДок>,<НомИмя>)
@Назначение:
возвращает внутренний номер ресурса регистра по его идентификатору или порядковому номеру.
@Возвращаемое значение:
(Число)  внутренний ид ресурса регистра.
@Параметры:
<НомИмяДок> - (строка/число)  идентификатор регистра или порядковый номер, определяется от 1 до Метаданные.Регистр();
<НомИмя> - (строка/число)  идентификатор ресурса или порядковый номер определяется от 1 до Метаданные. Регистр (х). Ресурс()"
    },
    {"Item","AST","ИДРеквизитаРегистра","GetRegAttributeID",
"ИДРеквизитаРегистра(<?>)",
"GetRegAttributeID(<?>)",
"@Синтаксис:
ИДРеквизитаРегистра(<НомИмяДок>,<НомИмя>)
@Назначение:
возвращает внутренний номер реквизита регистра по его идентификатору или порядковому номеру.
@Возвращаемое значение:
(Число)  внутренний ид реквизита регистра.
@Параметры:
<НомИмяДок> - (строка/число)  идентификатор регистра или порядковый номер, определяется от 1 до Метаданные.Регистр();
<НомИмя> - (строка/число)  идентификатор реквизита или порядковый номер определяется от 1 до Метаданные. Регистр (х).Реквизит ()"
    },
    {"Item","AST","ИмяТаблицыДвижений","GetRegActsTableName",
"ИмяТаблицыДвижений(<?>)",
"GetRegActsTableName(<?>)",
"@Синтаксис:
ИмяТаблицыДвижений(<НомИмя>)
@Назначение:
возвращает имя таблицы движений регистра по его порядковому номеру  или идентификатору.
@Возвращаемое значение:
(Строка)  имя таблицы движений регистра.
@Параметры:
<НомИмя> - (строка/число)  идентификатор регистра или порядковый номер определяется от 1 до Метаданные. Регистр();"
    },
    {"Item","AST","ИмяТаблицыИтогов","GetRegTotalsTableName",
"ИмяТаблицыИтогов(<?>)",
"GetRegTotalsTableName(<?>)",
"@Синтаксис:
ИмяТаблицыИтогов(<НомИмя>)
@Назначение:
возвращает имя таблицы итогов регистра по его порядковому номеру  или идентификатору.
@Возвращаемое значение:
(Строка)  имя таблицы итогов регистра.
@Параметры:
<НомИмя> - (строка/число)  идентификатор регистра или порядковый номер определяется от 1 до Метаданные. Регистр();"
    },
    {"Item","AST","ИДОбъекта","GetMetadataID",
"ИДОбъекта(<?>)",
"GetMetadataID(<?>)",
"@Синтаксис:
ИДОбъекта(<ОбъектМетаДанных>)
@Назначение:
Возвращает внутренний идентификатор переданного объекта метаданных.
@Возвращаемое значение:
(Число)  внутренний идентификатор объекта метаданных.
@Параметры:
<ОбъектМетаДанных> - (Метаданные)  ссылка на объект метаданных"
    },
    {"Item","AST","ЧислоВСтроку","IntToBase",
"ЧислоВСтроку(<?>)",
"IntToBase(<?>)",
"@Синтаксис:
ЧислоВСтроку(<Число>,<Основание>)
@Назначение:
Преобразует целое число в строку с заданным основанием.
@Возвращаемое значение:
(Число)  результат
@Параметры:
<Число> - (Число)  Преобразуемое число по десятичному основанию.
<Основание> - (Число)  Основание результата"
    },
    {"Item","AST","СтрокаВЧисло","BaseToInt",
"СтрокаВЧисло(<?>)",
"BaseToInt(<?>)",
"@Синтаксис:
СтрокаВЧисло(<Строка>,<Основание>)
@Назначение:
Преобразует строку с заданным основанием в целое число.
@Возвращаемое значение:
(Число)  результат по десятичному основанию
@Параметры:
<Строка> - (Строка)  Строка с заданным основание
<Основание> - (Число)  Основание значения в строке"
    },
    {"Item","AST","ЗначениеВСтрокуБД","ValueToDBString",
"ЗначениеВСтрокуБД(<?>)",
"ValueToDBString(<?>)",
"@Синтаксис:
ЗначениеВСтрокуБД(<Object>)
@Назначение:
преобразует ссылочный тип данных 1С (Справочник, документ, перечисление) во внутренние представление системы, только внутренний ИД объекта. Возвращает строку - внутреннего представления в виде: [ID(6)][Sign(3)] = 9 символов.
@Возвращаемое значение:
(Строка)
@Параметры:
<Object> - объект неопределенного вида"
    },
    {"Item","AST","ЗначениеВДлиннуюСтрокуБД","ValueToLongDBString",
"ЗначениеВДлиннуюСтрокуБД(<?>)",
"ValueToLongDBString(<?>)",
"@Синтаксис:
ЗначениеВДлиннуюСтрокуБД(<Object>)
@Назначение:
преобразует ссылочный тип данных 1С (Справочник, документ, перечисление) во внутренние представление системы, строковое представление вида и внутренний ИД объекта. Возвращает строку - внутреннего представления в виде: [Kind(4)][ID(6)][Sign(3)] = 13 символов.
@Возвращаемое значение:
Строка 13 символов.
@Параметры:
<Object> - значение любого хранимого типа."
    },
    {"Item","AST","ЗначениеВСамуюДлиннуюСтрокуБД","ValueToSuperLongDBString",
"ЗначениеВСамуюДлиннуюСтрокуБД(<?>)",
"ValueToSuperLongDBString(<?>)",
"@Синтаксис:
ЗначениеВСамуюДлиннуюСтрокуБД(<Object>)
@Назначение:
преобразует ссылочный тип данных 1С (Справочник, документ, перечисление), а также простые типы (Число, Строка, Дата) во внутренние представление системы, строку для хранения в реквизите типа Неопределенный.
@Возвращаемое значение:
Строка 23 символа.
@Параметры:
<Object> - любой хранимый тип."
    },
    {"Item","AST","ЗначениеИзСтрокиБД","ValueFromDBString",
"ЗначениеИзСтрокиБД(<?>)",
"ValueFromDBString(<?>)",
"@Синтаксис:
ЗначениеИзСтрокиБД(<TypeKind>,<KindVal>,<strVal>)
@Назначение:
метод преобразует из строки внутреннего представления объекта в сам объект, конкретного типа и вида. Количество и типы параметров зависит от режимов работы метода. Формат внутреннего представления: [ID(6)][Sign(3)] = 9 символов.
@Возвращаемое значение:
(Неопределенный)
@Параметры:
<TypeKind> - (число/строка)  Если в данный параметр метода передать строковое представление типа преобразуемой строки в формате: Тип.Вид, то тогда во втором параметре данного метода необходимо передавать саму строку внутреннего представления. Если же в данный параметр передано число с номером типа (допустимые номера 10, 11, 12, 13), то тогда во второй параметр необходимо передать число, обозначающее внутренний вид типа, который можно получить с помощью методов данного класса описанных выше, и, наконец, в третьем параметре должно содержаться внутренне строковое представление объекта
<KindVal> - (число/строка)  Если в первом параметре тип и вид объекта представлен строкой, то в этот параметр передаем внутренне строковое представление получаемого объекта. Если же в первом параметре был передан числовое значение типа, то тогда данный параметр должен получить числовое представление вида объекта.
<strVal> - (строка)  внутреннее строковое представление объекта, данный параметр необходимо передавать в метод, только, если в первых двух параметрах были получены числовые представления типа и вида объекта.
@Замечание:
Внимание! Следите за длиной передаваемой строки, т.к. метод в целях оптимизации не проверяет строку внутреннего представления на допустимую длину равную 9 символам!"
    },
    {"Item","AST","ЗначениеИзДлиннойСтрокиБД","ValueFromLongDBString",
"ЗначениеИзДлиннойСтрокиБД(<?>)",
"ValueFromLongDBString(<?>)",
"@Синтаксис:
ЗначениеИзДлиннойСтрокиБД(<Type>,<strVal>)
@Назначение:
метод преобразует из строки внутреннего представления объекта в сам объект, конкретного типа и вида. В отличие от метода ValueFromDBString в данный метод нет необходимости передавать вид объекта, т.к. вид должен содержаться в самой строке внутреннего представления. Формат внутреннего представления: [Kind(4)][ID(6)][Sign(3)] = 13 символов.
@Возвращаемое значение:
(Неопределенный)
@Параметры:
<Type> - (число/строка)  в данный параметр можно передавать тип объекта как в строковом виде, так и в числовом.
<strVal> - (строка)  внутреннее строковое представление объекта.
@Замечание:
Внимание! Следите за длиной передаваемой строки, т.к. метод в целях оптимизации не проверяет строку внутреннего представления на допустимую длину равную 13 символам!"
    },
    {"Item","AST","ПолучитьКонПериода","GetEndOfPeriod",
"ПолучитьКонПериода(<?>)",
"GetEndOfPeriod(<?>)",
"@Синтаксис:
ПолучитьКонПериода(<Date>)
@Назначение:
Возвращает дату конца периода расчета остатков от указанной в параметре даты.
@Параметры:
<Date> - (Дата)  Необязательный параметр.   Необязательный параметр, дата от которой рассчитывается период, по умолчанию дата точки актуальности."
    },
    {"Item","AST","ПолучитьКонПериодаДляРег","GetEndOfPeriodForReg",
"ПолучитьКонПериодаДляРег(<?>)",
"GetEndOfPeriodForReg(<?>)",
"@Синтаксис:
ПолучитьКонПериодаДляРег(<ИмяОборотногоРег>,<Дата>)
@Назначение:
Возвращает дату конца периода расчета остатков для оборотного регистра от указанной в параметре даты.
@Параметры:
<ИмяОборотногоРег> - (число|строка)  идентификатор оборотного регистра или его порядковый номер
<Дата> - (Дата)  Необязательный параметр.   необязательный параметр, дата от которой рассчитывается период регистра, по умолчанию дата точки актуальности."
    },
    {"Item","AST","ПолучитьНачПериода","GetBegOfPeriod",
"ПолучитьНачПериода(<?>)",
"GetBegOfPeriod(<?>)",
"@Синтаксис:
ПолучитьНачПериода(<Дата>)
@Назначение:
Возвращает дату начала периода расчета остатков от указанной в параметре даты.
@Параметры:
<Дата> - (Дата)  Необязательный параметр.   необязательный параметр, дата от которой рассчитывается период, по умолчанию дата точки актуальности."
    },
    {"Item","AST","ПолучитьНачПериодаДляРег","GetBegOfPeriodForReg",
"ПолучитьНачПериодаДляРег(<?>)",
"GetBegOfPeriodForReg(<?>)",
"@Синтаксис:
ПолучитьНачПериодаДляРег(<ИмяОборотногоРег>,<Дата>)
@Назначение:
Возвращает дату начала периода расчета остатков для оборотного регистра от указанной в параметре даты.
@Параметры:
<ИмяОборотногоРег> - (число|строка)  идентификатор оборотного регистра или его порядковый номер
<Дата> - (Дата)  Необязательный параметр.   необязательный параметр, дата от которой рассчитывается период регистра, по умолчанию дата точки актуальности."
    },
    {"Item","AST","ПолучитьСтрокуИзСЗ","GetStringInVL",
"ПолучитьСтрокуИзСЗ(<?>)",
"GetStringInVL(<?>)",
"@Синтаксис:
ПолучитьСтрокуИзСЗ(<сз>,<режим>)
@Назначение:
Возвращает строку состоящую из строковых представлений значений 1С преобразованных во внутренне представление и разделенные запятыми. В основном используется в SQL выражениях типа: [ NOT ] IN ( subquery | expression [ ,...n ] ). Значения, содержащиеся в списке, обязаны быть одного типа, тип проверяется по первому значению в списке.
@Параметры:
<сз> - (СписокЗначений)  список с элементами
<режим> - (число)  Необязательный параметр.   необязательный параметр, по умолчанию равен 1. Параметр имеет смысл, только для значений элементов документов, справочников и перечислений, содержащихся в списке. 1 - преобразовывать элементы списка в короткое представление (9 символов), 2 - преобразовывать в длинное представление (13 символов)."
    },
    {"Item","AST","ПолучитьСтрИзДаты","GetStrFromDate",
"ПолучитьСтрИзДаты(<?>)",
"GetStrFromDate(<?>)",
"@Синтаксис:
ПолучитьСтрИзДаты(<Дата>)
@Назначение:
Возвращает строковое представление даты в виде Год/Месяц/День (20030101).
@Параметры:
<Дата> - (Дата)  Дата
"
    },
    {"Item","AST","ПолучитьДобПериод","GetAddPeriod",
"ПолучитьДобПериод(<?>)",
"GetAddPeriod(<?>)",
"@Синтаксис:
ПолучитьДобПериод(<Дата>,<чНом>,<ИмяОборотногоРег>)
@Назначение:
Добавляет/вычитает период из указанной даты. Значение периода может быть получено как для остаточных 
регистров в целом, так и для указанного оборотного регистра в отдельности.
@Параметры:
<Дата> - (Дата)  дата начала отчета периода.
<чНом> - (число)  количество периодов. Положительное значение - прибавляем период, отрицательное значение - 
отнимаем период.
<ИмяОборотногоРег> - (число|строка)  Необязательный параметр.   идентификатор оборотного регистра или его 
порядковый номер. Необязательный параметр, указывается только в случае расчета периода для конкретного 
оборотного регистра.
"
    },
    {"Item","AST","ПолучитьДатуВремяИдДок","GetDateTimeIDDOC",
"ПолучитьДатуВремяИдДок(<?>)",
"GetDateTimeIDDOC(<?>)",
"@Синтаксис:
ПолучитьДатуВремяИдДок(<стрПозДок>)
@Назначение:
формирует из позиции документа переданной в качестве параметра, представление даты, времени и 
идентификатора документа для временной оси.
@Параметры:
<стрПозДок> - (строка)  позиция документа полученная с помощью метода GetPosition()/ПолучитьПозицию 
класса Document/Документ.
"
    },
    {"Item","AST","ОбрМетаСКЛ","ProcessMetaSQL",
"ОбрМетаСКЛ(<?>)",
"ProcessMetaSQL(<?>)",
"@Синтаксис:
ОбрМетаСКЛ(<МетаТекст>)
@Назначение:
метод осуществляет преобразование мета язык SQL (описание см. Приложение А) в 
чистый SQL.
@Параметры:
<МетаТекст> - (строка)  текст мета языка SQL.
@Возвращаемое значение:
Возвращает текст чистого SQL.

"
    },
    {"Item","AST","УстановитьТекстовыйПараметр","SetTextParam",
"УстановитьТекстовыйПараметр(<?>,<?>)",
"SetTextParam(<?>,<?>)",
"@Синтаксис:

SetTextParam(<strName>, <unVal>) 

@Назначение:

устанавливает текстовый параметр. Необходимо вызывать до передачи текста

@Параметры:
<strName> (строка): имя текстового параметра;
<unVal> (Неопределенный): значение текстового параметра.
"
    },
    },
 {"Folder","AST","ODBCRecordSet","ODBCRecordSet",
    {"Item","AST","ODBCRecordSet","Назначение",
"ODBCRecordSet",
"Назначение",
"@Синтаксис:
ODBCRecordSet
@Назначение:
Данный класс предназначен для получения данных из внешних источников, 
таких как различные БД имеющие в своем распоряжение драйвера ODBC, файлы 
данных (*.txt, *.csv и т.д.). По умолчанию, в SQL - версии 1С созданный объект 
подключен к текущему соединению программы 1С:Предприятие и пригоден к работе 
без установки соединения (ODBCDatabase).
В тексте запросов, допускается  использование метаимен, которые 
транслируются (заменяются прямо в тексте запроса) в следующие виды имен:
+ реальные имена таблиц 1С:Предприятия для SQL;
+ реальные имена полей таблиц 1С:Предприятия для SQL;
+ параметры запроса;
+ виртуальные таблицы (подзапросы, имена предварительно подготовленных 
временных таблиц);
+ виртуальные значения (корреляционные подзапросы, выражения MS T-SQL).
Спецификация метаимен приводится в Приложении А.
Существует возможность явно типизировать типами 1С колонки набора 
данных. Эта задача решается применением специальных, типизирующих 
псевдонимов полей результирующего набора данных.
        Формат типизирующего псевдонима
[<ИмяПоля> $<Тип1С>]
ИмяПоля - имя, которое будет доступно для обращения к полю методами этого 
класса.
Тип1С - строка, представляющая тип 1С, который будет назначен полю, в формате 
применяющемся в методе SetTypeColumn1C.
Пример запроса:
select
Номенклатура.descr as Наименование,
$Номенклатура.ВидНоменклатуры as [ВидНоменклатуры $Перечисление.ВидыНоменклатуры],
$Номенклатура.ОсновнойПоставщик as [Поставщик $Справочник.Контрагенты],
$Номенклатура.Цена as Цена
from $Справочник. Номенклатура as Номенклатура
where Номенклатура.isfolder = 2
"
    },
    {"Item","AST","Отладка","Debug",
"Отладка(<?>)",
"Debug(<?>)",
"@Синтаксис:
Отладка(<bOnOff>)
@Назначение:
включает/отключает отладочный режим, в котором проверяются на допустимость параметры методов. По умолчанию класс находится в рабочем - не отладочном режиме, включить отладку можно просто, вызвав данный метод, без передачи в него аргумента.
@Параметры:
<bOnOff> - (Число)  Необязательный параметр.   1 вкл. Отладку; 0 - откл. отладку."
    },
    {"Item","AST","УстБД","SetDatabase",
"УстБД(<?>)",
"SetDatabase(<?>)",
"@Синтаксис:
УстБД(<db>)
@Назначение:
устанавливает соединение.
@Параметры:
<db> - (ODBCDatabase)  соединение, объект класса ODBCDatabase"
    },
    {"Item","AST","УстБД1С","SetDatabase1C",
"УстБД1С(<?>)",
"SetDatabase1C(<?>)",
"@Синтаксис:
УстБД1С()
@Назначение:
для SQL версии устанавливает родное соединение 1С:Предприятия."
    },
    {"Item","AST","Закрыть","Close",
"Закрыть(<?>)",
"Close(<?>)",
"@Синтаксис:
Закрыть()
@Назначение:
закрывает текущую открытую выборку."
    },
    {"Item","AST","Выполнить","Execute",
"Выполнить(<?>)",
"Execute(<?>)",
"@Синтаксис:
Выполнить(<TextSQL>)
@Назначение:
выполнить SQL запрос, без возврата результата выборки. Метод в основном предназначен для выполнения запросов вставки, обновления, вызова процедур. Описания для установки параметров запроса см. ниже.
@Возвращаемое значение:
(Число)  1 - запрос выполнился успешно, 0 - не успешно, описание ошибки можно получить вызвав метод GetLastError.
@Параметры:
<TextSQL> - (Строка)  текст запроса"
    },
    {"Item","AST","ПолучитьОписаниеОшибки","GetLastError",
"ПолучитьОписаниеОшибки(<?>)",
"GetLastError(<?>)",
"@Синтаксис:
ПолучитьОписаниеОшибки()
@Назначение:
возвращает описание в виде строки последней ошибки."
    },
    {"Item","AST","УстСвойстваКурсора","SetPropertyCursor",
"УстСвойстваКурсора(<?>)",
"SetPropertyCursor(<?>)",
"@Синтаксис:
УстСвойстваКурсора(<CURSOR_TYPE>,<CURSOR_SCROLLABLE>,<CURSOR_SENSITIVITY>,
<SQL_ATTR_CONCURRENCY>)
@Назначение:
установить/изменить свойства курсора. Вызывать данный метод имеет смысл только до вызова методов 
Prepare и/или Open текущего класса.
@Параметры:
<CURSOR_TYPE> - (Число)  * 0 - не изменять
* 1 - SQL_CURSOR_FORWARD_ONLY = Последовательный тип курсора. Приложение может перебирать набор 
записей только в одном направлении. Изменения, производимые другими курсорами в данной транзакции или 
другими транзакциями, будут видимы только в том случае, если они затрагивают строки, находящиеся перед 
курсором.
* 2 - SQL_CURSOR_STATIC = Статический тип курсора. Приложение видит данные в том состоянии, в каком они 
были на момент открытия курсора. Изменения, производимые данным курсором, являются видимыми. 
Изменения, инициированные другими источниками, не видны. Перемещение курсора возможно в обоих 
направлениях.
* 3 - SQL_CURSOR_KEYSET_DRIVEN = Ключевой тип курсора. При открытии курсора для каждой строки набора 
записей сохраняется значение первичного ключа. Обращаясь к строке, приложение использует этот ключ для 
получения текущего значения строки. Обновления, вызванные любым источником, являются видимыми. Вставки 
из других источников не видны (в наборе записей для них не имеется ключей). Строки, вставляемые данным 
курсором, добавляются в конец набора записей. Изменения в порядке строк не видны.
* 4 - SQL_CURSOR_DYNAMIC = Динамический тип курсора. Приложение видит любые изменения, вызванные 
любым источником. Все вставки, обновления, удаления и изменения в порядке записей являются видимыми.
<CURSOR_SCROLLABLE> - (Число)  * 0 - не изменять
* 1 - SQL_NONSCROLLABLE = Открыть курсор, для которого возможно передвижение только в одном 
направлении - от первой строки к последней.
 * 2 - SQL_SCROLLABLE = Открыть курсор, для которого возможные любые продвижения по набору записей.
<CURSOR_SENSITIVITY> - (Число)  * 0 - не изменять
* 1 - SQL_UNSPECIFIED = Это не специфицированный тип курсора и данный тип курсора может сделать 
видимыми те изменения, которые были сделаны другими курсорами. Курсоры данного типа, могут  отражать 
все, некоторые и не одного изменения сделанные другими курсорами. Данный тип курсора устанавливается по 
умолчанию. 
* 2 - SQL_INSENSITIVE = Данный тип курсора не отражает изменения внесенные другими курсорами. Тип 
соответствует статическому виду курсора и предназначен только для чтения. Результирующий набор курсора 
размещается в базе данных Tempdb (MS SQL).
* 3 - SQL_SENSITIVE = Курсор, открытый с данным параметром может отражать все изменения внесенные 
другими курсорами.
<SQL_ATTR_CONCURRENCY> - (Число)  * 0 - не изменять
* 1 - SQL_CONCUR_READ_ONLY = Cursor is read-only. No updates are allowed.
* 2 - SQL_CONCUR_LOCK = Cursor uses the lowest level of locking sufficient to ensure that the row can be updated.
* 3 - SQL_CONCUR_ROWVER = Cursor uses optimistic concurrency control, comparing row versions such as SQLBase 
ROWID or Sybase TIMESTAMP.
* 4 - SQL_CONCUR_VALUES = Cursor uses optimistic concurrency control, comparing values.
"
    },
    {"Item","AST","УстРазмерМножестваСтрок","SetRowsetSize",
"УстРазмерМножестваСтрок(<?>)",
"SetRowsetSize(<?>)",
"@Синтаксис:
УстРазмерМножестваСтрок(<nSize>)
@Назначение:
устанавливает размер блока выборки (в виде количества строк), который будет получать за одно обращение в к источнику данных. Уменьшает количество обращений к источнику, за счет получение больших порций данных. Использовать данный метод имеет смысл только до вызова метода Open.
@Параметры:
<nSize> - (Число)  размер множества строк"
    },
    {"Item","AST","Подготовить","Prepare",
"Подготовить(<?>)",
"Prepare(<?>)",
"@Синтаксис:
Подготовить(<TextSQL>)
@Назначение:
подготовит SQL запрос. Метод в основном предназначен для выполнения запросов, в которых часто меняются только некоторые его части, а изменяемые части запроса устанавливаются с помощью методов для работы с параметрами.
@Возвращаемое значение:
(Число)  1 - подготовка запрос проведена успешно; 0 - не успешно, текст ошибки можно получить вызвав метод GetLastError.
@Параметры:
<TextSQL> - (Строка)  текст запроса"
    },
    {"Item","AST","ПостроитьПараметры","BuildParams",
"ПостроитьПараметры(<?>)",
"BuildParams(<?>)",
"@Синтаксис:
ПостроитьПараметры()
@Назначение:
данный формирует параметры на основе подготовленного методом Prepare параметризированного запроса, где места вставки параметров указываются знаком ?.
@Возвращаемое значение:
(Число)  1 - операция прошла успешно, 0 - нет.
@Пример:
rc.Prepare(INSERT INTO MyTable (NAME, AGE, SALARY, DATEOFBIRTH) VALUES(?, ?, ?, ?));
if rc.BuildParams() = 1 then
  rc.SetParam(1, Авраам Козлевич);
  rc.SetParam(2, 28);
  rc.SetParam(3, 1250.25);
  rc.SetParam(4, '17.11.1974');
  rc.Execute();                 
endif;"
    },
    {"Item","AST","ДобПараметр","AddParam",
"ДобПараметр(<?>)",
"AddParam(<?>)",
"@Синтаксис:
ДобПараметр(<IOType>,<nSQLType>,<nLen>,<nDec>,<pname>)
@Назначение:
добавляет описание параметра для параметризированного запроса.
@Параметры:
<IOType> - (Число)  * 1 - SQL_PARAM_INPUT
* 2 - SQL_PARAM_OUTPUT
* 3 - SQL_PARAM_INPUT_OUTPUT
<nSQLType> - (Число)  * 1  - SQL_BIT
* 2  - SQL_TINYINT
* 3  - SQL_SMALLINT
* 4  - SQL_INTEGER
* 5  - SQL_REAL
* 6  - SQL_FLOAT
* 7  - SQL_DOUBLE
* 8  - SQL_TYPE_DATE
* 9  - SQL_TYPE_TIME
* 10 - SQL_TYPE_TIMESTAMP
* 11 - SQL_NUMERIC
* 12 - SQL_DECIMAL
* 13 - SQL_BIGINT
* 14 - SQL_CHAR
* 15 - SQL_VARCHAR
* 16 - SQL_LONGVARCHAR
* 17 - SQL_BINARY
* 18 - SQL_VARBINARY
* 19 - SQL_LONGVARBINARY
<nLen> - (Число)  длина
<nDec> - (Число)  точность
<pname> - (Строка)  Необязательный параметр.   именованный параметр вида @Par1, необязательный параметр."
    },
    {"Item","AST","КолвоПараметров","ParamCount",
"КолвоПараметров(<?>)",
"ParamCount(<?>)",
"@Синтаксис:
КолвоПараметров()
@Назначение:
возвращает количество построенных и/или добавленных параметров.
@Возвращаемое значение:
(Число)"
    },
    {"Item","AST","УстПараметр","SetParam",
"УстПараметр(<?>)",
"SetParam(<?>)",
"@Синтаксис:
УстПараметр(<nPos>,<unVal>,<bType>)
@Назначение:
установить значение параметра, добавленного с помощью метода AddParam/ДобПараметр или автоматически 
созданного на основе подготовленного SQL запроса (с знаками подстановки ?) методом Prepare/Подготовить и 
созданного методом BuildParams/ПостроитьПараметры.
@Параметры:
<nPos> - (Число)  позиция параметра. Допустимый диапазон [1 - ParamCount()]
<unVal> - (Неопределенный)  значение параметра
<bType> - (Число)  0 - использовать короткое представление значений 1С объектов, т.к. элементы справочников, 
документов. Для колонок, в которых хранятся только ID объектов. 1 - использовать длинное представление 
значений 1С. Для колонок, в которых помимо ID объектов хранятся также и виды объекта. Необязательный 
параметр. По умолчанию 0.
"
    },
    {"Item","AST","ПолучПараметр","GetParam",
"ПолучПараметр(<?>)",
"GetParam(<?>)",
"@Синтаксис:
ПолучПараметр(<nPos>,<strType>)
@Назначение:
получить значение параметра по его позиции.
@Параметры:
<nPos> - (Число)  позиция параметра. Допустимый диапозон [1 - ParamCount()]
<strType> - (строка)  тип получаемого параметра. Допустимые значения:
  Справочник/Reference - полученное значение параметра преобразуется из длинного формата представления элементов справочников: [Kind(4)][ID(6)][Sign(3)] = 13 символов, в конкретный элемент справочника.
  Справочник/Reference.* - где * любой вид справочника как он определен в конфигураторе (Идентификатор) существующий в ИБ 1С. Преобразует короткую строку полученную из параметра в конкретный элемент: [ID(6)][Sign(3)] = 9 символов.
  Документ/Document - преобразование длинной (13) строки в конкретный элемент документа.
  Документ/Document.* - где * любой вид документа как он определен в конфигураторе (Идентификатор). Строка, полученная из параметра преобразуется в конкретный элемент документа.
  Перечисление/Enum - преобразование длинной строки (13) в конкретный элемент перечисления.
  Перечисление/Enum.* - преобразование короткой строки (9) в конкретный элемент перечисления.
  Неопределенный/Undefine - преобразование строки [Type(2)][Kind(4)][ID(6)][Sign(3)] = 15 символов в конкретный тип и конкретный элемент представленный в ней для реквизитов, тип у которых не определен."
    },
    {"Item","AST","УдалитьПараметры","ClearParams",
"УдалитьПараметры(<?>)",
"ClearParams(<?>)",
"@Синтаксис:
УдалитьПараметры()
@Назначение:
удаляет ранее установленные параметры"
    },
    {"Item","AST","УдалитьПараметр","DeleteParam",
"УдалитьПараметр(<?>)",
"DeleteParam(<?>)",
"@Синтаксис:
УдалитьПараметр(<nPos>)
@Назначение:
удаляет ранее установленные параметры по индексу.
@Параметры:
<nPos> - (Число)  позиция параметра. Допустимый диапозон [1 - ParamCount()]"
    },
    {"Item","AST","Открыть","Open",
"Открыть(<?>)",
"Open(<?>)",
"@Синтаксис:
Открыть(<TextSQL>,<bUseCursors>,<bIsPrepare>)
@Назначение:
открывает выборку, для полученного выражения SQL или ранее подготовленную выборку методом Prepare/Подготовить.
@Параметры:
<TextSQL> - (Строка)  Необязательный параметр.   текст запроса, если строка пустая, то выборка открывается для подготовленного ранее запроса методом Prepare/Подготовить. Необязателен, по умолчанию - пустая строка.
<bUseCursors> - (Число)  Необязательный параметр.   1 - открыть курсор, только для запроса указанного в первом параметре метода (если запрос подготавливался ранее командой Prepare, тогда разрешить использовать курсор уже нельзя, для установки курсора и его типа воспользуйтесь методом SetPropertyCursor), 
                                         0 - не открывать курсор.
Если ранее был использован метод SetPropertyCursor, то значение данного параметра игнорируется. Необязателен, по умолчанию равен 0.
<bIsPrepare> - (Число)  Необязательный параметр.   1 - открыть ранее подготовленный методом Prepare запрос.
0 - использовать первый параметр как запрос на выполнение.
Необязателен, по умолчанию равен 0, если в первом параметре есть текст запроса и равен 1, если передан пустой текст запроса."
    },
    {"Item","AST","УстТипыКолонок1С","SetTypeColumn1C",
"УстТипыКолонок1С(<?>)",
"SetTypeColumn1C(<?>)",
"@Синтаксис:
УстТипыКолонок1С(<strTypes>)
@Назначение:
метод используется только после открытия выборки, методом Open. Устанавливает эквивалентные типы для значений колонок полученной выборки, для успешного преобразования в типы 1С языка при получении результатов.
@Параметры:
<strTypes> - (Строка)  Строка с типами разделенными запятыми. Каждый тип соотвествует номеру колонки начиная с первой и заканчивая GetFieldCount() включительно. Все типы которые превышают номер последнего столбца - игнорируются. Синтаксис строки типов: 
type_string ::= empty-string[,] | type[,] | type, type_string
empty-string ::=
type ::=
 | Строка
 | Дата
 | Число
 | Справочник/Reference - полученное значение параметра преобразуется из длинного формата представления элементов справочников: [Kind(4)][ID(6)][Sign(3)] = 13 символов, в конкретный элемент справочника.
 | Справочник/Reference.* - где * любой вид справочника как он определен в конфигураторе (Идентификатор) существующий в ИБ 1С. Преобразует короткую строку полученную из параметра в конкретный элемент: [ID(6)][Sign(3)] = 9 символов.
 | Документ/Document - преобразование длинной (13) строки в конкретный элемент документа.
 | Документ/Document.* - где * любой вид документа как он определен в конфигураторе (Идентификатор). Строка, полученная из параметра преобразуется в конкретный элемент документа.
 | Перечисление/Enum - преобразование длинной строки (13) в конкретный элемент перечисления.
 | Перечисление/Enum.* - преобразование короткой строки (9) в конкретный элемент перечисления.
 | Неопределенный/Undefine - преобразование строки [Type(2)][Kind(4)][ID(6)][Sign(3)] = 15 символов в конкретный тип и конкретный элемент представленный в ней для реквизитов, тип у которых не определен.
@Пример:
rc.SetTypeColumn1C(Строка, Число, Дата, Справочник.Тест_2, Справочник, Перечисление._ТестПакеты, Документ, Документ.Док_2);"
    },
    {"Item","AST","ВыборкаОткрыта","IsOpen",
"ВыборкаОткрыта(<?>)",
"IsOpen(<?>)",
"@Синтаксис:
ВыборкаОткрыта()
@Назначение:
возвращает 1, если выборка открыта, иначе 0.
@Возвращаемое значение:
(Число)"
    },
    {"Item","AST","След","MoveNext",
"След(<?>)",
"MoveNext(<?>)",
"@Синтаксис:
След()
@Назначение:
продвигает курсор на следующую позицию, если достигнут конец выборки возвращает 0, иначе 1.
@Возвращаемое значение:
(Число)"
    },
    {"Item","AST","Пред","MovePrevious",
"Пред(<?>)",
"MovePrevious(<?>)",
"@Синтаксис:
Пред()
@Назначение:
продвигает курсор на предыдущую позицию, если текущая строка была первая на момент выполнения метода, то метод вернет 0, иначе 1.
@Возвращаемое значение:
(Число)"
    },
    {"Item","AST","ВНачало","MoveFirst",
"ВНачало(<?>)",
"MoveFirst(<?>)",
"@Синтаксис:
ВНачало()
@Назначение:
двигает курсор в начало выборки.
@Возвращаемое значение:
(Число)"
    },
    {"Item","AST","ВКонец","MoveLast",
"ВКонец(<?>)",
"MoveLast(<?>)",
"@Синтаксис:
ВКонец()
@Назначение:
двигает курсор в конец выборки.
@Возвращаемое значение:
(Число)"
    },
    {"Item","AST","КолвоПолей","GetFieldCount",
"КолвоПолей(<?>)",
"GetFieldCount(<?>)",
"@Синтаксис:
КолвоПолей()
@Назначение:
возвращает количество столбцов (полей) в выборке.
@Возвращаемое значение:
(Число)"
    },
    {"Item","AST","Начало","IsBof",
"Начало(<?>)",
"IsBof(<?>)",
"@Синтаксис:
Начало()
@Назначение:
возвращает 1, когда курсор перешел за начало выборки, иначе 0.
@Возвращаемое значение:
(Число)"
    },
    {"Item","AST","Конец","IsEof",
"Конец(<?>)",
"IsEof(<?>)",
"@Синтаксис:
Конец()
@Назначение:
возвращает 1 пока курсор не пройдет последнюю строку выборки, 0 - курсор находится за последней строкой выборки.
@Возвращаемое значение:
(Число)"
    },
    {"Item","AST","ИндексПоля","GetFieldIndex",
"ИндексПоля(<?>)",
"GetFieldIndex(<?>)",
"@Синтаксис:
ИндексПоля(<strNameColumn>)
@Назначение:
метод возвращает позицию столбца выборки по его имени.
@Возвращаемое значение:
(Число)  позиция столбца в диапазоне от 0 до GetFieldCount()-1 включительно. Если колонка с именем, 
переданным в первом параметре, отсутствует в выборке, то метод вернет -1.
@Параметры:
<strNameColumn> - (Строка)  имя столбца
"
    },
    {"Item","AST","СтрокОбработанно","GetRowsAffected",
"СтрокОбработанно(<?>)",
"GetRowsAffected(<?>)",
"@Синтаксис:
СтрокОбработанно()
@Назначение:
возвращает количество обработанных строк во время выполнения запроса.
@Возвращаемое значение:
(Число)"
    },
    {"Item","AST","ПолучитьЗначение","GetValue",
"ПолучитьЗначение(<?>)",
"GetValue(<?>)",
"@Синтаксис:
ПолучитьЗначение(<NamePosCol>)
@Назначение:
возвращает значение строки в колонке с номером или именем полученным в качестве первого параметра.
@Возвращаемое значение:
(Неопределенный)  значение пересечения строки и колонки выборки.
@Параметры:
<NamePosCol> - (число/строка)  число - номер колонки, допустимый диапазон [1…GetFieldCount()], строка - имя колонки."
    },
    {"Item","AST","ПолучитьЗначения","GetValues",
"ПолучитьЗначения(<?>)",
"GetValues(<?>)",
"@Синтаксис:
ПолучитьЗначения(<...>)
@Назначение:
возвращает значения колонок по текущей строке выборки. Количество параметров неограниченно, но будут заполнены значениями из выборки только те параметры, которые окажутся в диапазоне [1…GetFieldCount()].
@Параметры:
<...> -"
    },
    {"Item","AST","ПолучитьЗначенияСЗ","GetValuesInSV",
"ПолучитьЗначенияСЗ(<?>)",
"GetValuesInSV(<?>)",
"@Синтаксис:
ПолучитьЗначенияСЗ(<PosNamesCol>)
@Назначение:
возвращает в списке значений все содержимое колонок или колонки, указанных в качестве строк(и) (название колонки) или числа (порядкового номера колонки) из выборки.
@Возвращаемое значение:
(СписокЗначений/Структура)  Список значений возвращается только тогда, когда в качестве первого параметра передано число - номер колонки. Структура возвращается всегда, когда в качестве параметра метода передавалась строка с названием/названиями колонок. В структуре определяются свойства с именами колонок, полученных из строки и существующих в выборке, далее в эти свойства записываются списки значений, содержащие значения колонок из всех строк текущей выборки.
@Параметры:
<PosNamesCol> - (число/строка)  число число - номер колонки, допустимый диапазон [1…GetFieldCount()], строка название колонки или колонок разделенный запятыми."
    },
    {"Item","AST","ПолучитьРезультатыВ_ТЗ","GetResultsInVT",
"ПолучитьРезультатыВ_ТЗ(<?>)",
"GetResultsInVT(<?>)",
"@Синтаксис:
ПолучитьРезультатыВ_ТЗ(<vt>,<bEraseVT>)
@Назначение:
возвращает результаты выборки в полученную таблицу значений или в класс производном от него.
@Параметры:
<vt> - (ТаблицаЗначений)  таблица значений или производный от нее класс в которая заполняет результатами из выборки.
<bEraseVT> - (Число)  Необязательный параметр.   1 - очистить таблицу и создать колонки автоматически, 0 - не очищать таблицу, а использовать существующие колонки, соответствие между колонками таблицы и колонками выборки проводится по порядковым номером, т.е. колонка первая таблицы заполняется значениями из колонки первой выборки и т.д. вплоть до GetFieldCount()."
    },
    {"Item","AST","ВыполнитьSQL_ИзТЗ","ExeSQL_FromTV",
"ВыполнитьSQL_ИзТЗ(<?>)",
"ExeSQL_FromTV(<?>)",
"@Синтаксис:
ВыполнитьSQL_ИзТЗ(<tvValues>,<nNumOfRow>)
@Назначение:
метод выполняет параметрический запрос и в качестве параметров берет значения из переданной таблицы.
@Параметры:
<tvValues> - (ТаблицаЗначений)  таблица со значениями параметров запроса. Для указания вида преобразования объектов 1С используется свойства колонки Положение которое устанавливает при помощи методов 
НоваяКолонка и УстановитьПараметрыКолонки таблицы значений, свойство может принимать следующие значения: 1 - короткая строка (9 - символов), 2 - длинная строка (13 - символов), 3 - супер длинная строка (15 
символов), более детально об этих строках можно узнать из описания метода GetParam данного класса. Имена колонок не имеют значения, берется в расчет позиция колонки, т.е. значения первой колонки 
подставляются в качестве первого параметра запроса, вторая колонка соответствует второму параметру и т.д.
<nNumOfRow> - (Число)  Необязательный параметр.   Необязателен, по умолчанию равен 0. Данный параметр определяет размер блока, который будет заполняется параметрами из таблицы, без пересылки на 
сервер базы, как только количество строк в блоке достигнет указанного в параметре производиться пересылка данных на сервер с последующем очищением буфера. Если передано нулевое значение данного 
параметра, то расчет размера блока производится по следующей формуле: всего количество строк переданной таблицы умножается 0.1, т.е. 10% от общего числа строк.
@Пример:
rc = СоздатьОбъект(ODBCRecordSet);
rc.Execute(DELETE FROM [TestSQL].[dbo].[MyTable]);              
rc.Close();

rc.Prepare(INSERT INTO MyTable (NAME, AGE, SALARY, DATEOFBIRTH) VALUES(?, ?, ?, ?));
тз = СоздатьОбъект(ТаблицаЗначений);

тз.НоваяКолонка(NAME,Строка,,,,,,0);
тз.НоваяКолонка(AGE,Число,4,,,,,);      
тз.НоваяКолонка(SALARY,Число,18,2,,,,0);
тз.НоваяКолонка(DATEOFBIRTH,Дата,,,,,,0);
        
for i = 1 to 10 do
                тз.НоваяСтрока();
        тз.NAME        = Панферов Вартан;
        тз.AGE         = 28;
        тз.SALARY      = 1453.12;
        тз.DATEOFBIRTH = '17.11.1974';
        тз.НоваяСтрока();
        тз.NAME        = Гусев Дмитрий;
        тз.AGE         = 23;
        тз.SALARY      = 1233.99;
        тз.DATEOFBIRTH = '09.03.1980';
enddo;          
rc.ExeSQL_FromTV(тз);
"
    },
    {"Item","AST","УстановитьТекстовыйПараметр","SetTextParam",
"УстановитьТекстовыйПараметр(<?>,<?>)",
"SetTextParam(<?>,<?>)",
"@Синтаксис:
SetTextParam(<strName>, <unVal>)
@Назначение:
устанавливает текстовый параметр. Необходимо вызывать до передачи текста 
запроса.
@Параметры:
<strName> (строка): имя текстового параметра;
<unVal> (Неопределенный): значение текстового параметра.
"
    },
    {"Item","AST","ПолучитьПараметрыПоля","GetFieldDefs",
"ПолучитьПараметрыПоля(<?>,<?>,<?>,<?>,<?>,<?>,<?>,<?>)",
"GetFieldDefs(<?>,<?>,<?>,<?>,<?>,<?>,<?>,<?>)",
"@Синтаксис:
GetFieldDefs(NamePosCol, strType1C, nLength1С, nPrec1С, nSQLType, nSQLPrecision, nSQLScale, nSQLNullability)
@Назначение:
если первым параметром передан номер поля возвращается его имя, если передано 
имя возвращается номер поля.
@Параметры:
- NamePosCol (строка/число): номер или имя поля. Входной параметр, 
остальные выходные и могут не использоваться;
- strType1C (строка): обозначение типа в 1С;
- nLength1С (число): обозначение длины в 1С;
- nPrec1С (число): обозначение точности в 1С;
- nSQLType (число): номер типа в ODBC;
- nSQLPrecision (число): длина типа в ODBC;
- nSQLScale (число): точность типа в ODBC;
- nSQLNullability (число): допустимость значений NULL в ODBC.
"
    },
    {"Item","AST","АвтоТипизация","AutoTypification",
"АвтоТипизация(<?>)",
"AutoTypification(<?>)",
"@Синтаксис:
AutoTypification(bOnOff)
@Назначение:
устанавливает/снимает режим работы объекта в котором происходит 
автоматическая типизация и именование полей полученной выборки на 
основании исходных имен полей типа spXXX. Происходит именование поля 
идентификатором 1С (как он задан в конфигураторе), а также назначение 
полю типа 1С по метаданным. Сразу после создания объекта (по умолчанию) 
режим выключен для обратной совместимости.
@Параметры:
- bOnOff (число): 1 - включить, 0 - выключить;
"
    },
    {"Item","AST","УложитьСписокОбъектов","PutObjectList",
"УложитьСписокОбъектов(<?>,<?>,<?>)",
"PutObjectList(<?>,<?>,<?>)",
"@Синтаксис:
PutObjectList(ObjList, strTableName, strRefKinde)
@Назначение:
сохраняет список объектов во временной таблице MS SQL. Идентификаторы 
объектов из списка ObjList сохраняются во временной таблице strTableName. Таблица 
имеет единственное поле val char(9). Имя таблицы должно начинаться с символа «#». 
Если strRefKinde идентификатор иерархического справочника, то таблица будет 
содержать элементы иерархически принадлежащие группам переданным в списке. 
(Подобно оператору «в» стандартного языка запросов 1С.)
@Параметры:
- ObjList (СписокЗначений/АгрегатныйТип): список для сохранения или 
элемент справочника, группа справочника, документ и т.п.;
- strTableName (строка): имя таблицы;
- strRefKinde (строка): вид справочника для иерархического включения элементов или вид плана счетов для иерархического включения счетов;
"
    },
    {"Item","AST","УстТаймаутЗапроса","SetQueryTimeout",
"УстТаймаутЗапроса(<?>)",
"SetQueryTimeout(<?>)",
"@Синтаксис:
SetQueryTimeout(nSeconds)
@Назначение:
Устанавливает таймаут выполнения запроса в секундах. Если выполнение запроса не заканчивается до истечения таймаута выполнение метода Open() или Execute() заканчивается с ошибкой. Значение таймаута в 0 секунд означает, что нет никакого таймаута выполнения запроса, и запрос будет выполняться бесконечно. Это значение действует по умолчанию.
@Параметры:
- nSeconds (Число): количество секунд.
"
    },
    {"Item","AST","ИстекТаймаут","IsQueryTimeoutExpired",
"ИстекТаймаут()",
"IsQueryTimeoutExpired()",
"@Синтаксис:
IsQueryTimeoutExpired()
@Назначение:
Позволяет проверить, является ли последняя ошибка выполнения запроса, ошибкой завершения по таймауту. Метод допустимо вызывать только после вызова метода GetLastError().
Возвращает: 1 - было завершение по таймауту, иначе 0.
"
    },
    {"Item","AST","ОбратныйРасчетОтТА","BackFromTAEnabled",
"ОбратныйРасчетОтТА()",
"BackFromTAEnabled()",
"@Синтаксис:
BackFromTAEnabled()
@Назначение:
Разрешает оптимизацию расчета остатков от ТА. По умолчанию такая оптимизация запрещена т.к. запросы ВТ выполняются грязным чтением. Ее полезно включить имея гарантию того что остатки на ТА досчитаны доконца, например в модуле проведения.
Возвращает: 1 - разрешено, иначе 0.
"
    },
    {"Item","AST","ВыполнитьИнструкцию","ExecuteStatement",
"ВыполнитьИнструкцию(<?>,<?>,<?>)",
"ExecuteStatement(<?>,<?>,<?>)",
"@Синтаксис:
ExecuteStatement(strTextSQL, obVT, bEraseVT)
@Назначение:
Выполняет SQL запрос, при ошибке парсинга или при ошибке на ODBC драйвере формируется исключение. Если запрос возвращает набор строк, метод возвращает объект с результатом запроса, если запрос не возвращает набор строк (не select, а DML или прочий), возвращается количество обработанных строк. Если запрос содержит несколько SQL инструкций (multistatement batch), результаты возвращаются только от первой инструкции. Однако, на драйвер уходит весь текст запроса (По спецификации ODBC, будут ли выполнены остальные инструкции в пакете зависит от драйвера. Для драйвера SQL Server они выполняются), остальные результаты игнорируются. Если запрос возвращает набор данных, и в наборе данных нет ни одной строки, это не является ошибкой. Если запрос не параметризированный - метод гарантированно закрывает курсор.
Возвращает: объект с результатом запроса (ТаблицаЗначений или наследник), или число - количество обработанных строк.
@Параметры:
- strTextSQL (Строка): текст запроса, если пустая строка запрос считается параметризированным. По умолчанию пустая строка.
- obVT (объект): ТаблицаЗначений или наследник от нее для приема результатов запроса, именно этот объект и будет возвращаемым значением. Это должен быть именно ТаблицаЗначений или наследник, а не объект реализующий ее интерфейс. Если тип объекта - пустое значение, создается объект типа ТаблицаЗначений. По умолчанию: пустое значение.
- bEraseVT (Число): 1 - очистить таблицу и создать колонки. 0 - не создавать. По умолчанию - 1.
"
    },
    {"Item","AST","ВыполнитьСкалярный","ExecuteScalar",
"ВыполнитьСкалярный(<?>)",
"ExecuteScalar(<?>)",
"@Синтаксис:
ExecuteScalar(strTextSQL)
@Назначение:
Выполняет SQL запрос, при ошибке парсинга или при ошибке на ODBC драйвере формируется исключение. Запрос может возвращать количество обработаных строк: в этом случае возвращается это значение. Запрос может возвращать набор данных состоящий из одной строки, при этом если в наборе данных одна колонка возвращается значение из нее, если запрос возвращает несколько колонок, то возвращается объект Структура, заполненый полями и именами ключей соответствующими именам колонок и значениями из этих колонок. Если запрос возвращает набор данных, и в наборе данных нет ни одной строки, это не является ошибкой, в этом случае возвращается пустое значение типа определенного в первой колонке, или объект Структура, заполненый соответствующим образом. Если запрос не параметризированный - метод гарантированно закрывает курсор.
@Параметры:
- strTextSQL (Строка): текст запроса, если пустая строка запрос считается параметризированным. По умолчанию пустая строка.
"
    },
    {"Item","AST","ВыполнитьXML","ExecuteXML",
"ВыполнитьXML(<?>,<?>)",
"ExecuteXML(<?>,<?>)",
"@Синтаксис:
ВыполнитьXML(strTextSQL, obBinaryData)
@Назначение:
Выполняет запрос и получает результат как XML данные. Если вторым параметром передан объект BinaryData, то результат записывается в этот объект (с учетом текущей кодировки и текущей позиции в файле) при этом возвращаемое значение метода не определено, если второй параметр пустое значение, метод возвращает строку - результат запроса.
@Параметры:
- strTextSQL (Строка): текст запроса, если пустая строка запрос считается параметризированным. По умолчанию пустая строка.
- obBinaryData (объект BinaryData) - объект для получения результата запроса, по умолчанию, пустое значение.
"
    },
    {"Item","AST","РежимRPC","RPCMode",
"РежимRPC(<?>)",
"RPCMode(<?>)",
"@Синтаксис:
ВыполнитьXML(nMode)
@Назначение:
переводит объект в специальный режим выполнения запросов. Только для MSSQL. Когда этот режим включен выполнение запроса происходит с помощью RPC вызова хранимой процедуры sp_executesql. (Подробнее о назначении этой хп можно прочитать в BOL) В сущности это режим парсера, а не режим этого объекта. Не применимо для параметризированных запросов. По умолчанию этот режим выключен.
@Параметры:
- nMode (Число): 1 - включить режим, 0 - выключить режим.
"
    },
    },
 {"Folder","AST","ODBCDatabase","ODBCDatabase",
    {"Item","AST","ODBCDatabase","Назначение",
"ODBCDatabase",
"Назначение",
"@Синтаксис:
ODBCDatabase
@Назначение:
Данный класс представляет собой сущность для подключения и настройки некоторых параметров к источникам данных, через записи DSN и с использованием драйверов ODBC. По умолчанию, в SQL - версии 1С созданный объект подключен к текущему соединению программы 1С:Предприятие."
    },
    {"Item","AST","Закрыть","Close",
"Закрыть(<?>)",
"Close(<?>)",
"@Синтаксис:
Закрыть()
@Назначение:
закрывает установленное ранее соединение и отключает текущий набор (ODBCRecordSet), если таковой подключался к базе."
    },
    {"Item","AST","Соединение","DriverConnect",
"Соединение(<?>)",
"DriverConnect(<?>)",
"@Синтаксис:
Соединение(<СтрокаСоединения>)
@Назначение:
присоединиться по указанному DSN к источнику. В случае успеха возвращает 1, иначе 0.
@Возвращаемое значение:
(Число)  В случае успеха возвращает 1, иначе 0.
@Параметры:
<СтрокаСоединения> - (Строка)  connection-string ::= empty-string[;] | attribute[;] | attribute; connection-string
empty-string ::=
attribute ::= attribute-keyword=attribute-value | DRIVER=[{]attribute-value[}]
attribute-keyword ::= DSN | UID | PWD
         | driver-defined-attribute-keyword
attribute-value ::= character-string
driver-defined-attribute-keyword ::= identifier
Где:
DSN - имя источника. (необязателен, по умолчанию DSN=Default)
FILEDSN - имя файла *.dsn с описание параметров соединения (необязателен)
DRIVER - имя драйвера соединения. (необязателен, по умолчанию значение атрибута берется  из настроек DSN)
UID - имя пользователя
PWD - пароль пользователя
Пример: db.DriverConnect(DSN=pubs; DRIVER=SQL Server; UID=sa; PWD=1234;);"
    },
    {"Item","AST","ПолучитьЗначениеТаймаута","GetConnectionTimeout",
"ПолучитьЗначениеТаймаута(<?>)",
"GetConnectionTimeout(<?>)",
"@Синтаксис:
ПолучитьЗначениеТаймаута()
@Назначение:
возвращает значение таймаута для текущего соединения."
    },
    {"Item","AST","ПолучитьОписаниеОшибки","GetLastError",
"ПолучитьОписаниеОшибки(<?>)",
"GetLastError(<?>)",
"@Синтаксис:
ПолучитьОписаниеОшибки()
@Назначение:
возвращает описание последней возникшей ошибки."
    },
    {"Item","AST","ЕстьСоединение","IsConnected",
"ЕстьСоединение(<?>)",
"IsConnected(<?>)",
"@Синтаксис:
ЕстьСоединение()
@Назначение:
- проверяет установлено ли соединение и возвращает 1 в случае существования соединения с источником и 0 в случае отсутствия последнего."
    },
    {"Item","AST","Открыть","Open",
"Открыть(<?>)",
"Open(<?>)",
"@Синтаксис:
Открыть(<ИмяСоединения>,<ИмяПользователя>,<Пароль>)
@Назначение:
присоединиться по указанному DSN к источнику. В случае успеха возвращает 1, иначе 0. Описание см. выше у метода DriverConnect / Соединение
@Параметры:
<ИмяСоединения> - (Строка)
<ИмяПользователя> - (Строка)
<Пароль> - (Строка)"
    },
    {"Item","AST","УстЗначениеТаймаута","SetConnectionTimeout",
"УстЗначениеТаймаута(<?>)",
"SetConnectionTimeout(<?>)",
"@Синтаксис:
УстЗначениеТаймаута(<чЗначение>)
@Назначение:
установить значение таймаута для текущего соединения.
@Параметры:
<чЗначение> - (Число)"
    },
    {"Item","AST","УстЗначениеТаймаутаЛогина","SetLoginTimeout",
"УстЗначениеТаймаутаЛогина(<?>)",
"SetLoginTimeout(<?>)",
"@Синтаксис:
УстЗначениеТаймаутаЛогина(<чЗначение>)
@Назначение:
установить значение таймаута логина пользователя
@Параметры:
<чЗначение> - (Число)"
    },
    {"Item","AST","УстТолькоЧтение","SetReadOnly",
"УстТолькоЧтение(<?>)",
"SetReadOnly(<?>)",
"@Синтаксис:
УстТолькоЧтение(<nValue>)
@Назначение:
установить соединение в режим Только чтение
@Параметры:
<nValue> - (Число)"
    },
    {"Item","AST","Присоеденить1С","Attach1C",
"Присоеденить1С(<?>)",
"Attach1C(<?>)",
"@Синтаксис:
Присоеденить1С()
@Назначение:
установить в качестве текущего соединения - соединение 1С:Предприятие для SQL."
    },
    {"Item","AST","КонфигурироватьИсточник","ConfigDataSource",
"КонфигурироватьИсточник(<?>)",
"ConfigDataSource(<?>)",
"@Синтаксис:
КонфигурироватьИсточник(p1, p2, p3)
@Назначение:
Конфигурировать источник данных."
    },
    {"Item","AST","ПолучитьВерсиюДрайвера","GetDriverVer",
"ПолучитьВерсиюДрайвера()",
"GetDriverVer()",
"@Синтаксис:
ПолучитьВерсиюДрайвера()
@Назначение:
Получить версию драйвера ODBC."
    },
    {"Item","AST","ПолучитьВерсиюODBC","GetODBCVer",
"ПолучитьВерсиюODBC()",
"GetODBCVer()",
"@Синтаксис:
ПолучитьВерсиюODBC()
@Назначение:
версию менеджера драйверов ODBC."
    },
    },
 {"Folder","AST","SQLLock","SQLLock",
    {"Item","AST","SQLLock","Назначение",
"SQLLock",
"Назначение",
"@Синтаксис:
SQLLock
@Назначение:
Предназначен для получения новых идентификаторов, кодов справочников, номеров документов.
Для получения нового идентификатора достаточно перед GetNewID() установить тип объекта.
Получение новых кодов справочника и номеров документов идет по всем правилам, учитывая метаданные, и значение префикса.
Если тип кода справочника или номера документа число, методами GetNewCode() и GetNewNumber() возвращается строка, что и соответствует типу хранения в ИБ. В этом случае не учитывается значение установленного префикса.
При первом вызове метода GetNewID() происходит обращение к информационной базе для определения последнего назначенного идентификатора, при этом устанавливается блокировка обновления на таблицу справочника или _1sjourn для документов, при следующих вызовах обращения к ИБ не происходит. Полученые идентификаторы допустимо использовать для образования новых объектов только внутри транзакции. Методы GetNewCode() и GetNewNumber() работают аналогично.
В распределенных базах программист должен сам позаботиться о правилах миграции.
Для блокирования используется таймаут. В случае истечения таймаута возбуждается исключение со строкой ошибки 'LockTimeoutExpired'.
Значение таймаута по умолчанию 5 секунд.
"
    },
    {"Item","AST","УстановитьТипОбъекта","SetObjectType",
"УстановитьТипОбъекта(<?>,<?>)",
"SetObjectType(<?>,<?>)",
"@Синтаксис:
УстановитьТипОбъекта(strType, strKind)
@Назначение:
Устанавливает тип объекта для получения идентификатора, кода справочника, номера документа.
@Параметры:
- strType (Строка): тип объекта, допустимые типы 'Справочник', 'Документ';
- strKind (Строка): вид объекта.
"
    },
    {"Item","AST","УстановитьРодителя","SetParent",
"УстановитьРодителя(<?>)",
"SetParent(<?>)",
"@Синтаксис:
УстановитьРодителя(objParent)
@Назначение:
Устанавливает тип объекта для получения идентификатора, кода справочника, номера документа.
@Параметры:
- objParent (Справочник): группа справочника;
"
    },
    {"Item","AST","УстановитьВладельца","SetOwner",
"УстановитьВладельца(<?>)",
"SetOwner(<?>)",
"@Синтаксис:
УстановитьВладельца(objOwner)
@Назначение:
устанавливает владельца для получения нового кода справочника.
+Параметры:
- objOwner (Справочник): элемент справочника;
"
    },
    {"Item","AST","УстановитьДатуНомера","SetDateNum",
"УстановитьДатуНомера(<?>)",
"SetDateNum(<?>)",
"@Синтаксис:
УстановитьДатуНомера(dDateNum)
@Назначение:
устанавливает владельца для получения нового кода справочника.
@Параметры:
- dDateNum (Дата): дата из периода номеров документа;
"
    },
    {"Item","AST","УстановитьПрефикс","SetPrefix",
"УстановитьПрефикс(<?>)",
"SetPrefix(<?>)",
"@Синтаксис:
УстановитьПрефикс(strPrefix)
@Назначение:
Устанавливает префикс для получения новых кодов справочника или номеров документа. Имеет смысл только если код или номер текстовый.
@Параметры:
- strPrefix (Строка): строка префикс;
"
    },
    {"Item","AST","НовыйИД","GetNewID",
"НовыйИД()",
"GetNewID()",
"@Синтаксис:
НовыйИД()
@Назначение:
Позволяет получить новый идентификатор объекта.
Возвращает новый идентификатор (строка 9 символов).
"
    },
    {"Item","AST","НовыйКод","GetNewCode",
"НовыйКод()",
"GetNewCode()",
"@Синтаксис:
НовыйКод()
@Назначение:
Позволяет получить новый код справочника.
Возвращает строку, новый код справочника, следующий по порядку. В зависимости от настроек справочника в метаданных, может быть учтен владелец, родитель.
"
    },
    {"Item","AST","НовыйНомер","GetNewNumber",
"НовыйНомер()",
"GetNewNumber()",
"@Синтаксис:
НовыйНомер()
@Назначение:
Позволяет получить новый номер документа.
Возвращает строку, новый номер документа, следующий по порядку. В зависимости от настроек документа может быть учтена дата периода номеров.
"
    },
    {"Item","AST","УстановитьТаймаут","SetTimeout",
"УстановитьТаймаут(<?>)",
"SetTimeout(<?>)",
"@Синтаксис:
УстановитьТаймаут(nSeconds)
@Назначение:
Устанавливает таймаут для установки блокировки.
@Параметры:
- nSeconds (Число): таймаут;
"
    },
    },
    },
 {"Folder","AST","5. Работа с FormEx","FormEx",
    {"Item","AST","Раскраска таблиц","Раскраска таблиц",
"FONT[<?>] BRUSH[<?>] FONT_S[<?>] BRUSH_S[<?>] COUNT[<?>] INDENT[<?>] FONTSET[<?>] FONTSET_S[<?>]",
"FONT[<?>] BRUSH[<?>] FONT_S[<?>] BRUSH_S[<?>] COUNT[<?>] INDENT[<?>] FONTSET[<?>] FONTSET_S[<?>]",
"Включение раскраски осуществляется методом ВключитьРаскраскуТаблиц() объекта Сервис или
установкой соответствующего флага в свойствах компоненты.
@Описание:
Компонента позволяет устанавливать произвольную раскраску в таблицах
1С (многострочные части документов, формы списков, таблицы значений на форме и т.д.).
Для включения раскраски в таблицу необходимо добавить колонку, формула в которой должна
содержать служебную строку. В общем случае колонка должна располагаться левее колонок,
которые предполагается раскрасить.
Служебная строка может быть как напрямую прописана в формуле колонки (или формироваться
функцией, вызываемой из формулы), так и быть содержимым реквизита. Для таблиц значений
строка раскраски устанавливается в качестве значения ячейки таблицы. Служебная строка состоит
из макрокоманд, которые формируют стиль строки. Макрокоманды регистронезависимы и могут
располагаться в любой последовательности. Ни одна из макрокоманд не является обязательной,
т.е. любая из них может быть опущена при формировании служебной строки.
@Макрокоманды:
FONT[<Цвет>] - задает цвет шрифта строки;
BRUSH[<Цвет>] - задает цвет фона строки;
FONT_S[<Цвет>] - задает цвет шрифта строки, если она является текущей (не влияет на текущую ячейку);
BRUSH_S[<Цвет>] - задает цвет фона строки, если она является текущей (не влияет на текущую ячейку);
COUNT[<КоличествоКолонок>] - задает количество колонок, на которые распространяется раскраска;
INDENT[<Отступ>] - задает количество колонок, которое необходимо пропустить перед началом раскраски;
FONTSET[<КодШрифта>] - задает шрифт строки;
FONTSET_S[<КодШрифта>] - задает шрифт строки, если она является текущей;
@Параметры макрокоманд:
<Цвет> - представление необходимого цвета в формате RGB в виде положительного числа.
Может быть как десятеричным, так шеснадцатиричным (в этом случае необходимо добавить ""0x""
перед числом).
<КоличествоКолонок> - положительное число.
<Отступ> - положительное или отрицательное число.
<КодШрифта> - код пользовательского шрифта, возвращенный методом ""CreateFont(...)/СоздатьШрифт(...)"".

Вместо любого из параметров можно написать строку ""NONE"", тогда соответствующая макрокоманда
применит текущую системную настройку.
Если Отступ задан отрицательным числом, то КоличествоКолонок считает только видимые колонки до
текущей колонки со служебной строкой. После текущей строки (или если Отступ >=0) КоличествоКолонок
считает как видимые, так и невидимые колонки.

Служебная строка с макрокомандами действует только в пределах одной строки.
Макрокоманды FONT, FONT_S, BRUSH, BRUSH_S, FONTSET и FONTSET_S сбрасывают значения макрокоманд COUNT и
INDENT, заданные предыдущей служебной строкой, к нулевому состоянию.
Макрокоманда COUNT сбрасывает значение макрокоманды INDENT, заданное предыдущей служебной строкой,
к нулевому состоянию.

@Замечание:
Флаг ""Отрицательное красным"" игнорируется в раскрашиваемых колонках.
"
    },
 {"Folder","AST","Предопределенные процедуры","",
    {"Item","AST","Порядок вызова","Порядок вызова",
"",
"",
"Первоначально предопределенная процедура ищется в модуле активной формы.
Если процедура присутствует в модуле формы, то она вызывается. В противном случае
процедура ищется во всех загруженных глобальных модулях, в порядке их загрузки, начиная
с основного глобального модуля.
Вызов дополнительных предопределенных процедур сквозной. Т.е. не останавливается после первой найденной
процедуры, а идет дальше, через локальный контекст, основной глобальный модуль и все дополнительный глобальные модули.
"
    },
 {"Folder","AST","Глобальный модуль","",
    {"Item","AST","ПослеОткрытия","OnActivate",
"Процедура ПослеОткрытия(<?>)
КонецПроцедуры",
"Procedure OnActivate(<?>)
EndProcedure",
"@Синтаксис:
Процедура ПослеОткрытия(<Контекст>)
КонецПроцедуры
@Назначение:
Предопределенная процедура после физического создания окна формы в системе.
@Пареметры:
<Контекст> - контекст открытой формы
@Замечание:
В этой процедуре можно вызывать методы, которые помечены как работает только после
физического открытия окна формы.
@Пример:
Процедура ПослеОткрытия(Конт)
        ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
        ФормаРасш.УстановитьФорму(Конт.Форма);
        ФормаРасш.ФиксироватьМногострочнуюЧасть(2);
КонецПроцедуры
"
    },
    {"Item","AST","ПриДвиженииМыши","OnMouseMove",
"Процедура ПриДвиженииМыши(<?>,,,,)
КонецПроцедуры",
"Procedure OnMouseMove(<?>,,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриДвиженииМыши(<Контекст>,<Состояние>,<КоординатаПоГоризонтали>,<КоординатаПоВертикали>,<ФСО>)
КонецПроцедуры
@Назначение:
Предопределенная процедура движения мыши поверх формы.
@Пареметры:
<Контекст> - контекст формы
<Состояние> - битовая маска, показывающаяя текущее состояние кнопок мыши.
<КоординатаПоГоризонтали> - значение координаты курсора мыши по горизонтальной оси (Х).
<КоординатаПоВертикали> - значение координаты курсора мыши по вертикальной оси (Y).
<ФСО> - флаг стандартной обработки. Изначально равен 1. Если в теле процедуры сбросить
значение в 0, то стандартная обработка события не вызывается.
@Пример:
Процедура ПриДвиженииМыши(конт, сост, х, у)
        Состояние( х =  + х +  у =  + у +  сост =  + сост);
КонецПроцедуры
"
    },
    {"Item","AST","ПриНажатииПравойКнопки","OnRButtonDown",
"Процедура ПриНажатииПравойКнопки(<?>,,,,)
КонецПроцедуры",
"Procedure OnRButtonDown(<?>,,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриНажатииПравойКнопки(<Контекст>,<Состояние>,<КоординатаПоГоризонтали>,<КоординатаПоВертикали>,<ФСО>)
КонецПроцедуры
@Назначение:
Предопределенная процедура при нажатии правой кнопки мыши.
@Пареметры:
<Контекст> - контекст формы
<Состояние> - битовая маска, показывающаяя текущее состояние кнопок мыши.
<КоординатаПоГоризонтали> - значение координаты курсора мыши по горизонтальной оси (Х).
<КоординатаПоВертикали> - значение координаты курсора мыши по вертикальной оси (Y).
<ФСО> - флаг стандартной обработки. Изначально равен 1. Если в теле процедуры сбросить
значение в 0, то стандартная обработка события не вызывается.
@Пример:
Процедура ПриНажатииПравойКнопки(конт, сост, х, у)
        Сообщить(Нажата правая кнопка мыши.);
КонецПроцедуры
"
    },
    {"Item","AST","ПриОтжатииПравойКнопки","OnRButtonUp",
"Процедура ПриОтжатииПравойКнопки(<?>,,,,)
КонецПроцедуры",
"Procedure OnRButtonUp(<?>,,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриОтжатииПравойКнопки(<Контекст>,<Состояние>,<КоординатаПоГоризонтали>,<КоординатаПоВертикали>,<ФСО>)
КонецПроцедуры
@Назначение:
Предопределенная процедура вызывается когда отпущена правая кнопка мыши.
@Пареметры:
<Контекст> - контекст формы
<Состояние> - битовая маска, показывающаяя текущее состояние кнопок мыши.
<КоординатаПоГоризонтали> - значение координаты курсора мыши по горизонтальной оси (Х).
<КоординатаПоВертикали> - значение координаты курсора мыши по вертикальной оси (Y).
<ФСО> - флаг стандартной обработки. Изначально равен 1. Если в теле процедуры сбросить
значение в 0, то стандартная обработка события не вызывается.
@Пример:
Процедура ПриОтжатииПравойКнопки(конт, сост, х, у)
        Сообщить(Отпущена правая кнопка мыши.);
КонецПроцедуры
"
    },
    {"Item","AST","ПриДвойномНажатииПравойКнопки","OnRButtonDblClk",
"Процедура ПриДвойномНажатииПравойКнопки(<?>,,,,)
КонецПроцедуры",
"Procedure OnRButtonDblClk(<?>,,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриДвойномНажатииПравойКнопки(<Контекст>,<Состояние>,<КоординатаПоГоризонтали>,<КоординатаПоВертикали>,<ФСО>)
КонецПроцедуры
@Назначение:
Предопределенная процедура при двойном клике правой кнопкой мыши.
@Пареметры:
<Контекст> - контекст формы
<Состояние> - битовая маска, показывающаяя текущее состояние кнопок мыши.
<КоординатаПоГоризонтали> - значение координаты курсора мыши по горизонтальной оси (Х).
<КоординатаПоВертикали> - значение координаты курсора мыши по вертикальной оси (Y).
<ФСО> - флаг стандартной обработки. Изначально равен 1. Если в теле процедуры сбросить
значение в 0, то стандартная обработка события не вызывается.
@Пример:
Процедура ПриДвойномНажатииПравойКнопки(конт, сост, х, у)
        Предупреждение(Двойной правый клик по форме.);
КонецПроцедуры
"
    },
    {"Item","AST","ПриНажатииЛевойКнопки","OnLButtonDown",
"Процедура ПриНажатииЛевойКнопки(<?>,,,,)
КонецПроцедуры",
"Procedure OnLButtonDown(<?>,,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриНажатииЛевойКнопки(<Контекст>,<Состояние>,<КоординатаПоГоризонтали>,<КоординатаПоВертикали>,<ФСО>)
КонецПроцедуры
@Назначение:
Предопределенная процедура при нажатии левой кнопки мыши.
@Пареметры:
<Контекст> - контекст формы
<Состояние> - битовая маска, показывающаяя текущее состояние кнопок мыши.
<КоординатаПоГоризонтали> - значение координаты курсора мыши по горизонтальной оси (Х).
<КоординатаПоВертикали> - значение координаты курсора мыши по вертикальной оси (Y).
<ФСО> - флаг стандартной обработки. Изначально равен 1. Если в теле процедуры сбросить
значение в 0, то стандартная обработка события не вызывается.
@Пример:
Процедура ПриНажатииЛевойКнопки(конт, сост, х, у)
        Сообщить(Нажата левая кнопка мыши.);
КонецПроцедуры
"
    },
    {"Item","AST","ПриОтжатииЛевойКнопки","OnLButtonUp",
"Процедура ПриОтжатииЛевойКнопки(<?>,,,,)
КонецПроцедуры",
"Procedure OnLButtonUp(<?>,,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриОтжатииЛевойКнопки(<Контекст>,<Состояние>,<КоординатаПоГоризонтали>,<КоординатаПоВертикали>,<ФСО>)
КонецПроцедуры
@Назначение:
Предопределенная процедура вызывается когда отпущена левая кнопка мыши.
@Пареметры:
<Контекст> - контекст формы
<Состояние> - битовая маска, показывающаяя текущее состояние кнопок мыши.
<КоординатаПоГоризонтали> - значение координаты курсора мыши по горизонтальной оси (Х).
<КоординатаПоВертикали> - значение координаты курсора мыши по вертикальной оси (Y).
<ФСО> - флаг стандартной обработки. Изначально равен 1. Если в теле процедуры сбросить
значение в 0, то стандартная обработка события не вызывается.
@Пример:
Процедура ПриОтжатииЛевойКнопки(конт, сост, х, у)
        Сообщить(Отпущена левая кнопка мыши.);
КонецПроцедуры
"
    },
    {"Item","AST","ПриДвойномНажатииЛевойКнопки","OnLButtonDblClk",
"Процедура ПриДвойномНажатииЛевойКнопки(<?>,,,,)
КонецПроцедуры",
"Procedure OnLButtonDblClk(<?>,,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриДвойномНажатииЛевойКнопки(<Контекст>,<Состояние>,<КоординатаПоГоризонтали>,<КоординатаПоВертикали>,<ФСО>)
КонецПроцедуры
@Назначение:
Предопределенная процедура при двойном клике левой кнопкой мыши.
@Пареметры:
<Контекст> - контекст формы
<Состояние> - битовая маска, показывающаяя текущее состояние кнопок мыши.
<КоординатаПоГоризонтали> - значение координаты курсора мыши по горизонтальной оси (Х).
<КоординатаПоВертикали> - значение координаты курсора мыши по вертикальной оси (Y).
<ФСО> - флаг стандартной обработки. Изначально равен 1. Если в теле процедуры сбросить
значение в 0, то стандартная обработка события не вызывается.
@Пример:
Процедура ПриДвойномНажатииЛевойКнопки(конт, сост, х, у)
        Предупреждение(Двойной левый клик по форме.);
КонецПроцедуры
"
    },
    {"Item","AST","ПриНажатииКнопкиКлавиатуры","OnChar",
"Процедура ПриНажатииКнопкиКлавиатуры(<?>,,,,,,)
КонецПроцедуры",
"Procedure OnChar(<?>,,,,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриНажатииКнопкиКлавиатуры(<Контекст>,<КодКлавиши>,<Alt>,<Shift>,<Ctrl>,<Символ>,<ФСО>)
КонецПроцедуры
@Назначение:
Предопределенная процедура при нажатии кнопки клавиатуры.
@Пареметры:
<Контекст> - контекст формы
<КодКлавиши> - код нажатой кнопки клавиатуры.
<Alt> - флаг нажатия кнопки <Alt>.
<Shift> - флаг нажатия кнопки <Shift>.
<Ctrl> - флаг нажатия кнопки <Ctrl>.
<Символ> - символ нажатой кнопки в формате ASCII.
<ФСО> - флаг стандартной обработки. Изначально равен 1. Если в теле процедуры сбросить
значение в 0, то стандартная обработка события не вызывается.
@Пример:
Процедура ПриНажатииКнопкиКлавиатуры(конт, код, _а, _ш, _к)
        Предупреждение(Нажата кнопка клавиатуры.);
КонецПроцедуры
"
    },
    {"Item","AST","ПриИзмененииРазмераОкна","OnSize",
"Процедура ПриИзмененииРазмераОкна(<?>,,,)
КонецПроцедуры",
"Procedure OnSize(<?>,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриИзмененииРазмераОкна(<Контекст>,<ТипСобытия>,<Ширина>,<Высота>)
КонецПроцедуры
@Назначение:
Предопределенная процедура при изменении размеров окна формы.
@Пареметры:
<Контекст> - контекст формы
<ТипСобытия> - определяет тип запрошенного изменения размеров.
Этот параметр может принимать одно из следующих значений:
0 - Окно было изменено, но без минимизации или максимизации.
1 - Окно было свернуто (минимизировано).
2 - Окно было развернуто (максимизировано).
<Ширина> - новая ширина формы.
<Высота> - новая высота формы.
@Пример:
Процедура ПриИзмененииРазмераОкна(Конт, ТипСобытия,Ширина,Высота)
  Если ТипСобытия = 1 Тогда
    Сообщить(Окно формы свернуто.);
  ИначеЕсли ТипСОбытия = 2 Тогда
    Сообщить(Окно формы развернуто.);
  Иначе
    Сообщить(Новый размер формы:+Ширина+х+Высота);
  КонецЕсли;
КонецПроцедуры
"
    },
    },
 {"Folder","AST","Модуль формы","",
	{"Folder","AST","Процедуры объекта ""Дерево+Таблица""","",
    {"Item","AST","ПриРазворачиванииУзла","OnItemExpanding",
"Процедура ПриРазворачиванииУзла(<?>,<>)
КонецПроцедуры",
"Procedure OnItemExpanding(<?>,<>)
EndProcedure",
"@Синтаксис:
Процедура ПриРазворачиванииУзла(<НомерСтроки>,<ФСО>)
КонецПроцедуры
@Назначение:
Процедура вызывается при начале разворачивания ветви дерева.
@Пареметры:
<НомерСтроки> - строка с полным путем ветви дерева, которая готовится к раскрытию;
<ФСО> - флаг стандартной обработки. При установке его в 0 ветвь не будет раскрыта.
"
    },
    {"Item","AST","ПослеРазворачиванияУзла","OnItemExpanded",
"Процедура ПослеРазворачиванияУзла(<?>)
КонецПроцедуры",
"Procedure OnItemExpanded(<?>)
EndProcedure",
"@Синтаксис:
Процедура ПослеРазворачиванияУзла(<НомерСтроки>)
КонецПроцедуры
@Назначение:
Процедура вызывается после разворачивания ветви дерева, но до отображения этого действия на форме.
@Пареметры:
<НомерСтроки> - строка с полным путем ветви дерева, которая раскрылась.
"
    },
    {"Item","AST","ПриСворачиванииУзла","OnItemCollapsing",
"Процедура ПриСворачиванииУзла(<?>,<>)
КонецПроцедуры",
"Procedure OnItemCollapsing(<?>,<>)
EndProcedure",
"@Синтаксис:
Процедура ПриСворачиванииУзла(<НомерСтроки>,<ФСО>)
КонецПроцедуры
@Назначение:
Процедура вызывается при начале сворачивания ветви дерева.
@Пареметры:
<НомерСтроки> - строка с полным путем ветви дерева, которая готовится к сворачиванию;
<ФСО> - флаг стандартной обработки. При установке его в 0 ветвь не будет свернута.
"
    },
    {"Item","AST","ПослеСворачиванияУзла","OnItemCollapsed",
"Процедура ПослеСворачиванияУзла(<?>)
КонецПроцедуры",
"Procedure OnItemCollapsed(<?>)
EndProcedure",
"@Синтаксис:
Процедура ПослеСворачиванияУзла(<НомерСтроки>)
КонецПроцедуры
@Назначение:
Процедура вызывается после сворачивания ветви дерева, но до отображения этого действия на форме.
@Пареметры:
<НомерСтроки> - строка с полным путем ветви дерева, которая свернулась.
"
    },
    {"Item","AST","ПриНажатииЛевойКнопкиНадДеревом","OnLButtonOverTree",
"Процедура ПриНажатииЛевойКнопкиНадДеревом(<?>,<>)
КонецПроцедуры",
"Procedure OnLButtonOverTree(<?>,<>)
EndProcedure",
"@Синтаксис:
Процедура ПриНажатииЛевойКнопкиНадДеревом(<НомерСтроки>,<НомерКолонки>)
КонецПроцедуры
@Назначение:
Процедура вызывается при одиночном клике левой кнопкой мыши над объектом.
@Замечание:
При двойном клике над объектом срабатывает функция, которая прописана в формуле перехватываемой таблицы значений.
@Пареметры:
<НомерСтроки> - строка с полным путем ветви дерева, над которой произошел клик;
<НомерКолонки> - число - номер колонки, над которой произошел клик.
"
    },
	},
    {"Item","AST","ПослеОткрытия","OnActivate",
"Процедура ПослеОткрытия()
КонецПроцедуры",
"Procedure OnActivate()
EndProcedure",
"@Синтаксис:
Процедура ПослеОткрытия()
КонецПроцедуры
@Назначение:
Предопределенная процедура после физического создания окна формы в системе.
@Замечание:
В этой процедуре можно вызывать методы, которые помечены как работает только
после физического открытия окна формы.
@Пример:
Процедура ПослеОткрытия()
        ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
        ФормаРасш.УстановитьФорму(Форма);
        ФормаРасш.ФиксироватьМногострочнуюЧасть(2);
КонецПроцедуры
"
    },
    {"Item","AST","ПриДвиженииМыши","OnMouseMove",
"Процедура ПриДвиженииМыши(<?>,,,)
КонецПроцедуры",
"Procedure OnMouseMove(<?>,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриДвиженииМыши(<Состояние>,<КоординатаПоГоризонтали>,<КоординатаПоВертикали>,<ФСО>)
КонецПроцедуры
@Назначение:
Предопределенная процедура движения мыши поверх формы.
@Пареметры:
<Состояние> - битовая маска, показывающаяя текущее состояние кнопок мыши.
<КоординатаПоГоризонтали> - значение координаты курсора мыши по горизонтальной оси (Х).
<КоординатаПоВертикали> - значение координаты курсора мыши по вертикальной оси (Y).
<ФСО> - флаг стандартной обработки. Изначально равен 1. Если в теле процедуры сбросить
значение в 0, то стандартная обработка события не вызывается.
@Пример:
Процедура ПриДвиженииМыши(сост, х, у)
        Состояние( х =  + х +  у =  + у +  сост =  + сост);
КонецПроцедуры
"
    },
    {"Item","AST","ПриНажатииПравойКнопки","OnRButtonDown",
"Процедура ПриНажатииПравойКнопки(<?>,,,)
КонецПроцедуры",
"Procedure OnRButtonDown(<?>,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриНажатииПравойКнопки(<Состояние>,<КоординатаПоГоризонтали>,<КоординатаПоВертикали>,<ФСО>)
КонецПроцедуры
@Назначение:
Предопределенная процедура при нажатии правой кнопки мыши.
@Пареметры:
<Состояние> - битовая маска, показывающаяя текущее состояние кнопок мыши.
<КоординатаПоГоризонтали> - значение координаты курсора мыши по горизонтальной оси (Х).
<КоординатаПоВертикали> - значение координаты курсора мыши по вертикальной оси (Y).
<ФСО> - флаг стандартной обработки. Изначально равен 1. Если в теле процедуры сбросить
значение в 0, то стандартная обработка события не вызывается.
@Пример:
Процедура ПриНажатииПравойКнопки(сост, х, у)
        Сообщить(Нажата правая кнопка мыши.);
КонецПроцедуры
"
    },
    {"Item","AST","ПриОтжатииПравойКнопки","OnRButtonUp",
"Процедура ПриОтжатииПравойКнопки(<?>,,,)
КонецПроцедуры",
"Procedure OnRButtonUp(<?>,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриОтжатииПравойКнопки(<Состояние>,<КоординатаПоГоризонтали>,<КоординатаПоВертикали>,<ФСО>)
КонецПроцедуры
@Назначение:
Предопределенная процедура вызывается когда отпущена правая кнопка мыши.
@Пареметры:
<Состояние> - битовая маска, показывающаяя текущее состояние кнопок мыши.
<КоординатаПоГоризонтали> - значение координаты курсора мыши по горизонтальной оси (Х).
<КоординатаПоВертикали> - значение координаты курсора мыши по вертикальной оси (Y).
<ФСО> - флаг стандартной обработки. Изначально равен 1. Если в теле процедуры сбросить
значение в 0, то стандартная обработка события не вызывается.
@Пример:
Процедура ПриОтжатииПравойКнопки(сост, х, у)
        Сообщить(Отпущена правая кнопка мыши.);
КонецПроцедуры
"
    },
    {"Item","AST","ПриДвойномНажатииПравойКнопки","OnRButtonDblClk",
"Процедура ПриДвойномНажатииПравойКнопки(<?>,,,)
КонецПроцедуры",
"Procedure OnRButtonDblClk(<?>,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриДвойномНажатииПравойКнопки(<Состояние>,<КоординатаПоГоризонтали>,<КоординатаПоВертикали>,<ФСО>)
КонецПроцедуры
@Назначение:
Предопределенная процедура при двойном клике правой кнопкой мыши.
@Пареметры:
<Состояние> - битовая маска, показывающаяя текущее состояние кнопок мыши.
<КоординатаПоГоризонтали> - значение координаты курсора мыши по горизонтальной оси (Х).
<КоординатаПоВертикали> - значение координаты курсора мыши по вертикальной оси (Y).
<ФСО> - флаг стандартной обработки. Изначально равен 1. Если в теле процедуры сбросить
значение в 0, то стандартная обработка события не вызывается.
@Пример:
Процедура ПриДвойномНажатииПравойКнопки(сост, х, у)
        Предупреждение(Двойной правый клик по форме.);
КонецПроцедуры
"
    },
    {"Item","AST","ПриНажатииЛевойКнопки","OnLButtonDown",
"Процедура ПриНажатииЛевойКнопки(<?>,,,)
КонецПроцедуры",
"Procedure OnLButtonDown(<?>,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриНажатииЛевойКнопки(<Состояние>,<КоординатаПоГоризонтали>,<КоординатаПоВертикали>,<ФСО>)
КонецПроцедуры
@Назначение:
Предопределенная процедура при нажатии левой кнопки мыши.
@Пареметры:
<Состояние> - битовая маска, показывающаяя текущее состояние кнопок мыши.
<КоординатаПоГоризонтали> - значение координаты курсора мыши по горизонтальной оси (Х).
<КоординатаПоВертикали> - значение координаты курсора мыши по вертикальной оси (Y).
<ФСО> - флаг стандартной обработки. Изначально равен 1. Если в теле процедуры сбросить
значение в 0, то стандартная обработка события не вызывается.
@Пример:
Процедура ПриНажатииЛевойКнопки(сост, х, у)
        Сообщить(Нажата левая кнопка мыши.);
КонецПроцедуры
"
    },
    {"Item","AST","ПриОтжатииЛевойКнопки","OnLButtonUp",
"Процедура ПриОтжатииЛевойКнопки(<?>,,,)
КонецПроцедуры",
"Procedure OnLButtonUp(<?>,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриОтжатииЛевойКнопки(<Состояние>,<КоординатаПоГоризонтали>,<КоординатаПоВертикали>,<ФСО>)
КонецПроцедуры
@Назначение:
Предопределенная процедура вызывается когда отпущена левая кнопка мыши.
@Пареметры:
<Состояние> - битовая маска, показывающаяя текущее состояние кнопок мыши.
<КоординатаПоГоризонтали> - значение координаты курсора мыши по горизонтальной оси (Х).
<КоординатаПоВертикали> - значение координаты курсора мыши по вертикальной оси (Y).
<ФСО> - флаг стандартной обработки. Изначально равен 1. Если в теле процедуры сбросить
значение в 0, то стандартная обработка события не вызывается.
@Пример:
Процедура ПриОтжатииЛевойКнопки(сост, х, у)
        Сообщить(Отпущена левая кнопка мыши.);
КонецПроцедуры
"
    },
    {"Item","AST","ПриДвойномНажатииЛевойКнопки","OnLButtonDblClk",
"Процедура ПриДвойномНажатииЛевойКнопки(<?>,,,)
КонецПроцедуры",
"Procedure OnLButtonDblClk(<?>,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриДвойномНажатииЛевойКнопки(<Состояние>,<КоординатаПоГоризонтали>,<КоординатаПоВертикали>,<ФСО>)
КонецПроцедуры
@Назначение:
Предопределенная процедура при двойном клике левой кнопкой мыши.
@Пареметры:
<Состояние> - битовая маска, показывающаяя текущее состояние кнопок мыши.
<КоординатаПоГоризонтали> - значение координаты курсора мыши по горизонтальной оси (Х).
<КоординатаПоВертикали> - значение координаты курсора мыши по вертикальной оси (Y).
<ФСО> - флаг стандартной обработки. Изначально равен 1. Если в теле процедуры сбросить
значение в 0, то стандартная обработка события не вызывается.
@Пример:
Процедура ПриДвойномНажатииЛевойКнопки(сост, х, у)
        Предупреждение(Двойной левый клик по форме.);
КонецПроцедуры
"
    },
    {"Item","AST","ПриНажатииКнопкиКлавиатуры","OnChar",
"Процедура ПриНажатииКнопкиКлавиатуры(<?>,,,,,)
КонецПроцедуры",
"Procedure OnChar(<?>,,,,,)
EndProcedure",
"@Синтаксис:
Процедура ПриНажатииКнопкиКлавиатуры(<КодКлавиши>,<Alt>,<Shift>,<Ctrl>,<Символ>,<ФСО>)
КонецПроцедуры
@Назначение:
Предопределенная процедура при нажатии кнопки клавиатуры.
@Пареметры:
<КодКлавиши> - код нажатой кнопки клавиатуры.
<Alt> - флаг нажатия кнопки <Alt>.
<Shift> - флаг нажатия кнопки <Shift>.
<Ctrl> - флаг нажатия кнопки <Ctrl>.
<Символ> - символ нажатой кнопки в формате ASCII.
<ФСО> - флаг стандартной обработки. Изначально равен 1. Если в теле процедуры сбросить
значение в 0, то стандартная обработка события не вызывается.
@Пример:
Процедура ПриНажатииКнопкиКлавиатуры(код, _а, _ш, _к)
        Предупреждение(Нажата кнопка клавиатуры.);
КонецПроцедуры
"
    },
    {"Item","AST","ПриИзмененииРазмераОкна","OnSize",
"Процедура ПриИзмененииРазмераОкна(<?>,,)
КонецПроцедуры",
"Procedure OnSize(<?>,,)
EndProcedure",
"@Синтаксис:
Процедура ПриИзмененииРазмераОкна(<ТипСобытия>,<Ширина>,<Высота>)
КонецПроцедуры
@Назначение:
Предопределенная процедура при изменении размеров окна формы.
@Пареметры:
<ТипСобытия> - определяет тип запрошенного изменения размеров.
Этот параметр может принимать одно из следующих значений:
0 - Окно было изменено, но не без минимизации или максимизации.
1 - Окно было свернуто(минимизировано).
2 - Окно было развернуто(максимизировано).
<Ширина> - новая ширина формы.
<Высота> - новая высота формы.
@Пример:
Процедура ПриИзмененииРазмераОкна(ТипСобытия,Ширина,Высота)
  Если ТипСобытия = 1 Тогда
    Сообщить(Окно формы свернуто.);
  ИначеЕсли ТипСОбытия = 2 Тогда
    Сообщить(Окно формы развернуто.);
  Иначе
    Сообщить(Новый размер формы:+Ширина+х+Высота);
  КонецЕсли;
КонецПроцедуры
"
    },
    },
    },
 {"Folder","AST","Объект Сервис","Service",
 {"Folder","AST","Методы","",
    {"Item","AST","ВключитьРаскраскуТаблиц","ColourBrowse",
"ВключитьРаскраскуТаблиц(<?>)",
"ColourBrowse(<?>)",
"@Синтаксис:
ВключитьРаскраскуТаблиц(<ВыборочнаяРаскраска>)
@Назначение:
Разрешает раскраску таблиц.
@Замечание:
Если необходим функционал раскраски таблиц, то рекомендуется вызвать этот метод
при начале работы системы, т.к. раскрытые на момент выполнения метода таблицы не
перерисовываются сразу.
@Параметры:
<ВыборочнаяРаскраска> - необязательный флаг, показывающий, что раскрашиваться будут
только таблицы явно указанных контекстов : 1 - включить выборочную раскраску.
По умолчанию - 0.  Этот флаг может быть изменен путем установки/сброса флажка на странице
свойств компоненты (в главном меню: Сервис - Параметры).
@Пример:
Сервис = СоздатьОбъект(""Сервис"");
Сервис.ВключитьРаскраскуТаблиц();
"
    },
    {"Item","AST","ВыключитьРаскраскуТаблиц","UnColourBrowse",
"ВыключитьРаскраскуТаблиц()",
"UnColourBrowse()",
"@Синтаксис:
ВыключитьРаскраскуТаблиц()
@Назначение:
Запрещает раскраску таблиц.
@Замечание:
Метод обратный методу @ВключитьРаскраскуТаблиц().
Не забывайте, что раскрытые на момент выполнения метода таблицы не перерисовываются сразу.
@Пример:
Сервис = СоздатьОбъект(""Сервис"");
Сервис.ВыключитьРаскраскуТаблиц();
"
    },
    {"Item","AST","АктивныйКонтекст","ActiveContext",
"АктивныйКонтекст(<?>)",
"ActiveContext(<?>)",
"@Синтаксис:
АктивныйКонтекст(<Контекст>)
@Назначение:
Возвращает контекст активного в данный момент окна.
Возвращает 1 в случае успеха, 0 в противном случае.
@Параметры:
<Контекст> - Переменная, в которую записывается активный контекст.
@Пример:
Процедура ЗакрытьАктивноеОкно()
        Перем Конт;
        Сервис = СоздатьОбъект(""Сервис"");
        Если Сервис.АктивныйКонтекст(Конт) = 1 Тогда
                Конт.Форма.Закрыть(0);
        Иначе
                Сообщить(Активное окно не является контекстным или нет активного окна.);
        КонецЕсли;
КонецПроцедуры
"
    },
    {"Item","AST","ВыполнитьПроцедуру","CallAsProcedure",
"ВыполнитьПроцедуру(<?>,,)",
"CallAsProcedure(<?>,,)",
"@Синтаксис:
ВыполнитьПроцедуру(<Контекст>,<ИмяПроцедуры>,<СписокАргументов>)
@Назначение:
Метод предназначен для выполнения процедуры в заданном контексте.
Возвращает 1 в случае успеха, 0 - в противном случае.
@Пареметры:
<Контекст> - необязательный параметр. Контекст, в котором необходимо выполнить процедуру.
По умолчанию выполняется в текущем контексте.
<ИмяПроцедуры> - строка с именем процедуры.
<СписокАргументов> - необязательный параметр. Список значений, содержащий аргументы
процедуры. Если размер списка меньше, чем количество аргументов процедуры или параметр
опущен, то в оставшиеся аргументы передаются пустые значения. Лишние значения игнорируются.
Значения по умолчанию игнорируются.
@Пример:
Перем Конт;
Сервис = СоздатьОбъект(""Сервис"");
ОткрытьФорму(Обработка.Демо, Конт);
Список = СоздатьОбъект(""СписокЗначений"");
Список.ДобавитьЗначение(""Первый параметр"");
Список.ДобавитьЗначение(""Второй параметр"");
Список.ДобавитьЗначение(""Третий параметр"");
Сервис.ВыполнитьПроцедуру(Конт, ""Выполнить2"", Список);
"
    },
    {"Item","AST","ВыполнитьФункцию","CallAsFunction",
"ВыполнитьФункцию(<?>,,,)",
"CallAsFunction(<?>,,,)",
"@Синтаксис:
ВыполнитьФункцию(<Контекст>,<ИмяФункции>,<СписокАргументов>,<Результат>)
@Назначение:
Метод предназначен для выполнения функции в заданном контексте.
Возвращает 1 в случае успеха, 0 - в противном случае.
@Пареметры:
<Контекст> - необязательный параметр. Контекст, в котором необходимо выполнить функцию.
По умолчанию выполняется в текущем контексте.
<ИмяФункции> - строка с именем функции.
<СписокАргументов> - необязательный параметр. Список значений, содержащий аргументы
функции. Если размер списка меньше, чем количество аргументов функции или параметр
опущен, то в оставшиеся аргументы передаются пустые значения. Лишние значения игнорируются.
Значения по умолчанию игнорируются.
<Результат> - Переменная, в которую возвращается результат выполнения функции.
@Пример:
Перем Конт, Рез;
Сервис = СоздатьОбъект(""Сервис"");
ОткрытьФорму(Обработка.Демо, Конт);
Список = СоздатьОбъект(""СписокЗначений"");
Список.ДобавитьЗначение(""Первый параметр"");
Список.ДобавитьЗначение(""Второй параметр"");
Список.ДобавитьЗначение(""Третий параметр"");
Сервис.ВыполнитьФункцию(Конт, ""Выполнить3"", Список, Рез);
Сообщить(Рез);
"
    },
    {"Item","AST","ПолучитьПеременнуюКонтекста","GetContextVar",
"ПолучитьПеременнуюКонтекста(<?>,,)",
"GetContextVar(<?>,,)",
"@Синтаксис:
ПолучитьПеременнуюКонтекста(<Контекст>,<ИмяПеременной>,<Результат>)
@Назначение:
Метод предназначен для вычисления значения переменной в заданном контексте.
Возвращает 1 в случае успеха, 0 - в противном случае.
@Пареметры:
<Контекст> - необязательный параметр. Контекст, в котором необходимо вычислить значение
переменной. По умолчанию в текущем контексте.
<ИмяПеременной> - строка с именем переменной модуля.
<Результат> - Переменная, в которую возвращается значение переменной.
@Пример:
Перем Конт, Рез;
Сервис = СоздатьОбъект(""Сервис"");
ОткрытьФорму(""Обработка.Демо"", Конт);
Если Сервис.ПолучитьПеременнуюКонтекста(Конт,""Перем0"",Рез) = 1 Тогда
        Сообщить(""Значение переменной контекста: ""+Рез);
КонецЕсли;
"
    },
    {"Item","AST","УстановитьПеременнуюКонтекста","SetContextVar",
"УстановитьПеременнуюКонтекста(<?>,,)",
"SetContextVar(<?>,,)",
"@Синтаксис:
УстановитьПеременнуюКонтекста(<Контекст>,<ИмяПеременной>,<НовоеЗначение>)
@Назначение:
Метод предназначен для установки значения переменной в заданном контексте.
Возвращает 1 в случае успеха, 0 - в противном случае.
@Пареметры:
<Контекст> - необязательный параметр. Контекст, в котором необходимо установить значение
переменной. По умолчанию в текущем контексте.
<ИмяПеременной> - строка с именем переменной модуля.
<НовоеЗначение> - Значение, в которое необходимо установить переменную.
@Пример:
Перем Конт, Рез;
Сервис = СоздатьОбъект(""Сервис"");
ОткрытьФорму(""Обработка.Демо"", Конт);
Если Сервис.ПолучитьПеременнуюКонтекста(Конт,""Перем0"",Рез) = 1 Тогда
        Сообщить(""Старое значение переменной контекста: ""+Рез);
КонецЕсли;
Если Сервис.УстановитьПеременнуюКонтекста(Конт,""Перем0"",""Новое значение"") = 1 Тогда
        Если Сервис.ПолучитьПеременнуюКонтекста(Конт,""Перем0"",Рез) = 1 Тогда
                Сообщить(""Новое значение переменной контекста: ""+Рез);
        КонецЕсли;
КонецЕсли;
"
    },
    {"Item","AST","ВыбратьЗначение","ChooseValue",
"ВыбратьЗначение(<?>,,,,)",
"ChooseValue(<?>,,,,)",
"@Синтаксис:
ВыбратьЗначение(<СписокЗначений>,<Значение>,<Заголовок>,<СпособВыбора>,<Флаг>)
@Назначение:
Метод предназначен для интерактивного выбора значения из списка. Является расширением штатного метода ВыбратьЗначение объекта СписокЗначений.
Возвращает 1 в случае успеха (выбор произведен), 0 - в противном случае.
@Пареметры:
<СписокЗначений> - список значений, из которого необходимо произвести выбор;
<Значение> - идентификатор переменной, куда помещается результат выбора;
<Заголовок> - строка заголовка диалогового окна;
<СпособВыбора> - число, значение которого задает способ выбора значения:
0 - выбор в виде многоуровневого меню; 1 - выбор в виде дерева.
<Флаг> - необязательный параметр.
Для выбора в дереве: 1 - разрешить выбор групп; 0 - запретить.
Для выбора в меню: 0 - простой выбор; 1 - пометка значений; 2 - простой выбор
(без привязки к активному реквизиту); 3 - пометка значений (без привязки к активному
реквизиту). Значение по умолчанию - 0.
Если указано значение из разряда без привязки к активному реквизиту, то меню
показывается в текущей позиции курсора мыши.
@Замечание:
Многоуровневость обеспечивается списками значений, вложенными в основной (см. пример).
Если выбор производится в меню, то значения с представлением - воспринимаются как
разделители.
@Пример:
Сервис = СоздатьОбъект(""Сервис"");
Список = СоздатьОбъект(""СписокЗначений"");
Список.ДобавитьЗначение(1,""Пункт 1"");
Список.ДобавитьЗначение(2,""Пункт 2"");
Список.ДобавитьЗначение(3,""Пункт 3"");
Список.ДобавитьЗначение(4,""Пункт 4"");
Список.ДобавитьЗначение(0,""-"");
// создаем вложенный список
СписокДоп = СоздатьОбъект(""СписокЗначений"");
СписокДоп.ДобавитьЗначение(551,""Пункт 51"");
СписокДоп.ДобавитьЗначение(552,""Пункт 52"");
СписокДоп.ДобавитьЗначение(553,""Пункт 53"");
СписокДоп.ДобавитьЗначение(554,""Пункт 54"");
// добавляем вложенный список
Список.ДобавитьЗначение(СписокДоп,""Пункт 5"");
Список.ДобавитьЗначение(6,""Пункт 6"");
Список.ДобавитьЗначение(7,""Пункт 7"");
Выб = ;
Если Сервис.ВыбратьЗначение(Список,Выб,""Тестовый выбор значения"",0) = 1 Тогда
        Сообщить(Выб);
КонецЕсли;
"
    },
    {"Item","AST","ДобавитьГлобальныйМодуль","AddGlobalModule",
"ДобавитьГлобальныйМодуль(<?>)",
"AddGlobalModule(<?>)",
"@Синтаксис:
ДобавитьГлобальныйМодуль(<ТекстМодуля>)
@Назначение:
Загружает, компилирует и запускает дополнительный глобальный модуль. В случае удачной
загрузки возвращает номер загруженного глобального модуля, иначе - 0.
@Пареметры:
<ТекстМодуля> - строка с текстом добавляемого глобального модуля.
@Замечание:
С версии 1.8.1.3 в дополнительных модулях работает теперь директива ЗагрузитьИзФайла. 
@Пример:
Сервис = СоздатьОбъект(""Сервис"");
глДопМодуль = Сервис.ДобавитьГлобальныйМодуль(""#ЗагрузитьИзФайла ГлобМодуль1.txt"");
"
    },
    {"Item","AST","УдалитьГлобальныйМодуль","DeleteGlobalModule",
"УдалитьГлобальныйМодуль(<?>)",
"DeleteGlobalModule(<?>)",
"@Синтаксис:
УдалитьГлобальныйМодуль(<НомерМодуля>)
@Назначение:
Выгружает дополнительный глобальный модуль. В случае успеха возвращает 1, иначе - 0.
@Пареметры:
<НомерМодуля> - номер дополнительного глобального модуля.
@Пример:
Если глДопМодуль > 0 Тогда
        Сервис = СоздатьОбъект(""Сервис"");
        Сервис.УдалитьГлобальныйМодуль(глДопМодуль);
КонецЕсли;
"
    },
    {"Item","AST","ПоказыватьИндикаторКлавиатуры","ShowKeyboardIndicator",
"ПоказыватьИндикаторКлавиатуры(<?>)",
"ShowKeyboardIndicator(<?>)",
"@Синтаксис:
ПоказыватьИндикаторКлавиатуры(<Флаг>)
@Назначение:
Включает/отключиет показ ракладки клавиатуры и времени в статусной панели 1С:Предприятия.
@Пареметры:
<Флаг> - 0 - отключить показ; 1 - включить показ. Этот флаг может быть изменен путем
установки/сброса флажка на странице свойств компоненты (в главном меню: Сервис - Параметры).
@Пример:
Сервис = СоздатьОбъект(""Сервис"");
Сервис.ПоказыватьИндикаторКлавиатуры(1);
"
    },
    {"Item","AST","УстановитьОбои","SetWallpaper",
"УстановитьОбои(<?>,,,)",
"SetWallpaper(<?>,,,)",
"@Синтаксис:
УстановитьОбои(<Имя>,<Положение>,<Серый>,<ЦветФона>)
@Назначение:
Метод позволяет загрузить свою картику на задний план главного окна 1С:Предприятия.
@Замечание:
Если в библиотеке картинок есть картинка с идентификатором Wallpaper, то при загрузке
компоненты она автоматически загружается в качестве обоев в левый верхний угол, в режиме
оригинального отображения.
@Пареметры:
<Имя> - Имя файла с картинкой (bmp) или идентификатор картинки в библиотеки картинок.
Может быть пустой строкой. В этом случае следующие параметры применяются к текущей
загруженной картинке.
<Положение> - задает положение картинки в окне. Может принимать следующие значения:
0 - не показывать картинку;
1 - показывать в левом верхнем углу;
2 - показывать в правом верхнем углу;
3 - показывать в левом нижнем углу;
4 - показывать в правом нижнем углу;
5 - показывать по центру экрана;
6 - растянуть картинку во все окно;
7 - размножить картинку по окну.
<Серый> - необязательный флаг, задающий показ картинки в режиме градаций серого:
0 -  показ в оригинальном виде; 1 - показ в обесцвеченном виде. По умолчанию 0.
<ЦветФона> - необязательный, число в RGB, задает цвет фона всего окна заднего плана.
@Пример:
Сервис = СоздатьОбъект(""Сервис"");
Сервис.УстановитьОбои(""Лого"",4,1,255);
"
    },
    {"Item","AST","ВысотаСтрокиТаблицы","HeightTableString",
"ВысотаСтрокиТаблицы(<?>,,)",
"HeightTableString(<?>,,)",
"@Синтаксис:
ВысотаСтрокиТаблицы(<Таблица>,<НомерСтроки>,<ТипВозврата>)
@Замечание:
Метод работает только для таблиц, которые уже выведены на экран методом Показать().
@Назначение:
Возвращает высоту строки объекта Таблица в заданных единицах
@Параметры:
<Таблица> - объект Таблица;
<НомерСтроки> - номер строки, высоту которой необходимо вычислить.
<ТипВозврата> - тип возвращаемого значения. Может принимать следующие значения:
1 - возвращается значение в миллиметрах, 2 - возвращается значение в экранных пикселах,
3 - возвращается значение во внутренних юнитах 1С.
@Пример:
Сервис = СоздатьОбъект(""Сервис"");
Таб.Показать(""Тест"");
Сервис.ПрятатьТаблицу(Таб,1);
Для инд = 1 по Таб.ВысотаТаблицы() Цикл
  Сообщить(+инд+ :: 
    +Сервис.ВысотаСтрокиТаблицы(Таб, инд, 1)+мм. :: 
    +Сервис.ВысотаСтрокиТаблицы(Таб, инд, 2)+ :: 
    +Сервис.ВысотаСтрокиТаблицы(Таб, инд, 3));
КонецЦикла;
Сервис.ПрятатьТаблицу(Таб,0);
"
    },
    {"Item","AST","ПрятатьТаблицу","HideTable",
"ПрятатьТаблицу(<?>,)",
"HideTable(<?>,)",
"@Синтаксис:
ПрятатьТаблицу(<Таблица>,<Флаг>)
@Назначение:
Прячет/показывает выведенное окно таблицы.
@Параметры:
<Таблица> - объект Таблица;
<Флаг> - при 1 скрывает окно таблицы, при 0 - показывает скрытое ранее окно.
@Замечание:
Окно таблицы делаеться невидимым, но не уничтожается. Программисту необходимо следить
самостоятельно, чтобы скрытые окна после обработки вновь делались видимыми.
@Пример:
Сервис = СоздатьОбъект(""Сервис"");
Таб.Показать(""Тест"");
Сервис.ПрятатьТаблицу(Таб,1);
Для инд = 1 по Таб.ВысотаТаблицы() Цикл
  Сообщить(+инд+ :: 
    +Сервис.ВысотаСтрокиТаблицы(Таб, инд, 1)+мм. :: 
    +Сервис.ВысотаСтрокиТаблицы(Таб, инд, 2)+ :: 
    +Сервис.ВысотаСтрокиТаблицы(Таб, инд, 3));
КонецЦикла;
Сервис.ПрятатьТаблицу(Таб,0);
"
    },
    {"Item","AST","ОбработкаОжидания","IdleProcessing",
"ОбработкаОжидания(<?>,)",
"IdleProcessing(<?>,)",
"@Синтаксис:
ОбработкаОжидания(<Имя>,<Интервал>)
@Назначение:
Вызывает глобальную процедуру с заданным интервалом в милисекундах.
@Параметры:
<Имя> - строка с именем глобальной процедуры (если в качестве параметра передается 
'пустая строка', то ранее запущенный процесс прекращается);
<Интервал> - интервал вызова в миллисекундах (если в качестве параметра передается 
'пустая строка' или 0, то ранее запущенный процесс прекращается).
@Пример:
Сервис = СоздатьОбъект(""Сервис"");
Сервис.ОбработкаОжидания(""глПолучитьНовыеЗаявки"",200);
"
    },
    {"Item","AST","КоманднаяСтрока","CommandLine",
"КоманднаяСтрока()",
"CommandLine()",
"@Синтаксис:
КоманднаяСтрока()
@Назначение:
Возвращает коммандную строку, с который было запущено 1С:Предприятие.
@Пример:
Сервис = СоздатьОбъект(""Сервис"");
Сообщить(Сервис.КоманднаяСтрока());
"
    },
    {"Item","AST","ПолучитьИменаТаблицы","GetTableNames",
"ПолучитьИменаТаблицы(<?>)",
"GetTableNames(<?>)",
"@Синтаксис:
ПолучитьИменаТаблицы(<Таблица>)
@Назначение:
Возвращает таблицу значений с адресами и идентификаторами поименованных областей 
(колонки ТЗ: 'Адрес', 'Идентификатор', 'Лево', 'Верх', 'Право', 'Низ').
@Параметры:
<Таблица> - объект ""Таблица"";
"
    },
    {"Item","AST","ВерсияОС","OSVersion",
"ВерсияОС()",
"OSVersion()",
"@Синтаксис:
ВерсияОС()
@Назначение:
Возвращает строку с описанием версии операционной системы.
@Пример:
Сервис = СоздатьОбъект(""Сервис"");
Сообщить(Сервис.ВерсияОС());
"
    },
    {"Item","AST","ПолучитьСписокПринтеров","GetPrintersList",
"ПолучитьСписокПринтеров()",
"GetPrintersList()",
"@Синтаксис:
ПолучитьСписокПринтеров()
@Назначение:
Возвращает список значений, где значения - имена принтеров.
"
    },
    {"Item","AST","ГотовностьПринтера","IsPrinterReady",
"ГотовностьПринтера(<?>)",
"IsPrinterReady(<?>)",
"@Синтаксис:
ГотовностьПринтера(<ИмяПринтера>)
@Назначение:
Возвращает показатель готовности принтера.
Возможные значения:
число 0: принтер готов к печати;
список значений с ошибками состояния принтера;
число -2: невозможно создать объект 'СписокЗначений' для списка ошибок.
@Параметры:
<ИмяПринтера> - имя принтера в виде строки.
"
    },
    {"Item","AST","Воспроизвести","Play",
"Воспроизвести(<?>)",
"Play(<?>)",
"@Синтаксис:
Воспроизвести(<ИмяФайла>)
@Назначение:
Проигрывает wav-файл, переданный в качестве параметра.
@Параметры:
<ИмяФайла> - имя wav-файла, который тербуется проиграть.
"
    },
    {"Item","AST","СписокТаблиц","ListMoxel",
"СписокТаблиц()",
"ListMoxel()",
"@Синтаксис:
СписокТаблиц()
@Назначение:
Возвращает список значений, значения в котором имеют тип ""TableEx/РасширениеТаблицы"". 
@Замечание:
У объектов типа ""TableEx/РасширениеТаблицы"" есть только один метод: ""Write/Записать"", параметры 
которого и действия аналогичны соответствующему методу штатного объекта ""Таблица"".
"
    },
    {"Item","AST","УстановитьКурсор","SetCurcor",
"УстановитьКурсор(<?>)",
"SetCurcor(<?>)",
"@Синтаксис:
УстановитьКурсор(<ИмяКурсора>)
@Назначение:
Перехват курсора для главного окна 1С.
@Параметры:
<ИмяКурсора> - Если в качестве параметра передается строковое значение, то оно  воспринимается
как путь к файлу с курсором. Если ни чего не передавать, то для текущего  объекта перехват курсора
отключается. Если передается числовое значение, то устанавливается курсор из системы. 
Возможные значения:
(значение) - (виндовая константа, которой соответсвует это значение)
1 - IDC_ARROW;
2 - IDC_IBEAM;
3 - IDC_WAIT;
4 - IDC_CROSS;
5 - IDC_UPARROW;
6 - IDC_SIZENWSE;
7 - IDC_SIZENESW;
8 - IDC_SIZEWE;
9 - IDC_SIZENS;
10 - IDC_SIZEALL;
11 - IDC_NO;
12 - IDC_APPSTARTING;
13 - IDC_HELP.
@Замечание:
Любое другое числовое значение сбрасывает курсор.
@Пример:
Процедура ПриДвиженииМыши(сост, х, у)
   Сервис = СоздатьОбъект(""Сервис"");
   ФормаРасш = СоздатьОбъект(""РасширениеФормы"");
   Атр = ФормаРасш.ПолучитьАтрибутПоКоординатам(х,у);
   Если ТипЗначенияСтр(Атр) = ""АтрибутФормы"" Тогда
      Сервис.УстановитьКурсор(Число(Атр.Заголовок));
   Иначе
      Сервис.УстановитьКурсор(0);
   КонецЕсли;
КонецПроцедуры
"
    },
    {"Item","AST","ЭмулироватьКлавиатуру","SendKeys",
"ЭмулироватьКлавиатуру(<?>,,)",
"SendKeys(<?>,,)",
"@Синтаксис:
ЭмулироватьКлавиатуру(<Строка>,<Ждать>,<Раскладка>)
@Назначение:
Метод предназначен для программной эмуляции нажатий кнопок на клавиатуре.
@Параметры:
<Строка> - строка для отсылки в буфер клавиатуры (подробнее см. документацию по методу SendKeys из WSH);
<Ждать> - необязательный флаг: 1 - продолжать программу только после обработки сообщения клавиатуры Windows; 0 - продолжить выполнение, не дожидаясь обработки сообщения (по умолчанию).
<Раскладка> - необязательный параметр. Строка с наименованием раскладки или число, соответствующее следующим раскладкам:
	1 - ""English (United States)"" (по умолчанию);
	2 - ""Russian"";
	3 - ""Ukrainian"";
	4 - ""Belarusian"";
	5 - ""German (Germany)"";
	6 - ""French (France)"".
@Пример:
Процедура МаксимизироватьОкно()
   Сервис = СоздатьОбъект(""Сервис"");
   Сервис.SendKeys(""%"");
   Сервис.SendKeys(""{LEFT}{DOWN}{DOWN}{DOWN}{DOWN}{DOWN}{ENTER}"");
КонецПроцедуры
"
    },
    {"Item","AST","СоздатьШрифт","CreateFont",
"СоздатьШрифт(<?>,,,,,,)",
"CreateFont(<?>,,,,,,)",
"@Синтаксис:
СоздатьШрифт(<Имя>,<Высота>,<Жирность>,<Курсив>,<Подчеркивание>,<Зачеркивание>,<Наклон>)
@Назначение:
Создает шривт по указанным параметрам. За основу берется шрифт, установленный в профиле пользователя (настройка интерфейса).
@Параметры:
<Имя> - системное имя шрифта;
<Высота> - высота создаваемого шрифта;
<Жирность> - жирность создаваемого шрифта. Может принимать следующие значения:
        1 - THIN;
        2 - EXTRALIGHT;
        3 - LIGHT;
        4 - NORMAL;
        5 - MEDIUM;
        6 - SEMIBOLD;
        7 - BOLD;
        8 - EXTRABOLD;
        9 - HEAVY;
        другое - DONTCARE;
<Курсив> - флаг использования курсива;
<Подчеркивание> - флаг использования подчеркивания;
<Зачеркивание> - флаг использования зачеркивания;
<Наклон> - значение наклона создаваемого шрифта в десятых долях градуса (только положительное значение).
Все параметры являются необязательными. По умолчанию используются настройки шрифта - основания.
Возвращает код созданного шрифта.
@Предупреждение!!!
Метод работает напрямую с объектом WinApi, поэтому надо быть очень осторожным при его использовании.
@Обязательно удаляйте ненужные уже шрифты методом УдалитьШрифт(...).
"
    },
    {"Item","AST","УдалитьШрифт","DeleteFont",
"УдалитьШрифт(<?>)",
"DeleteFont(<?>)",
"@Синтаксис:
УдалитьШрифт(<КодШрифта>)
@Назначение:
Уничтожает созданный пользователем шрифт.
@Параметры:
<КодШрифта> - код шрифта, полученный из метода СоздатьШрифт(...).
@Предупреждение!!!
Метод работает напрямую с объектом WinApi, поэтому надо быть очень осторожным при его использовании.
"
    },
    {"Item","AST","ПолучитьGUID","GetGUID",
"ПолучитьGUID()",
"GetGUID()",
"@Синтаксис:
ПолучитьGUID()
@Назначение:
Генерирует и возвращает GUID в виде строки.
@Пример:
Сервис = СоздатьОбъект(""Сервис"");
Сообщить(Сервис.ПолучитьGUID());
"
    },
    {"Item","AST","Версия","Version",
"Версия(<?>)",
"Version(<?>)",
"@Синтаксис:
Версия(<ВерсияСтрокой>)
@Назначение:
Возвращает текущую версию компоненты в виде числа. Номер версии представляется в виде шестнадцатиричного числа, каждое слово которого - разряд номера версии.
@Параметры:
<ВерсияСтрокой> - необязательная переменная, в которую возвращается номер версии в виде форматированной строки.
@Пример:
Сервис = СоздатьОбъект(""Сервис"");
стрВерсия = """";
Сообщить(Сервис.Версия(стрВерсия)); // выведет: ""33554688"" (0x02000100)
Сообщить(стрВерсия); // выведет: ""2.0.1.0""
"
    },
    {"Item","AST","ВнешнееСобытие","AsyncEvent",
"ВнешнееСобытие(<?>,<>,<>)",
"AsyncEvent(<?>,<>,<>)",
"@Синтаксис:
ВнешнееСобытие(<Источник>,<Событие>,<Данные>)
@Назначение:
Вызов внешнего события компоненты. Событие обрабатывается в предопределенной процедуре ОбработкаВнешнегоСобытия() текущей активной формы.
@Параметры:
<Источник>,<Событие>,<Данные> - строки для передачи в процедуру ОбработкаВнешнегоСобытия().
"
    },
    },
    },
 {"Folder","AST","Объект РасширениеФормы","FormEx",
 {"Folder","AST","Атрибуты","",
    {"Item","AST","<АтрибутФормы>","<Attribute>",
"",
"",
"@Назначение:
Доступ к объекту АтрибутФормы, где <АтрибутФормы> - идентификатор элемента диалога,
как он задан в конфигураторе.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
Сообщить(ФормаРасш.кнОК.Заголовок);
"
    },
    {"Item","AST","Высота","Height",
"Высота",
"Height",
"@Синтаксис:
Высота
@Назначение:
Доступ к значению высоты формы. Атрибут для чтения/записи.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
ФормаРасш.УстановитьФорму(Форма);
ФормаРасш.Высота = 250;
"
    },
    {"Item","AST","Ширина","Width",
"Ширина",
"Width",
"@Синтаксис:
Высота
@Назначение:
Доступ к значению ширины формы. Атрибут для чтения/записи.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
ФормаРасш.УстановитьФорму(Форма);
ФормаРасш.Ширина = 250;
"
    },
    {"Item","AST","Максимизирована","Maximize",
"Максимизирована",
"Maximize",
"@Синтаксис:
Максимизирована
@Назначение:
Доступ к состоянию окна формы. Атрибут для чтения/записи. 
Возвращает/устанавливает признак развернутости окна формы (для немодальных окон).
@Замечание:
Работает только после физического открытия окна. В момент первого обновления формы 
(до вывода окна на экран) все формы в 1С имеют значение этого атрибута равным 0.
"
    },
    {"Item","AST","Минимизирована","Minimize",
"Минимизирована",
"Minimize",
"@Синтаксис:
Минимизирована
@Назначение:
Доступ к состоянию окна формы. Атрибут для чтения/записи. 
Возвращает/устанавливает признак свернутости окна формы (для немодальных окон).
@Замечание:
Работает только после физического открытия окна.
"
    },
    {"Item","AST","Метка","Label",
"Метка",
"Label",
"@Синтаксис:
Метка
@Назначение:
Доступ к значению метки формы. Атрибут для чтения/записи. 
Возвращает/устанавливет метку формы, которая задается при вызове метода ОткрытьФорму() 
после знака '#' в названии объекта.
"
    },
    {"Item","AST","Верх","Top",
"Верх",
"Top",
"@Синтаксис:
Верх
@Назначение:
Доступ к положению формы. Атрибут для чтения/записи. 
Возвращает/устанавливает координату верхнего края формы относительно главного окна 
программы (для немодальных окон).
"
    },
    {"Item","AST","Лево","Left",
"Лево",
"Left",
"@Синтаксис:
Лево
@Назначение:
Доступ к положению формы. Атрибут для чтения/записи. 
Возвращает/устанавливает координату верхнего края формы относительно главного окна 
программы (для немодальных окон).
"
    },
    {"Item","AST","ЦветФона","BkColor",
"ЦветФона",
"BkColor",
"@Синтаксис:
ЦветФона
@Назначение:
Доступ к цвету фона формы. Атрибут для чтения/записи. 
Возвращает/устанавливает цвет фона формы.
Если задано -1, то устанавливается цвет по умолчанию.
"
    },
    {"Item","AST","Описание","Description",
"Описание",
"Description",
"@Синтаксис:
Описание
@Назначение:
Доступ к описанию формы. Атрибут только для чтения.
Возвращает в виде строки описание формы, заданное в конфигураторе.
"
    },
    },
 {"Folder","AST","Методы","",
    {"Item","AST","УстановитьФорму","AssignForm",
"УстановитьФорму(<?>)",
"AssignForm(<?>)",
"@Синтаксис:
УстановитьФорму(Форма)
@Назначение:
Привязавает указанную форму к объекту. Вся дальнейшая работа будет вестись именно
с этой формой. При создании объекта РасширениеФормы, он сразу привязывается к
текущей форме, если таковая присутствует, т.е. объект создается не в процедуре глобального
модуля.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
ФормаРасш.УстановитьФорму(Форма);
"
    },
    {"Item","AST","ПолучитьФорму","GetForm",
"ПолучитьФорму()",
"GetForm()",
"@Синтаксис:
ПолучитьФорму()
@Назначение:
Возвращает форму, которая указывалась при инициализации объекта в методе УстановитьФорму()
@Пример:
Фрм = ФормаРасш.ПолучитьФорму();
Фрм.Заголовок(Новый заголовок формы);
"
    },
    {"Item","AST","КоличествоАтрибутов","GetNumAttrib",
"КоличествоАтрибутов()",
"GetNumAttrib()",
"@Синтаксис:
КоличествоАтрибутов()
@Назначение:
Возвращает количество атрибутов расширяемой формы.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
ФормаРасш.УстановитьФорму(Форма);
СписокИд = СоздатьОбъект(""СписокЗначений""); 
Для Х = 0 По ФормаРасш.КоличествоАтрибутов() - 1 Цикл
  СписокИд.ДобавитьЗначение(ФормаРасш.ПолучитьАтрибут(Х).Идентификатор());
КонецЦикла;
"
    },
    {"Item","AST","ПолучитьАтрибут","GetAttrib",
"ПолучитьАтрибут(<?>)",
"GetAttrib(<?>)",
"@Синтаксис:
ПолучитьАтрибут(<Номер>)
@Назначение:
Возвращает объект АтрибутФормы.
@Параметры:
<Номер> - номер или строка с идентификатором атрибута формы, проинициализированной
методом УстановитьФорму(). Для получение доступа к многострочной части формы необходимо
в этот метод передать строку МногострочнаяЧасть.
@Замечание по многострочной части:
Для атрибута МногострочнаяЧасть возможно только получение/установка координат.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
ФормаРасш.УстановитьФорму(Форма);
ФормаРасш.ПолучитьАтрибут(5).Слой = ""Основной"";
"
    },
    {"Item","AST","ПолныйПуть","FullPath",
"ПолныйПуть()",
"FullPath()",
"@Синтаксис:
ПолныйПуть()
@Назначение:
Возвращает полный путь к метаданным объекта, которому принадлежит расширяемая форма.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
ФормаРасш.УстановитьФорму(Форма);
Сообщить(ФормаРасш.ПолныйПуть());
// выводит строку вида: C:\myBASE\1Cv7.MD\CalcVar\CalcVar_Number41
"
    },
    {"Item","AST","ТипОбъекта","ObjectType",
"ТипОбъекта()",
"ObjectType()",
"@Синтаксис:
ТипОбъекта()
@Назначение:
Возвращает тип объекта, которому принадлежит расширяемая форма.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
ФормаРасш.УстановитьФорму(Форма);
Сообщить(ФормаРасш.ТипОбъекта());
// выводит строку вида: Обработка
"
    },
    {"Item","AST","ПолныйТипОбъекта","FullObjectType",
"ПолныйТипОбъекта()",
"FullObjectType()",
"@Синтаксис:
ПолныйТипОбъекта()
@Назначение:
Возвращает полный тип объекта, которому принадлежит расширяемая форма.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
ФормаРасш.УстановитьФорму(Форма);
Сообщить(ФормаРасш.ПолныйТипОбъекта());
// выводит строку вида: Справочник.Тестовый.ФормаСписка.ДляВыбора
"
    },
    {"Item","AST","ФиксироватьМногострочнуюЧасть","FixMultiLine",
"ФиксироватьМногострочнуюЧасть(<?>)",
"FixMultiLine(<?>)",
"@Синтаксис:
ФиксироватьМногострочнуюЧасть(<Кол>)
@Назначение:
Фиксирует заданное количество колонок в многострочной части формы. 
@Параметры:
<Кол> - количество фиксируемых колонок
@Замечание:
Метод работает только после физического открытия окна формы.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
ФормаРасш.УстановитьФорму(Форма);
ФормаРасш.ФиксироватьМногострочнуюЧасть(2);
"
    },
    {"Item","AST","ДобавитьАтрибут","AddAttrib",
"ДобавитьАтрибут(<?>)",
"AddAttrib(<?>)",
"@Синтаксис:
ДобавитьАтрибут(<Тип>)
@Назначение:
Добавляет на форму новый реквизит. Возвращает объект вида АтрибутФормы.
@Параметры:
<Тип> - тип создаваемого реквизита.
Возможные значения:
1  - STATIC (Текст)
2  - 1CEDIT (Поле ввода)
3  - BUTTON (Кнопка)
4  - 1CGROUPBOX (Рамка группы)
5  - 1CEDIT (Поле ввода без рамки)
11 - LISTBOX (Список)
12 - CHECKBOX (Флажок)
13 - RADIO (Переключатель)
14 - COMBOBOX (Поле со списком)
15 - TABLE (Таблица)
@ВАЖНОЕ ЗАМЕЧАНИЕ:
Метод работает работает очень нестабильно и вряд ли будет когда-нибудь толком работать.
Одним словом, не рекомедуется к использованию.
"
    },
    {"Item","AST","ПолучитьАтрибутПоКоординатам","GetAttribAtPos",
"ПолучитьАтрибутПоКоординатам(<?>,)",
"GetAttribAtPos(<?>,)",
"@Синтаксис:
ПолучитьАтрибутПоКоординатам(<X>, <Y>)
@Назначение:
Метод предназначен для получения атрибута формы по заданным координатам. При удачном
завершении возвращает объект АтрибутФормы, иначе пустое значение.
@Параметры:
<X> - координата по горизонтальной оси
<Y> - координата по вертикальной оси
@Замечание:
Метод определяет элементы диалога при помощи стандартных функций операционной системы.
Отсюда некоторые ограничения, связанные с порядком обхода элементов диалога.
Советую внимательно относиться к настройке порядка обхода и не пользоваться режимом
автоматический порядок обхода.
@Пример:
Процедура ПриДвиженииМыши(сост, х, у)
        ФормаРасш = СоздатьОбъект(""РасширениеФормы"");
        Атр = ФормаРасш.ПолучитьАтрибутПоКоординатам(х,у);
        Если ТипЗначенияСтр(Атр) = АтрибутФормы Тогда
                Состояние("" х = ""+х+"" у = ""+у+"" сост = ""+сост+"" :: ""+Атр.Заголовок);
        Иначе
                Состояние("" х = ""+х+"" у = ""+у+"" сост = ""+сост);
        КонецЕсли;
КонецПроцедуры
"
    },
    {"Item","AST","НайтиАтрибут","FindAttrib",
"НайтиАтрибут(<?>,)",
"FindAttrib(<?>,)",
"@Синтаксис:
НайтиАтрибут(<ТипФильтра>, <ЗначениеФильтра>)
@Назначение:
Осуществляет поиск атрибута в соответствии с заданным условием. В случае успеха возвращает 1, иначе - 0.
@Параметры:
<ТипФильтра> - задает тип фильтра поиска.
Возможны следующие значения: 1 - по типу атрибута; 2 - по заголовку атрибута;
3 - по значению видимости атрибута; 4 - по значению доступности атрибута;
5 - по принадлежности к слою.
<ЗначениеФильтра> - значение фильтра, соответствующее установленному типу.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы"");
р = ФормаРасш.НайтиАтрибут(1,3);
Пока р = 1 Цикл
        Сообщить(ФормаРасш.ТекущийАтрибут().Заголовок);
        р = ФормаРасш.ПолучитьСледующийАтрибут();
КонецЦикла;
"
    },
    {"Item","AST","ПолучитьСледующийАтрибут","GetNextAttrib",
"ПолучитьСледующийАтрибут()",
"GetNextAttrib()",
"@Синтаксис:
ПолучитьСледующийАтрибут()
@Назначение:
Переход на следующий атрибут, удовлетворяющий условиям, заданным при вызове метода
НайтиАтрибут(). В случае успеха возвращает 1, иначе - 0.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы"");
р = ФормаРасш.НайтиАтрибут(5,""Основной"");
Пока р = 1 Цикл
        Сообщить(ФормаРасш.ТекущийАтрибут().Заголовок);
        р = ФормаРасш.ПолучитьСледующийАтрибут();
КонецЦикла;
"
    },
    {"Item","AST","ТекущийАтрибут","CurrentAttrib",
"ТекущийАтрибут()",
"CurrentAttrib()",
"@Синтаксис:
ТекущийАтрибут()
@Назначение:
Метод предназначен для получение текущего атрибута. Позиционирование на атрибуте
осуществляется методами НайтиАтрибут() и ПолучитьСледующийАтрибут().
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы"");
р = ФормаРасш.НайтиАтрибут(2,""Выбор"");
Пока р = 1 Цикл
        Сообщить(ФормаРасш.ТекущийАтрибут().Идентификатор);
        р = ФормаРасш.ПолучитьСледующийАтрибут();
КонецЦикла;
"
    },
    {"Item","AST","ПолучитьКартинку","GetPicture",
"ПолучитьКартинку(<?>,,,)",
"GetPicture(<?>,,,)",
"@Синтаксис:
ПолучитьКартинку(<Лево>,<Верх>,<Ширина>,<Высота>)
@Назначение:
Метод предназначен для получения части формы в виде объекта Картинка
(см. документацию 1С:Предприятия).
@Параметры:
<Лево> - координата начала вырезаемой области по горизонтальной оси
<Верх> - координата начала вырезаемой области по вертикальной оси
<Ширина> - ширина вырезаемой области
<Высота> - высота вырезаемой области
@Замечание:
Метод работает только после физического открытия и отображения окна формы.
@Пример:
Процедура ПолучитьКартинку(Карт)
// процедура вызывается из объекта Картинка, расположенного на печатной форме
        Перем Лево,Верх,Ширина,Высота;
        ФормаРасш = СоздатьОбъект(""РасширениеФормы"");
        АтрТекст = СоздатьОбъект(""АтрибутФормы"");
        АтрТекст.УстановитьАтрибут(Форма,""Табл"");
        АтрТекст.ПолучитьКоординаты(Лево,Верх,Ширина,Высота);
        Карт.УстановитьКартинку(ФормаРасш.ПолучитьКартинку(Лево,Верх,Ширина,Высота));
КонецПроцедуры
"
    },
    {"Item","AST","ПодсветкаЗакладки","HighlightTabItem",
"ПодсветкаЗакладки(<?>,)",
"HighlightTabItem(<?>,)",
"@Синтаксис:
ПодсветкаЗакладки(<НомерЗакладки>,<ВключитьПодсветку>)
@Назначение:
Метод предназначен для включения/выключения подсветки заданной закладки.
@Замечание:
Метод работает только после физического открытия окна формы.
@Параметры:
<НомерЗакладки> - номер закладки, для которой необходимо изменить состояние подсветки;
<ВключитьПодсветку> - флаг состояния подсветки: 1 - включить; 0 - выключить;
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы"");
Форма.ИспользоватьЗакладки(1);
Форма.Закладки.ДобавитьЗначение(""Основная"");
Форма.Закладки.ДобавитьЗначение(""Дополнительная"");
ФормаРасш.ПодсветкаЗакладки(2, 1); // включаем подсветку дополнительной закладки
"
    },
    {"Item","AST","ДобавитьКартинкиЗакладок","AddTabImages",
"ДобавитьКартинкиЗакладок()",
"AddTabImages(<?>)",
"@Синтаксис:
ДобавитьКартинкиЗакладок(<ИмяКартинки>)
@Назначение:
Добавляет на закладки пиктограммы из библиотеки картинок. В библиотеке картинок должна
присутствовать картинка в формате bmp с пикторгаммами размером 16х16 пикселей.
Пикторгаммы назначаются закладкам по их порядковому номеру. Прозрачным считается
цвет RGB(0, 128, 128). При повторных вызовах пикторгаммы из указанной картинки
добавляются к тем, которые загружены ранее в закладки. Т.е. библитека пикторгамм на
закладках будет увеличиваться.
В случае успеха возвращает 1, иначе - 0.
@Замечание:
Метод работает только после физического открытия окна формы.
@Параметры:
<ИмяКартинки> - идентификатор картинки с пиктограммами в библиотеке картинок конфигурации.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы"");
Форма.ИспользоватьЗакладки(1);
Форма.Закладки.ДобавитьЗначение(""Основная"");
Форма.Закладки.ДобавитьЗначение(""Дополнительная"");
ФормаРасш.ДобавитьКартинкиЗакладок(""ДляЗакладок""); // в картинке две пиктограммы
Форма.Закладки.ДобавитьЗначение(""Второстепенная""); // закладка появится без пиктограммы
ФормаРасш.ДобавитьКартинкиЗакладок(""ДляДопЗакладок""); // добавляется пикторгамма для последней закладки
"
    },
    {"Item","AST","ОбновитьКартинкиЗакладок","RefreshTabImages",
"ОбновитьКартинкиЗакладок()",
"RefreshTabImages()",
"@Синтаксис:
ОбновитьКартинкиЗакладок()
@Назначение:
Метод предназначен для обновления сопоставления пиктограмм и закладок.
Необходимо его вызвать, например, при добавлении новой закладки, для которой уже есть
пикторгамма.
@Замечание:
Метод работает только после физического открытия окна формы.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы"");
Форма.ИспользоватьЗакладки(1);
Форма.Закладки.ДобавитьЗначение(""Основная"");
Форма.Закладки.ДобавитьЗначение(""Дополнительная"");
ФормаРасш.ДобавитьКартинкиЗакладок(""ДляЗакладок""); // в картинке три пиктограммы
Форма.Закладки.ДобавитьЗначение(""Второстепенная""); // закладка появится без пиктограммы
ФормаРасш.ОбновитьКартинкиЗакладок(); // в результате все закладки с соответсвующими пиктограммами
"
    },
    {"Item","AST","ЗапретЗакрытияФормыКнопкой","DisableCloseFormByButton",
"ЗапретЗакрытияФормыКнопкой(<?>)",
"DisableCloseFormByButton(<?>)",
"@Синтаксис:
ЗапретЗакрытияФормыКнопкой(<ФлагЗапрета>)
@Назначение:
Метод предназначен для получения/установки доступности системной кнопки закрытия окна
формы.
@Возвращаемое значение:
Значение доступности ситемной кнопки закрытия окна формы до выполнения метода.
@Замечание:
Метод работает только после физического открытия окна формы.
@Параметры:
<ФлагЗапрета> - необязательный параметр. 1 - сделать недоступной системную кнопку
закрытия окна формы; 0 - разрешить закрытие формы по кнопке.
@Пример:
Если Проведен() = 0 Тогда
        ФормаРасш = СоздатьОбъект(""РасширениеФормы"");
        ФормаРасш.ЗапретЗакрытияФормыКнопкой(1);
КонецЕсли;
"
    },
    {"Item","AST","Обновить","Refresh",
"Обновить()",
"Refresh(<?>)",
"@Синтаксис:
Обновить()
@Назначение:
Вызывает перерисовку формы. В отличии от штатного метода объекта Форма не вызывает
пересчет формул в форме, а просто обновляет окно.
@Замечание:
Метод работает только после физического открытия окна формы.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы"");
ФормаРасш.Обновить();
"
    },
    {"Item","AST","РаскрашиватьТаблицу","ColourTable",
"РаскрашиватьТаблицу(<?>)",
"ColourTable(<?>)",
"@Синтаксис:
РаскрашиватьТаблицу(<Имя>)
@Назначение:
Разрешает раскраску указанной таблицы при включенной частичной раскраске.
@Замечание:
Метод работает только после физического открытия окна формы.
@Параметры:
<Имя> - строка с идентификатором таблицы на форме. Для многострочной части формы
идентификатор - ""МногострочнаяЧасть"".
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы"");
ФормаРасш.РаскрашиватьТаблицу(""Табл"");
"
    },
    {"Item","AST","ПрисоединитьФорму","AttachForm",
"ПрисоединитьФорму(<?>,)",
"AttachForm(<?>)",
"@Синтаксис:
ПрисоединитьФорму(<Положение>,<Форма>)
ПрисоединитьФорму(<Положение>,...)
@Назначение:
Присоединяет к текущей форме другую отрытую форму. Формы разделяются сплиттером.
@Замечание:
Метод работает только после физического открытия окна формы.
При изменении положения сплиттера предопределенная процедура
ПриИзмененииРазмераОкна(...) не вызывается.
В один момент времени может быть присоединена только одна форма.
@Параметры:
<Положение> - необязательный параметр, задающий положение присоединяемой формы
относительно текущей. Может принимать следующие значения: 1 - снизу; 2 - справа;
3 - сверху; 4 - слева. По умолчанию 1.
<Форма> - присоединяемый объект Форма.

Во втором варианте вызова метод работает как процедура ОткрытьФорму(). Соответственно,
в этом случае после первого параметра идут параметра аналогичные штатной процедуре.
Подробней о параметрах см. в соответствующем разделе документации по 1С:Предприятию.
@Пример (вариант 1):
Перем Конт;

Процедура ПослеОткрытия()
        Конт = ;
        Если Форма.РежимВыбора() = 0 Тогда
                РФорма = СоздатьОбъект(""РасширениеФормы"");
                Если ОткрытьФорму(""Справочник.ЕдиницыИзмерения#"",Конт) = 1 Тогда
                        РФорма.ПрисоединитьФорму(,Конт.Форма);
                КонецЕсли;
        КонецЕсли;
КонецПроцедуры
@Пример (вариант 2):
Перем Конт;

Процедура ПослеОткрытия()
        Конт = ;
        Если Форма.РежимВыбора() = 0 Тогда
                РФорма = СоздатьОбъект(""РасширениеФормы"");
                Если РФорма.ПрисоединитьФорму(2,""Справочник.ЕдиницыИзмерения#"",Конт) = 0 Тогда
                        Конт = Ошибка;
                КонецЕсли;
        КонецЕсли;
КонецПроцедуры
"
    },
    {"Item","AST","ОтсоединитьФорму","DetachForm",
"ОтсоединитьФорму()",
"DetachForm()",
"@Синтаксис:
ОтсоединитьФорму()
@Назначение:
Отсоединяет ранее присоединенную форму и закрывает ее.
@Замечание:
Метод работает только после физического открытия окна формы.
Рекомендуется всегда явно отсоединять присоединенные формы при закрытии основной формы.
@Пример:
Процедура ПриЗакрытии()
        РФорма = СоздатьОбъект(""РасширениеФормы"");
        РФорма.ОтсоединитьФорму();
КонецПроцедуры
"
    },
    {"Item","AST","ПоложениеКолонкиТаблицы","TableColumnPosition",
"ПоложениеКолонкиТаблицы(<?>,,)",
"TableColumnPosition(<?>,,)",
"@Синтаксис:
ПоложениеКолонкиТаблицы(<Имя>,<Колонка>,<Положение>)
@Назначение:
Метод служит для изменения положения колонки таблицы значений на форме.
@Замечание:
Метод работает только после физического открытия окна формы.
@Параметры:
<Имя> - строка с идентификатором таблицы значений на форме.
<Колонка> - номер колонки, для которой изменяется положение
<Положение> - новое положение колонки. Может принимать следующие значения:
0 - новая колонка; 1 - в той же колонке; 2 - на следующей строке.
@Ограничение:
При установке положения на следующей строке необходимо произвести дополнительные
действия: добавить и удалить колонку в таблице. Это вызвано тем, что 1С:Предприятие не
распознает сразу, что изменилось количество строк в заголовке таблицы.
@Пример:
Процедура Выполнить()
        РФорма = СоздатьОбъект(""РасширениеФормы"");
        РФорма.ПоложениеКолонкиТаблицы(""Табл"",3,2);
        РФорма.ПоложениеКолонкиТаблицы(""Табл"",4,1);
        Табл.НоваяКолонка();
        Табл.УдалитьКолонку(Табл.КоличествоКолонок());
КонецПроцедуры
"
    },
    {"Item","AST","УстановитьАвтоширинуВТаблице","SetAutoAdjustTable",
"УстановитьАвтоширинуВТаблице(<?>,)",
"SetAutoAdjustTable(<?>,)",
"@Синтаксис:
УстановитьАвтоширинуВТаблице(<Имя>,<Флаг>)
@Назначение:
Снимает/устанавливает флаг автоширины колонок в таблице.
@Замечание:
Метод работает только после физического открытия окна формы.
@Параметры:
<Имя> - строка с идентификатором таблицы значений на форме или МногострочнаяЧасть для
доступа к многострочной части формы.
<Флаг> - новое значение флага автоширины колонок.
@Пример:
РФорма = СоздатьОбъект(""РасширениеФормы"");
РФорма.УстановитьАвтоширинуВТаблице(Табл,0);
"
    },
    {"Item","AST","СбросМодифицированности","ResetModify",
"СбросМодифицированности()",
"ResetModify()",
"@Синтаксис:
СбросМодифицированности()
@Назначение:
Сбрасывает флаг модифицированности для текущей формы.
"
    },
    {"Item","AST","УстановитьКурсор","SetCurcor",
"УстановитьКурсор(<?>)",
"SetCurcor(<?>)",
"@Синтаксис:
УстановитьКурсор(<ИмяКурсора>)
@Назначение:
Перехват курсора для текущего объекта.
@Параметры:
<ИмяКурсора> - Если в качестве параметра передается строковое значение, то оно  воспринимается
как путь к файлу с курсором. Если ни чего не передавать, то для текущего  объекта перехват курсора
отключается. Если передается числовое значение, то устанавливается курсор из системы. 
Возможные значения:
(значение) - (виндовая константа, которой соответсвует это значение)
1 - IDC_ARROW;
2 - IDC_IBEAM;
3 - IDC_WAIT;
4 - IDC_CROSS;
5 - IDC_UPARROW;
6 - IDC_SIZENWSE;
7 - IDC_SIZENESW;
8 - IDC_SIZEWE;
9 - IDC_SIZENS;
10 - IDC_SIZEALL;
11 - IDC_NO;
12 - IDC_APPSTARTING;
13 - IDC_HELP.
@Замечание:
Любое другое числовое значение сбрасывает курсор.
@Пример:
Процедура ПриДвиженииМыши(сост, х, у)
   ФормаРасш = СоздатьОбъект(""РасширениеФормы"");
   Атр = ФормаРасш.ПолучитьАтрибутПоКоординатам(х,у);
   Если ТипЗначенияСтр(Атр) = ""АтрибутФормы"" Тогда
      ФормаРасш.УстановитьКурсор(Число(Атр.Заголовок));
   Иначе
      ФормаРасш.УстановитьКурсор(0);
   КонецЕсли;
КонецПроцедуры
"
    },
    {"Item","AST","ПолучитьИменаТаблиц","GetTablesName",
"ПолучитьИменаТаблиц()",
"GetTablesName()",
"@Синтаксис:
ПолучитьИменаТаблиц()
@Назначение:
Получить имена всех таблиц-шаблонов, заданных для текущей формы.
@Возвращает:
Строку с именами таблиц-шаблонов, разделенных переносом строк.
"
    },
    },
    },
 {"Folder","AST","Объект АтрибутФормы","AttribEx",
 {"Folder","AST","Атрибуты","",
    {"Item","AST","Заголовок","Caption",
"Заголовок",
"Caption",
"@Синтаксис:
Заголовок
@Назначение:
Доступ к значению заголовка атрибута формы. Атрибут для чтения/записи.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
ФормаРасш.УстановитьФорму(Форма);
ФормаРасш.ПолучитьАтрибут(5).Заголовок = ""С&формировать"";
"
    },
    {"Item","AST","Подсказка","Hint",
"Подсказка",
"Hint",
"@Синтаксис:
Подсказка
@Назначение:
Доступ к значению подсказки атрибута формы. Атрибут для чтения/записи.
@Пример:
АтрФормы = СоздатьОбъект(""АтрибутФормы""); 
АтрФормы.УстановитьАтрибут(Форма,10);
АтрФормы.Подсказка = ""Печать документа"";
"
    },
    {"Item","AST","Описание","Description",
"Описание",
"Description",
"@Синтаксис:
Описание
@Назначение:
Доступ к значению описания атрибута формы. Атрибут для чтения/записи.
@Замечание:
Атрибут становится атрибутом только для чтения после физического открытия формы.
@Пример:
АтрФормы = СоздатьОбъект(""АтрибутФормы""); 
АтрФормы.УстановитьАтрибут(Форма,10);
Сообщить(АтрФормы.Описание);
"
    },
    {"Item","AST","Формула","Formula",
"Формула",
"Formula",
"@Синтаксис:
Формула
@Назначение:
Доступ к значению формулы атрибута формы. Атрибут для чтения/записи.
@Пример:
АтрФормы = СоздатьОбъект(""АтрибутФормы""); 
АтрФормы.УстановитьАтрибут(Форма,10);
Если ПустоеЗначение(АтрФормы.Формула)=1 Тогда
    АтрФормы.Формула = ""#Закрыть"";
КонецЕсли;
"
    },
    {"Item","AST","Видимость","Visible",
"Видимость",
"Visible",
"@Синтаксис:
Видимость
@Назначение:
Доступ к значению видимости атрибута формы. Атрибут для чтения/записи.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
ФормаРасш.УстановитьФорму(Форма);
Для Х = 0 По ФормаРасш.КоличествоАтрибутов() - 1 Цикл
  ФормаРасш.ПолучитьАтрибут(Х).Видимость = 1;
КонецЦикла;
"
    },
    {"Item","AST","Доступность","ReadOnly",
"Доступность",
"ReadOnly",
"@Синтаксис:
Доступность
@Назначение:
Доступ к значению доступности атрибута формы. Атрибут для чтения/записи.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
ФормаРасш.УстановитьФорму(Форма);
Для Х = 0 По ФормаРасш.КоличествоАтрибутов() - 1 Цикл
  ФормаРасш.ПолучитьАтрибут(Х).Доступность = 0;
КонецЦикла;
"
    },
    {"Item","AST","Слой","Layer",
"Слой",
"Layer",
"@Синтаксис:
Слой
@Назначение:
Доступ к значению принадлежности к слою атрибута формы. Атрибут для чтения/записи.
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
ФормаРасш.УстановитьФорму(Форма);
Для Х = 0 По ФормаРасш.КоличествоАтрибутов() - 1 Цикл
    Если ФормаРасш.ПолучитьАтрибут(Х).Слой = ""Слой1"" Тогда
        ФормаРасш.ПолучитьАтрибут(Х).Видимость = 0; 
    КонецЕсли;
КонецЦикла;
"
    },
    {"Item","AST","Тип","Type",
"Тип",
"Type",
"@Синтаксис:
Тип
@Назначение:
Доступ к значению типу контрола атрибута. Атрибут только для чтения.
@Возможные значения:
1  - STATIC (Текст)
2  - 1CEDIT (Поле ввода)
3  - BUTTON (Кнопка)
4  - 1CGROUPBOX (Рамка группы)
5  - 1CEDIT (Колонка многострочной части редактируемая)
8  - SysTreeView32 (Дерево групп)
9  - STATIC (Колонка многострочной части с пикторгаммой или просто текстовая)
10 - PICTURE (Картинка)
11 - LISTBOX (Список)
12 - CHECKBOX (Флажок)
13 - RADIO (Переключатель)
14 - COMBOBOX (Поле со списком)
15 - TABLE (Таблица)
@Пример:
ФормаРасш = СоздатьОбъект(""РасширениеФормы""); 
ФормаРасш.УстановитьФорму(Форма);
Для Х = 0 По ФормаРасш.КоличествоАтрибутов() - 1 Цикл
    Если ФормаРасш.ПолучитьАтрибут(Х).Тип = 1 Тогда
        ФормаРасш.ПолучитьАтрибут(Х).Доступность = 0; 
    КонецЕсли;
КонецЦикла;
"
    },
    {"Item","AST","Идентификатор","AttribID",
"Идентификатор",
"AttribID",
"@Синтаксис:
Идентификатор
@Назначение:
Доступ к значению идентификатора атрибута, если он задан. Атрибут только для чтения.
@Пример:
АтрФормы = СоздатьОбъект(""АтрибутФормы""); 
АтрФормы.УстановитьАтрибут(Форма,3);
ИдАтр = АтрФормы.Идентификатор;
"
    },
    {"Item","AST","Значение","Value",
"Значение",
"Value",
"@Синтаксис:
Значение
@Назначение:
Доступ к значению, хранимому в атрибуте. Атрибут для чтения/записи. 
@Пример:
АтрФормы = СоздатьОбъект(""АтрибутФормы""); 
АтрФормы.УстановитьАтрибут(Форма,3);
ЗначениеАтр = АтрФормы.Значение;
АтрФормы.Значение = ТекущаяДата();
"
    },
    {"Item","AST","ЦветФона","BkColor",
"ЦветФона",
"BkColor",
"@Синтаксис:
ЦветФона
@Назначение:
Доступ к цвету фона реквизита. Атрибут для чтения/записи. 
@Замечание:
Применимо только к объеткам на форме ""Текст"" и ""РеквизитДиалога"". 
@Пример:
АтрФормы = СоздатьОбъект(""АтрибутФормы""); 
АтрФормы.УстановитьАтрибут(Форма,3);
АтрФормы.ЦветФона = 255;
"
    },
    {"Item","AST","ЦветШрифта","FontColor",
"ЦветШрифта",
"FontColor",
"@Синтаксис:
ЦветШрифта
@Назначение:
Доступ к цвету шрифта реквизита. Атрибут для чтения/записи. 
@Замечание:
Применимо только к объектам на форме ""Текст"" и ""РеквизитДиалога"". 
@Пример:
АтрФормы = СоздатьОбъект(""АтрибутФормы""); 
АтрФормы.УстановитьАтрибут(Форма,3);
АтрФормы.ЦветШрифта= 255;
"
    },
    {"Item","AST","Маска","Mask",
"Маска",
"Mask",
"@Синтаксис:
Маска
@Назначение:
Доступ к маске реквизита. Атрибут для чтения/записи. 
@Пример:
АтрФормы = СоздатьОбъект(""АтрибутФормы""); 
АтрФормы.УстановитьАтрибут(Форма,3);
АтрФормы.Маска = ""999-99-99"";
"
    },
    {"Item","AST","СвязанС","Related",
"СвязанС",
"Related",
"@Синтаксис:
СвязанС
@Назначение:
Доступ к атрибуту связи реквизита с другим реквизитом на форме. Атрибут для чтения/записи. 
@Пример:
АтрФормы = СоздатьОбъект(""АтрибутФормы""); 
АтрФормы.УстановитьАтрибут(Форма,""Договор"");
АтрФормы.СвязанС = ""Контрагент"";
"
    },
    },
 {"Folder","AST","Методы","",
	{"Folder","AST","для объекта ""Дерево+Таблица""","",
    {"Item","AST","ПерехватитьТаблицуЗначений","WrapValueTable",
"ПерехватитьТаблицуЗначений()",
"WrapValueTable()",
"@Синтаксис:
ПерехватитьТаблицуЗначений()
@Назначение:
Преобразует таблицу значений на форме в объект 'дерево+таблица'.
@Замечание:
Преобразуемая ТЗ должна иметь строго определенную структуру: первые три колонки служебные, 
остальные произвольные. Служебные колонки:
1: содержит ТЗ той же структуры со следующим уровнем дерева,
2: содержит номер пиктограммы, из установленной на перехватываемой ТЗ картинки, для отображения в дереве (если нулевое значение, то используются системные пиктограммы),
3: содержит наименование ветви дерева.
Метод работает только после физического открытия окна формы.
"
    },
    {"Item","AST","ОбновитьДерево","UpdateTree",
"ОбновитьДерево()",
"UpdateTree()",
"@Синтаксис:
ОбновитьДерево()
@Назначение:
Обновляет объект 'дерево+таблица' данными из перехватываемой ТЗ.
@Замечание:
Метод работает только после выполнения метода ""ПерехватитьТаблицуЗначений()"", 
который работает после физического открытия окна формы. 
@Пример:
АтрФормы = СоздатьОбъект(""АтрибутФормы"");
АтрФормы.УстановитьАтрибут(Форма,""Табл"");
АтрФормы.ОбновитьДерево();
"
    },
    {"Item","AST","ТекущаяСтрокаДерева","CurrentTreeItem",
"ТекущаяСтрокаДерева()",
"CurrentTreeItem()",
"@Синтаксис:
ТекущаяСтрокаДерева()
@Назначение:
Возвращает полный путь к текущей строке в дереве.
@Пример:
АтрФормы = СоздатьОбъект(""АтрибутФормы"");
АтрФормы.УстановитьАтрибут(Форма,""Табл"");
Сообщить(АтрФормы.ТекущаяСтрокаДерева();
"
    },
    {"Item","AST","ТекущаяКолонкаДерева","CurrentTreeColumn",
"ТекущаяКолонкаДерева()",
"CurrentTreeColumn()",
"@Синтаксис:
ТекущаяКолонкаДерева()
@Назначение:
Возвращает номер текущей колонки дерева.
@Пример:
АтрФормы = СоздатьОбъект(""АтрибутФормы"");
АтрФормы.УстановитьАтрибут(Форма,""Табл"");
Сообщить(АтрФормы.ТекущаяКолонкаДерева();
"
    },
    {"Item","AST","ЗначениеИзДерева","ValueFromTree",
"ЗначениеИзДерева(<?>,)",
"ValueFromTree(<?>,)",
"@Синтаксис:
ЗначениеИзДерева(<Строка>, <Колонка>)
@Назначение:
Возвращает значение, хранящееся в объекте ""Дерево+таблица"" по указанным в параметрах координатам.
@Параметр:
<Строка> - строка с полным путем к строке дерева (если пустая строка, то значение из текущей строки);
<Колонка> - число, которое задает колонку.
"
    },
    {"Item","AST","ЗначениеВДерево","ValueToTree",
"ЗначениеВДерево(<?>,,)",
"ValueToTree(<?>,,)",
"@Синтаксис:
ЗначениеВДерево(<Строка>, <Колонка>, <Значение>)
@Назначение:
Устанавливает в ячейку объекта ""Дерево+таблица"" по указанным координатам заданное значение.
Возвращает:
0: значение не удалось установить;
1: значение установлено.
@Параметр:
<Строка> - строка с полным путем к строке дерева (если пустая строка, то значение в текущую строку);
<Колонка> - число, которое задает колонку;
<Значение> - значение, которое надо установить в указанную ячейку.
"
    },
    {"Item","AST","РазвернутьУзел","ExpandNode",
"РазвернутьУзел(<?>)",
"ExpandNode(<?>)",
"@Синтаксис:
РазвернутьУзел(<Строка>)
@Назначение:
Разворачивает заданную строку объекта ""Дерево+таблица"".
@Параметр:
<Строка> - строка с полным путем к строке дерева (если пустая строка, то текущая строка);
"
    },
    {"Item","AST","СвернутьУзел","CollapseNode",
"СвернутьУзел(<?>)",
"CollapseNode(<?>)",
"@Синтаксис:
СвернутьУзел(<Строка>)
@Назначение:
Сворачивает заданную строку объекта ""Дерево+таблица"".
@Параметр:
<Строка> - строка с полным путем к строке дерева (если пустая строка, то текущая строка);
"
    },
    {"Item","AST","ЭтоГруппа","IsGroupNode",
"ЭтоГруппа(<?>)",
"IsGroupNode(<?>)",
"@Синтаксис:
ЭтоГруппа(<Строка>)
@Назначение:
Проверяет является ли группой заданная строка объекта ""Дерево+таблица"".
@Параметр:
<Строка> - строка с полным путем к строке дерева (если пустая строка, то текущая строка);
@Возвращает:
1 - если заданный узел имеет вложенные элементы; 0 - иначе.
"
    },
    {"Item","AST","УстановитьТекущийУзел","SetCurrentNode",
"УстановитьТекущийУзел(<?>)",
"SetCurrentNode(<?>)",
"@Синтаксис:
УстановитьТекущийУзел(<Строка>)
@Назначение:
Делает заданную строку объекта ""Дерево+таблица"" текущей.
@Параметр:
<Строка> - строка с полным путем к строке дерева (если пустая строка, то текущая строка);
"
    },
    {"Item","AST","ИдентификаторКолонкиДерева","TreeColumnName",
"ИдентификаторКолонкиДерева(<?>)",
"TreeColumnName(<?>)",
"@Синтаксис:
ИдентификаторКолонкиДерева(<НомерКолонки>)
@Назначение:
Возвращает идентификатор перехваченной таблицы значения по номеру колонки.
@Параметр:
<НомерКолонки> - номер колонки таблицы значений (число, начиная с 1);
"
    },
    {"Item","AST","ПолучитьНомерКолонкиТаблицыЗначений","GetValueTableColumnNum",
"ПолучитьНомерКолонкиТаблицыЗначений(<?>)",
"GetValueTableColumnNum(<?>)",
"@Синтаксис:
ПолучитьНомерКолонкиТаблицыЗначений(<НомерКолонки>)
@Назначение:
Преобразует номер колонки объекта ""Дерево+таблица"" в номер колонки перехваченной таблицы значений.
@Параметр:
<НомерКолонки> - номер колонки дерева (число, начиная с 1);
"
    },
	},
    {"Item","AST","УстановитьАтрибут","AssignAttrib",
"УстановитьАтрибут(<?>,)",
"AssignAttrib(<?>,)",
"@Синтаксис:
УстановитьАтрибут(<Форма>,<Номер>)
@Назначение:
Привязывает объект к реквизиту формы.
@Параметры:
<Форма> - объект Форма.
<Номер> - номер или строка с идентификатором атрибута формы. Для получение доступа к
многострочной части формы необходимо в этот метод передать строку МногострочнаяЧасть.
@Замечание:
Перед использованием объекта обязательно надо привязать его к форме и реквизиту.
Единственное исключение, когда объект получен методом ПолучитьАтрибут() объекта
РасширениеФормы.
@Пример:
АтрФормы = СоздатьОбъект(""АтрибутФормы""); 
АтрФормы.УстановитьАтрибут(Форма,3);
"
    },
    {"Item","AST","ПолучитьФорму","GetForm",
"ПолучитьФорму()",
"GetForm()",
"@Синтаксис:
ПолучитьФорму()
@Назначение:
Возвращает форму, которая указывалась при инициализации объекта в методе УстановитьАтрибут().
@Пример:
Фрм = АтрФормы.ПолучитьФорму();
"
    },
    {"Item","AST","ТипЗначенияСтр","ValueTypeStr",
"ТипЗначенияСтр()",
"ValueTypeStr()",
"@Синтаксис:
ТипЗначенияСтр()
@Назначение:
Возвращает тип значения атрибута в виде строки.
@Пример:
АтрФормы = СоздатьОбъект(""АтрибутФормы""); 
АтрФормы.УстановитьАтрибут(Форма,3);
Сообщить(Тип:  + АтрФормы.ТипЗначенияСтр());
"
    },
    {"Item","AST","ПолучитьКоординаты","GetCoordinates",
"ПолучитьКоординаты(<?>,,,)",
"GetCoordinates(<?>,,,)",
"@Синтаксис:
ПолучитьКоординаты(<Лево>,<Верх>,<Ширина>,<Высота>)
@Назначение:
Получить значения для положения и размеров атрибута. Метод возвращает в переданные
переменные соответствующие значения.
@Параметры:
<Лево> - необязательный параметр. Расстояние от левой границы формы до левой границы атрибута.
<Верх> - необязательный параметр. Расстояние от верхней границы формы до верхней границы атрибута.
<Ширина> - необязательный параметр. Ширина атрибута.
<Высота> - необязательный параметр. Высота атрибута.
@Пример:
АтрФормы = СоздатьОбъект(""АтрибутФормы""); 
АтрФормы.УстановитьАтрибут(Форма,3);
Лево=0; Верх=0; Ширина=0; Высота=0;
АтрФормы.ПолучитьКоординаты(Лево, Верх, Ширина, Высота);
"
    },
    {"Item","AST","УстановитьКоординаты","SetCoordinates",
"УстановитьКоординаты(<?>,,,)",
"SetCoordinates(<?>,,,)",
"@Синтаксис:
УстановитьКоординаты(<Лево>,<Верх>,<Ширина>,<Высота>)
@Назначение:
Устанавливает новые значения для положения и размеров атрибута. Если какой-либо параметр
при вызове метода не задан, то данный параметр не изменяется.
@Параметры:
<Лево> - необязательный параметр. Расстояние от левой границы формы до левой границы атрибута.
<Верх> - необязательный параметр. Расстояние от верхней границы формы до верхней границы атрибута.
<Ширина> - необязательный параметр. Ширина атрибута.
<Высота> - необязательный параметр. Высота атрибута.
@Пример:
АтрФормы = СоздатьОбъект(""АтрибутФормы""); 
АтрФормы.УстановитьАтрибут(Форма,3);
Высота=0;
АтрФормы.ПолучитьКоординаты(,,,Высота);
АтрФормы.УстановитьКоординаты(,,,Высота+40);
"
    },
    {"Item","AST","ПерехватитьСписокЗначений","WrapValueList",
"ПерехватитьСписокЗначений()",
"WrapValueList()",
"@Синтаксис:
ПерехватитьСписокЗначений()
@Назначение:
Добавляет в список значений на форме (поле со списком) возможность ручного набора.
@Замечание:
Метод работает только после физического открытия окна формы.
@Пример:
Процедура ПослеОткрытия()
   АтрФормы = СоздатьОбъект(""АтрибутФормы""); 
   АтрФормы.УстановитьАтрибут(Форма,""VL"");
   АтрФормы.ПерехватитьСписокЗначений();
КонецПроцедуры
"
    },
    {"Item","AST","УстановитьКурсор","SetCurcor",
"УстановитьКурсор(<?>)",
"SetCurcor(<?>)",
"@Синтаксис:
УстановитьКурсор(<ИмяКурсора>)
@Назначение:
Перехват курсора для текущего объекта.
@Параметры:
<ИмяКурсора> - Если в качестве параметра передается строковое значение, то оно  воспринимается
как путь к файлу с курсором. Если ни чего не передавать, то для текущего  объекта перехват курсора
отключается. Если передается числовое значение, то устанавливается курсор из системы. 
Возможные значения:
(значение) - (виндовая константа, которой соответсвует это значение)
1 - IDC_ARROW;
2 - IDC_IBEAM;
3 - IDC_WAIT;
4 - IDC_CROSS;
5 - IDC_UPARROW;
6 - IDC_SIZENWSE;
7 - IDC_SIZENESW;
8 - IDC_SIZEWE;
9 - IDC_SIZENS;
10 - IDC_SIZEALL;
11 - IDC_NO;
12 - IDC_APPSTARTING;
13 - IDC_HELP.
@Замечание:
Любое другое числовое значение сбрасывает курсор.
@Пример:
Процедура ПриДвиженииМыши(сост, х, у)
   ФормаРасш = СоздатьОбъект(""РасширениеФормы"");
   Атр = ФормаРасш.ПолучитьАтрибутПоКоординатам(х,у);
   Если ТипЗначенияСтр(Атр) = ""АтрибутФормы"" Тогда
      Атр.УстановитьКурсор(Число(Атр.Заголовок));
   КонецЕсли;
КонецПроцедуры
"
    },
    },
    },
 {"Folder","AST","Объект РасширениеТаблицы","TableEx",
 {"Folder","AST","Методы","Methods",
    {"Item","AST","Записать","Write",
"Записать(<?>,)",
"Write(<?>,)",
"@Синтаксис:
Записать(<ИмяФайла>,<ТипФайла>)
@Назначение:
Записать таблицу в файл.
@Параметры:
<ИмяФайла> - имя файла.
<ТипФайла> - необязательный параметр. Числовое или строковое выражение, определяющее тип файла:
· отсутствует, 0 или ""MXL"" - формат 1C;
· 1 или ""XLS"" - формат Ms Excel;
· 2 или ""HTM"" или ""HTML"" - формат HTML;
· 3 или ""TXT"" - формат TXT.
"
    },
},
},
 {"Folder","AST","Объект Окна","Windows",
 {"Folder","AST","Методы","",
    {"Item","AST","ПолучитьМеню","GetMenu",
"ПолучитьМеню()",
"GetMenu()",
"@Синтаксис:
ПолучитьМеню()
@Назначение:
Возвращает список значений с главным меню программы. В представлении помещается строка с пунктом
меню, в значении числовой идентификатор пункта меню или список значений, если текущий пункт - это
подменю. Уровень вложения списков значений ограничен только количеством вложенных подменю.
"
    },
    {"Item","AST","ДоступностьМеню","EnableMenu",
"ДоступностьМеню(<?>,)",
"EnableMenu(<?>,)",
"@Синтаксис:
ДоступностьМеню(<ИмяПунктаМеню>,<ФлагДоступности>)
@Назначение:
Устанавливает доступность пункта меню или подменю по имени.
@Параметры:
<ИмяПунктаМеню> - имя пункта меню или подменю в том виде, в котором оно попадает в представление в список
значений, возвращаемый методом ""ПолучитьМеню"";
<ФлагДоступности> - флаг доступности: 1 - пункт меню становится доступным; 0 - запрещается доступ к
пункту меню.
"
    },
    {"Item","AST","ВидимостьМеню","VisibleMenu",
"ВидимостьМеню(<?>,)",
"VisibleMenu(<?>,)",
"@Синтаксис:
ВидимостьМеню(<ИмяПунктаМеню>,<ФлагВидимости>)
@Назначение:
Устанавливает видимость пункта меню или подменю по имени.
@Параметры:
<ИмяПунктаМеню> - имя пункта меню или подменю в том виде, в котором оно попадает в представление в список
значений, возвращаемый методом ""ПолучитьМеню"";
<ФлагВидимости> - флаг видимости: 1 - пункт меню становится видимым; 0 - пункту меню скрывается.
"
    },
    {"Item","AST","ПолучитьПанели","GetToolBars",
"ПолучитьПанели()",
"GetToolBars()",
"@Синтаксис:
ПолучитьПанели()
@Назначение:
Возвращает список значений со списком всех панелей программы. В представлении помещается строка с
наименованием панели, в значении - флаг видимости панели.
"
    },
    {"Item","AST","ПоказыватьПанель","ShowToolBar",
"ПоказыватьПанель(<?>,)",
"ShowToolBar(<?>,)",
"@Синтаксис:
ПоказыватьПанель(<ИмяПанели>,<ФлагВидимости>)
@Назначение:
Устанавливает видимость панели по имени.
@Параметры:
<ИмяПанели> - имя панели в том виде, в котором оно попадает в представление в список
значений, возвращаемый методом ""ПолучитьПанели"";
<ФлагВидимости> - флаг видимости: 1 - панель становится видимой; 0 - панель скрывается.
"
    },
    {"Item","AST","ПоказыватьПанели","ShowToolBars",
"ПоказыватьПанели(<?>)",
"ShowToolBars(<?>)",
"@Синтаксис:
ПоказыватьПанели(<ФлагВидимости>)
@Назначение:
Устанавливает видимость всех панелей.
@Параметры:
<ФлагВидимости> - флаг видимости: 1 - панели становится видимыми; 0 - все панели скрываются.
"
    },
    {"Item","AST","ПоказыватьСтрокуСостояния","ShowStatusBar",
"ПоказыватьСтрокуСостояния(<?>)",
"ShowStatusBar(<?>)",
"@Синтаксис:
ПоказыватьСтрокуСостояния(<ФлагВидимости>)
@Назначение:
Устанавливает видимость строки состояния.
@Параметры:
<ФлагВидимости> - флаг видимости: 1 - строка состояния становится видимой; 0 - строка состояния скрывается.
"
    },
    {"Item","AST","СтильОкна","WindowsStyle",
"СтильОкна(<?>,)",
"WindowsStyle(<?>,)",
"@Синтаксис:
СтильОкна(<Форма>,<Стиль>)
@Назначение:
Устанавливает необходимый стиль для заданного окна.
@Параметры:
<Форма> - необязательный параметр. Объект Форма окна, для которого необходимо установить стиль.
По умолчанию - главное окно программы.
<Стиль> - значение стиля окна (число от 0 до 2).
"
    },
    {"Item","AST","РазмерОкна","WindowsSize",
"РазмерОкна(<?>,,,)",
"WindowsSize(<?>,,,)",
"@Синтаксис:
РазмерОкна(<Форма>,<Ширина>,<Высота>,<Стиль>)
@Назначение:
Установить/получить размер заданного окна.
@Параметры:
<Форма> - необязательный параметр. Объект Форма окна, для которого необходимо установить или получить
размер. По умолчанию - главное окно программы.
<Ширина> - новая ширина окна, в переменную возвращается ширина до вызова метода;
<Высота> - новая высота окна, в переменную возвращается высота до вызова метода;
<Стиль> - имеет смысл только для главного окна программы, устанавливает стиль окна (число 1 или 2).
@Замечание:
Ширину и высоту окна нельзя сделать меньше или равной нулю.
"
    },
    {"Item","AST","ПоложениеОкна","WindowsPos",
"ПоложениеОкна(<?>,,)",
"WindowsPos(<?>,,)",
"@Синтаксис:
ПоложениеОкна(<Форма>,<Лево>,<Верх>)
@Назначение:
Установить/получить положение заданного окна.
@Параметры:
<Форма> - необязательный параметр. Объект Форма окна, для которого необходимо установить или получить
положение. По умолчанию - главное окно программы.
<Лево> - новая координата окна по горизонтали, в переменную возвращается координата до вызова метода;
<Верх> - новая координата окна по вертикали, в переменную возвращается координата до вызова метода.
"
    },
    {"Item","AST","МенюОкна","WindowsMenu",
"МенюОкна(<?>,,,,)",
"WindowsMenu(<?>,,,,)",
"@Синтаксис:
МенюОкна(<Форма>,<Закрыть>,<Максимизировать>,<Минимизировать>,<Восстановить>)
@Назначение:
Управление системным меню окна.
@Параметры:
<Форма> - необязательный параметр. Объект Форма окна, для которого необходимо установить системное меню.
По умолчанию - главное окно программы.
<Закрыть>,<Максимизировать>,<Минимизировать>,<Восстановить> - флаги управления соответсвующими пунктами
системного меню. Если флаг установлен в 0, то пункт меню скрывается.
"
    },
    {"Item","AST","ЦентрироватьОкно","CenterWindow",
"ЦентрироватьОкно(<?>)",
"CenterWindow(<?>)",
"@Синтаксис:
ЦентрироватьОкно(<Форма>)
@Назначение:
Центрирование окна.
@Параметры:
<Форма> - необязательный параметр. Объект Форма окна, которое необходимо центрировать.
По умолчанию - главное окно программы.
"
    },
    {"Item","AST","Максимизировать","Maximize",
"Максимизировать(<?>)",
"Maximize(<?>)",
"@Синтаксис:
Максимизировать(<Форма>)
@Назначение:
Максимизирование окна.
@Параметры:
<Форма> - необязательный параметр. Объект Форма окна, которое необходимо максимизировать.
По умолчанию - главное окно программы.
"
    },
    {"Item","AST","Минимизировать","Minimize",
"Минимизировать(<?>)",
"Minimize(<?>)",
"@Синтаксис:
Минимизировать(<Форма>)
@Назначение:
Минимизирование окна.
@Параметры:
<Форма> - необязательный параметр. Объект Форма окна, которое необходимо минимизировать.
По умолчанию - главное окно программы.
"
    },
    {"Item","AST","Восстановить","Restore",
"Восстановить(<?>)",
"Restore(<?>)",
"@Синтаксис:
Восстановить(<Форма>)
@Назначение:
Восстановление окна.
@Параметры:
<Форма> - необязательный параметр. Объект Форма окна, которое необходимо восстановить.
По умолчанию - главное окно программы.
"
    },
    {"Item","AST","ПолучитьРазрешение","GetResolution",
"ПолучитьРазрешение(<?>,)",
"GetResolution(<?>,)",
"@Синтаксис:
ПолучитьРазрешение(<Горизонтальное>,<Вертикальное>)
@Назначение:
Получить текущее разрешение.
@Параметры:
<Горизонтальное>,<Вертикальное> - переменные, куда возвращаются соответствующие значения текущего
разрешения экрана.
"
    },
    {"Item","AST","НаПереднийПлан","BringWindowToTop",
"НаПереднийПлан(<?>)",
"BringWindowToTop(<?>)",
"@Синтаксис:
НаПереднийПлан(<Форма>)
@Назначение:
Выдвижение окна на передний план.
@Параметры:
<Форма> - необязательный параметр. Объект Форма окна, которое необходимо выдвинуть на передний план.
По умолчанию - главное окно программы.
"
    },
    {"Item","AST","ВключитьМодальныйРежим","BeginModalState",
"ВключитьМодальныйРежим()",
"BeginModalState()",
"@Синтаксис:
ВключитьМодальныйРежим()
@Назначение:
Делает главное окно 1С модальным для системы.
@ВНИМАНИЕ!
С этим методом нужно быть крайне осторожным, т.к. после включения модального режима становятся
недоступны панель задач и любые другие запущенные приложения, кроме 1С:Предприятия.
"
    },
    {"Item","AST","ВыключитьМодальныйРежим","EndModalState",
"ВыключитьМодальныйРежим()",
"EndModalState()",
"@Синтаксис:
ВыключитьМодальныйРежим()
@Назначение:
Отменяет модальный режим главного окна 1С.
"
    },
    {"Item","AST","МинимизироватьВТрей","MinimizeToTray",
"МинимизироватьВТрей(<?>)",
"MinimizeToTray(<?>)",
"@Синтаксис:
МинимизироватьВТрей(<Флаг>)
@Назначение:
Разрешить/запретить сворачивание главного окна в трей при минимизации.
@Параметры:
<Флаг> - число: 1 - разрешить, 0 - запретить.
"
    },
},
},
    },
 {"Folder","AST","Разработчики","Develops",
    {"Item","AST","Гусев Дмитрий aka Deb","",
"Гусев Дмитрий aka Deb",
"",
"Основной движок 1С++ и дополнительные классы - разделы: 3.1, 3.2, 3.3, 3.4, 3.5, 3.7"
    },
    {"Item","AST","Андрей Рачкин","",
"Андрей Рачкин",
"",
"Дополнительные классы - разделы: 3.6, 3.8"
    },
    {"Item","AST","Алекс Л. Фёдоров aka АЛьФ","",
"Алекс Л. Фёдоров aka АЛьФ",
"",
"Дополнительные классы - разделы: 3.9, 3.10, 3.11"
    },
    {"Item","AST","Александр Орефков","",
"Александр Орефков",
"",
"раздел 1.8. Visual 1C++ 1.0"
    },
    },
 {"Folder","AST","История версий","History",
    {"Item","AST","OXY -> 1С++","",
"OXY -> 1С++",
"",
"• Добавлен класс Делегат. Данный класс представляет собой хранилище ссылок на методы 
экземпляров агрегатных объектов 1С. (раздел 3.3 описания ВК);
• Добавлены дополнительные методы в класс МенеджерСобытий (раздел 3.4 описания ВК);
• Добавлен препроцессор (раздел 1.5 описания ВК)."
    },
    {"Item","AST","Версия 1.0.0.1","",
"Версия 1.0.0.1",
"",
"• В методах КОП добавленна возможность передавть любое количество параметров. 
Подробности см. в документации пункт 1.3. раздел <Неопределенное количество параметров>."
    },
    {"Item","AST","Версия 1.0.0.2","",
"Версия 1.0.0.2",
"",
"• Исправлена ошибка, которая появлялась при считывании модулей КОП из файлов-отчетов (*.ert)
  в ОС Windows 98/95;
• Добавлена возможность вызывать методы текущего производного класса из методов его 
  базового класса. Для этого в модуле базового класса необходимо получить контекст и 
  через него возможно вызывать методы производных классов. Также получив контекст в 
  базовом классе возможно узнать тип созданного производного класса. 
  Более подробное описание см. в 1.4.8 документации;
• Исправлена ошибка передачи параметров по значению в методы КОП."
    },
    {"Item","AST","Версия 1.0.0.3","",
"Версия 1.0.0.3",
"",
"• Исправлена ошибка потери возвращаемого значения полученного из функции текущего 
  класса КОП вызванного через контекст;
• Исправлена ошибка получения базового класса по умолчанию в иерархиях классов глубиной 
  более 2 уровней;
• Исправлена ошибка получения базового отдаленного от текущего более чем на 1 уровень 
  в иерархии классов;
• Исправлена ошибка возникавшая при определенных обстоятельствах в передаче параметров 
  по значению;
• Исправлена ошибка возникающая при попытки обращения в конструкторе базового класса 
  к контексту и его методам, как основного функционала классов КОП, так и методов 
  определенных пользователем в классах иерархии, в момент создания производного класса.
• За более подробной информацией об исправленных ошибках обращайтесь по 
  почте компоненты с конкретными вопросами: @debbuger@yandex.ru"
    },
    {"Item","AST","Версия 1.0.0.4","",
"Версия 1.0.0.4",
"",
"@Синтаксис:
Версия 1.0.0.4
@Назначение:
- Исправлена ошибка определения типов параметров при указаном неопределнным типе возвращаемого 
  значения (неопределнный/undefine) метода.

- Добавлена препроцессорная директива //#include, описание см. в док.

- Добавлен дополнительный класс Структура/Struct, более потробное описание см. в док.

- В метод функционала класса КОП ПолучитьСписокПараметров/GetParamsList, теперь необходимо
  передавать строковое значение - название метода в котором требуется получить список неявных
  параметров.

- Удалены из функционала класса КОП методы НачПроведенияВложДок/BegPostNestedDoc и 
  КонПроведенияВложДок/EndPostNestedDoc

- Оптимизирована скорость вызова методов с неявными параметрами (в сигнатуре которых определен
  параметр ...), скорость работы приравнивается к обычным вызовам методов.

- Оптимизирована работа препроцессора и чтение модулей из отчетов 1С."
    },
    {"Item","AST","Версия 1.0.0.5","",
"Версия 1.0.0.5",
"",
"@Синтаксис:
Версия 1.0.0.5
@Назначение:
- Изменилось имя файла определений класса с Defcls.prm на defcls.prm

- Добавлен метод функционала класса ЗаменитьЭксзБазовогоКласса/ReplaceInstBaseClasses

- Добавлен метод функционала класса УстановитьПараметрПоИндексу/SetOnIndexParams

- Изменена семантика значений параметров методов задаваемых по умолчанию. Подробности см. в документации глава 1.3, абзац Значение по умолчанию

- Добавлены Динамические атрибуты класса, подробности см. в документации 1.4.7 Динамические атрибуты класса"
    },
    {"Item","AST","Версия 1.1.0.0","",
"Версия 1.1.0.0",
"",
"@Синтаксис:
Версия 1.1.0.0
@Назначение:
- В делегат, добавлена возможность вызывать методы по строковым ключам. Подробности см. в 

документации
  глава 3.3 Класс Delegate рус. Делегат
- Исправлена ошибка вызова методов и свойств через контекст в текущем деструкторе.
- Исправлена ошибка при чтении и записи динамических свойств одного экземпляра класса в 

кострукции
  вида мойКласс.Свойство1 = мойКласс.Свойство2.
- Исправлена ошибка при передаче в метод неявного параметра в виде пустого значения, 

данный
параметр не записывался в список значений неявных параметров. Теперь этот параметр также 

пуст, но
имеет тип значения равный двум, т.е. пустая строка.
- Добавлен метод Get/Получить в класс Структура.
- Добавлен метод ExistProp/ЕстьСвойство в класс Структура.
- Добавлен класс DynaValue, глава 3.6. документации.
- Добавлена возможность сериализации/десериализации (сохранения/восстановления состояния) 

классов. 
  Подробности см. в документации глава 1.4.9.
- Добавлена новая директива препроцессора #curmeth 
  Подробности см. в документации глава 1.5
- Добавлена поддержка отладчика для модулей классов, подробней см. в документации
  1.6. Отладка классов 1C++"
    },
    {"Item","AST","Версия 1.1.0.1","",
"Версия 1.1.0.1",
"",
"@Синтаксис:
Версия 1.1.0.1
@Назначение:
- Исправлена ошибка вызова первого метода с неявными параметрами."
    },
    {"Item","AST","Версия 1.1.0.2","",
"Версия 1.1.0.2",
"",
"@Синтаксис:
Версия 1.1.0.2
@Назначение:
- Изменено имя метода базового функционала классов с ПриОткрытии/OnOpen на 

_ПриОткрытии/_OnOpen"
    },
    {"Item","AST","Версия 1.1.1.0","",
"Версия 1.1.1.0",
"",
"@Синтаксис:
Версия 1.1.1.0
@Назначение:
- Добавлен класс MetaInfoClasses. Позволяющий получать метаданные ВК 1С++ и формировать 

als-файл помощника. Подробное описание глава 3.7. документации"
    },
    {"Item","AST","Версия 1.1.1.1","",
"Версия 1.1.1.1",
"",
"@Синтаксис:
Версия 1.1.1.1
@Назначение:
- Исправлена ошибка, появлявшаяся при следующих условиях: 1С++ загружается c  включенным 
  режимом оптимизации, потом создается один или несколько экземпляров любых классов, 
  далее мы изменяем, режим оптимизации в положение - выключен, при удалении ранее созданных 
  классов 1С вылетала с ошибкой доступа к памяти.
- Исправлена ошибка, когда в параметры по умолчанию использовался символ ;, 
  например Строка Разделить(Строка Стр, Строка Разделитель = ;);, при загрузке 1С++ 
  выдавала ошибку об не найденной ).
- Исправлена ошибка, когда include расположена в конце файла 1С++ сообщала, что расширение 
  указано неправильно например: имяФайла.р.  
- Исправлена ошибка - экземпляр класса не удаляется из памяти при отсутствии на него активных ссылок, 
  когда ему заменили базовый класс, с помощью метода ЗаменитьЭксзБазовогоКласса функционала КОП.
- Устранено ограничение - нельзя отлаживать деструктор класса, он просто не вызывается. Экземпляр 
  отлаживаемого класса не удаляется из памяти.
- ВНИМАНИЕ! Изменения в механизме отладки модулей, в данной версии запрещено вызывать Форма.Закрыть(), 1С++
  автоматически сделает это при уничтожении отлаживаемого объекта, после вызова его деструктора.
  Процедура ПриОткрытии()
    Форма.Параметр._ПриОткрытии();
        //Форма.Закрыть(); - ОБЯЗАТЕЛЬНО УДАЛИТЬ ИЛИ ЗАКОМЕНТИРОВАТЬ ДАННУЮ СТРОКУ КОДА
  КонецПроцедуры"
    },
    {"Item","AST","Версия 1.1.1.3","",
"Версия 1.1.1.3",
"",
"@Синтаксис:
Версия 1.1.1.3
@Назначение:
- Добавлен новый метод в класс MetaInfoClasses: SetCurSettings/УстановитьТекУстановки
- В данной версии исправлена ошибка появившася в версии 1.1.1.1, а именно: при включенном режиме опимизации, и выключенным режиме отладки, происходила утечка памяти, при создании и удаленни экземпляров класса."
    },
    {"Item","AST","Версия 1.1.1.5","",
"Версия 1.1.1.5",
"",
"@Синтаксис:
Версия 1.1.1.5
@Назначение:
Версия 1.1.1.5
- Усреднена скорость вызова методов объектов 1С, таких как СписокЗначений, ТаблицаЗначений и т.п. находящихся в иерархии 1С++. Если пользовательский класс наследует от 1С объекта и не переопределяет его стандартные методы,  а вызов их происходит, через экземпляр производного класса, разница в скорости вызова колбется от +0.5% до +50% по сравнению с обычным вызовом, непосредственно через ссылку на 1С базовый объект. В тоже время чтение/запись,  свойств объекта через ссылку на пользовательский производный класс поизводиться несколько медленнее от 0.5%  до 1.2%. Версия 1.1.1.4
- Исправлена ошибка - метод ПолучитьБазовыйКласс/GetBaseClass не находил базовый класс Документ по имени
- Добавлена возможность в метод НазначитьБазовыйКласс/AssignBaseClass передавать не только строку, но и готовый  агрегатный объект"
    },
    {"Item","AST","Версия 1.2.0.0","",
"Версия 1.2.0.0",
"",
"@Синтаксис:
Версия 1.2.0.0
@Назначение:
Версия 1.2.0.0
- Добавлен 3.8. Класс DynaCrypt
  В звязи с объеденением ВК FromEx - Alex L. Fedorov aka АльФ добавлены слеующие классы:
- Добавлен 3.9. Класс ServiceFormEx / СервисРасшФорм
- Добавлен 3.10. Класс FormEx / РасширениеФормы
- Добавлен 3.11. Класс AttribEx / АтрибутФормы

- Добавлен раздел документации Разработчики"
    },
    {"Item","AST","Версия 1.2.0.1","",
"Версия 1.2.0.1",
"",
"@Синтаксис:
Версия 1.2.0.1
@Назначение:
Версия 1.2.0.1
- Исправлена работа отладчика при чтении свойств объекта пользовательского класса во время работы функции
  вычисления выражения отладчика.
- Добавлена возможность просматривать значения динамических свойств в отладчике, для этого
  необходимо определить функции _GetNDynamicProps / _ПолучитьКолвоДСвойств, _GetPropDynamicName / _ПолучитьИмяДСвойства
  семантику которых см. в разделе 1.4.7. Динамические атрибуты класса
- Добавлен метод ClearReposClasses / ОчиститьКлассыРепозитария в класс MetaInfoClasses"
    },
    {"Item","AST","Версия 1.2.0.2","",
"Версия 1.2.0.2",
"",
"@Синтаксис:
Версия 1.2.0.2
@Назначение:
Версия 1.2.0.2
- В связи с нестабильностью работы, метод по раскраске таблиц в различные цвета был
  отключен.
  
- Блиц опрос!
Если тебя интересна данная разработка, то поддержи ее развитие, ответив коротко на следующие вопросы:
1.      Твое имя (Ф.И.О. или Ф.И., или ник, или все вместе):
2.      Я скачиваю ВК 1С++: а) Чтобы была, вдруг пригодится; б) для изучения; в) из-за любопытства; г) использую в реальных проектах (Выбери вариант или напиши, пожалуйста, свой)?
3.      Среднее количество классов, которые ты создал:
4.      Используешь ли ты сторонние классы, других авторов (Д/Н):
5.      Как ты думаешь, стоит ли развивать 1С++ дальше (Д/Н):
6.      В связи со скорым выходом V8 хотел бы ты видеть 1С++ для новой платформы (Д/Н):
7.      Что по твоему не хватает в 1С++?
и отправь ответы на debbuger@yandex.ru
Спасибо за твое участие!"
    },
    {"Item","AST","Версия 1.2.0.3","",
"Версия 1.2.0.3",
"",
"@Синтаксис:
Версия 1.2.0.3
@Назначение:
- Благодаря стараниям Александра Орефкова наконец-то доработана модель формирования/обработки исключений. 
  Теперь возникающая динамическая ошибка в модуле исполняемого текущего кода класса распостраняется за 
  его пределы.
- Добавлен метод в функционал класса _ВыброситьИскл()/_Throw()
- Добавлен методы Throw()/ВыброситьИскл() и GetExeption()/ПолучитьИсключение() в класс ExecuteModule/ВыполняемыйМодуль
- Вернулась назад возможность раскраски таблиц, на этот раз исправленная."
    },
    {"Item","AST","Версия 1.5.0.0","",
"Версия 1.5.0.0",
"",
"@Синтаксис:
Версия 1.5.0.0
@Назначение:
- Теперь пути файлов реализации рассчитываются относительно расположения файла объявления,
  где они были определены.
- Добвавлены классы MetaDataWork, ODBCDatabase, ODBCRecordSet для работы с SQL - запросами."
    },
    {"Item","AST","Версия 1.5.0.1","",
"Версия 1.5.0.1",
"",
"@Синтаксис:
Версия 1.5.0.1
@Назначение:
- Добавлен метод ODBCRecordSet::ExeSQL_FromTV
- Убрана небольшая утечка памяти из класса ODBCRecordSet
- Добавлены метод ServiceFormEx::UnColourBrowse, ServiceFormEx::ActiveContext, ServiceFormEx::LoadModule,
  ServiceFormEx::UnLoadModule, ServiceFormEx::CallAsProcedure, ServiceFormEx::CallAsFunction, 
  ServiceFormEx::GetContextVar, ServiceFormEx::SetContextVar, ServiceFormEx::ExecuteInContext"
    },
    {"Item","AST","Версия 1.5.0.2","",
"Версия 1.5.0.2",
"",
"@Синтаксис:
Версия 1.5.0.2
@Назначение:
Версия 1.5.0.2
- Исправлена ошибка замены базового класса имевшего тип Регистры
- Исправлена ошибка возникающая при использовании препроцессорной директивы #elif
- Изменен механизм передачи параметрических параметров, через таблицу значений метода 
  ODBCRecordSet::ExeSQL_FromTV. Теперь тип преобразования получается из колонки Заголовок.
- Доб. новый параметр метода ODBCRecordSet::SetPropertyCursor - SQL_ATTR_CONCURRENCY
- Доб. методот MetaInfoClasses::ThisIsSQL_Ver
- Доб. методот MetaDataWork::GetEndOfPeriod
- Доб. методот MetaDataWork::GetEndOfPeriodForReg
- Доб. методот MetaDataWork::GetBegOfPeriod
- Доб. методот MetaDataWork::GetBegOfPeriodForReg
- Доб. методот MetaDataWork::GetDateTimeIDDOC"
    },
    {"Item","AST","Версия 1.5.0.3","",
"Версия 1.5.0.3",
"",
"@Синтаксис:
Версия 1.5.0.3
@Назначение:
Версия 1.5.0.3
- Исправлена ошибка - закрытие последнего открытого курсора при создании нового курсора.
- Доб. методот MetaDataWork::GetStringInVL
- Доб. методот MetaDataWork::GetStrFromDate
- Доб. свойство ODBCRecordSet::md
- Работа препроцессора распостраненна на все модули 1С, кроме модуля глобального модуля и
  модулей внешних отчетов.
"
    },
    {"Item","AST","Версия 1.7.0.0","",
"Версия 1.7.0.0",
"",
"- Исправлена ошибка в методе MetaDataWork::GetDateTimeIDDOC, неверно формировалась строка позиции
- Встроена компонента TurboBL Александра Орефкова
- Встроент SQL процессор метаимен. См. документацию глава 4. Работа с SQL и 
  Приложение А. Спецификация метаимен и параметров в запросах
- Изменены ссылки в разделе № 6 документации.
- Обновлена ВК FormEx
"
    },
    {"Item","AST","Версия 1.7.0.1","",
"Версия 1.7.0.1",
"",
"- Восстановлен код относящийся к функционалу _GetCode/_ПолучитьКод, отсутствующий в версии 1.7.0.0
"
    },
    {"Item","AST","Версия 1.7.0.2","",
"Версия 1.7.0.2",
"",
"- Добавлена возможность хранить модули КОП в дереве текущей конфигурации - обработках.
  Имя источника класса в его объявлении должно содержать идентификатор обработки как оно 
  указано в конфигурации и заканчиваться ключевым окончанием @MD (Внимание, соблюдайте регистр букв).
  Окончание @MD можно также использовать в директиве include препроцессора.
  Если в каталоге БД не найден файл определения классов defcls.prm, то ВК пробует найти обработку в 
  текущей конфигурации с таким же именем (defcls), откуда читает текст модуля и принимает его за определения 
  классов.
  Пример: класс ТестРепорт = Тест1@MD {};, где обработка в которой храниться текст КОП называется Тест1.
"
    },
    {"Item","AST","Версия 1.7.0.3","",
"Версия 1.7.0.3",
"",
"- Добавлены методы в класс MetaDataWork::ProcessMetaSQL, MetaDataWork::SetTextParam
- Испр. ошибка в методе GetBaseClass/ReplaceInstBaseClasses
"
    },
    {"Item","AST","Версия 1.7.0.4","",
"Версия 1.7.0.4",
"",
"Версия 1.7.0.4
- Испр. ошибка возникавшая при отсутсвии файла описания классов.
- Доб. возможность отладки классов, модули, которых храняться в обработках
  конфигурации. Принцип работы такой же как и у модулей классов хранящихся во 
  внешних отчетах.
- Обновлена ВК FormEx
"
    },
    {"Item","AST","Версия 1.7.0.5","",
"Версия 1.7.0.5",
"",
"Версия 1.7.0.5
- Испр. ошибка, возникавшая в методе MetaDataWork::ProcessMetaSQL при возникновении ошибки обработки
  метапроцессора SQL.
"
    },
    {"Item","AST","Версия 1.7.1.5","",
"Версия 1.7.1.5",
"",
"- Обнаружена ошибка при попытке загрузить модуль класса из внешнего отчета возникала ошибка error catch 
& или 
  V75.zlibEngine Error:null pointer. Это связано с работой червя Blaster и его разновидностей, который 
  разрушал работу механизма RPC Windows и многое другое, в том числе нарушал работу 1С++. 
  Для исправления необходимо скачать патч для Win2000 Server, который расположен по адресу: 
  http://www.microsoft.com/downloads/details.aspx?FamilyId=C8B8A846-F541-4C15-8C9F-220354449117&displaylang=en
- исправлена ошибка с неоткрытием окна выбора при многоуровневом выборе из списка в виде дерева;
- исправлена работа с картинками на закладках;
- при выборе значения в виде меню над таблицей (или многострочной частью) оно теперь корректно 
подстраивается к текущей ячейки (при указании соответсвующего флага и активности таблицы);
- добавлено получение/установка координат для многострочной части документа;
- добавлена установка некоторых флагов на странице свойств компоненты;
- объект СервисРасшФормы: добавлен метод ПоказыватьИндикаторКлавиатуры(...) для отображения раскладки 
клавиатуры и текущего времени в статусной панели;
- объект СервисРасшФормы: добавлен метод УстановитьОбои(...) для установки картинки в качестве фона на 
главном окне;
- объект РасширениеФормы: добавлен метод Обновить() для перерисовки формы без обновления текстовых 
реквизитов;
- объект РасширениеФормы: добавлен метод РаскрашиватьТаблицу(...) для включения таблицы в частичную 
раскраску;
- объект РасширениеФормы: добавлен метод ПрисоединитьФорму(...) для совмещения двух форм в одном окне;
- объект РасширениеФормы: добавлен метод ПоложениеКолонкиТаблицы(..) для изменения положения колонки 
таблицы значений на форме (новая колонка,на следующей строке,в той же колонке);
"
    },
    {"Item","AST","Версия 1.7.1.6","",
"Версия 1.7.1.6",
"",
"- Исправлена ошибка:
  В системе описан класс ПроверкаСпискаПараметров:
  defcls
  CODE  
  класс ПроверкаСпискаПараметров = ПроверкаСпискаПараметров.ert
  {
      СписокЗначений Проверка(...);
  }
 
  ПроверкаСпискаПараметров.ert
  CODE  
  Функция Проверка() Экспорт
      Возврат(GetThis(Контекст).ПолучитьСписокПараметров(Проверка));
  КонецФункции
  В глобальном модуле создается экземпляр этого класса:
  CODE  
  Перем глПроверка экспорт;
  глПроверка = СоздатьОбъект(); 
  В клиентском коде вызываем метод:
  CODE  
  сообщить(глПроверка.Проверка(параметр));
  На что система сообщает: СписокЗначений.
  Затем, из другого метода опять вызываем этот же метод, но с любой другой сигнатурой, 
  например, вообще без параметров:
  CODE  
  сообщить(глПроверка.Проверка());
  В результате имеем ошибку: 
  .
- Увеличена скорость загрузки модулей классов из *.ert файлов.
"
    },
    {"Item","AST","Версия 1.7.1.7","",
"Версия 1.7.1.7",
"",
"- Исправлена ошибка версий 1.7.1.5,1.7.1.6  не вызывалась предопределенная процедура 
ПриИзмененииРазмераОкна()
"
    },
    {"Item","AST","Версия 1.7.1.8","",
"Версия 1.7.1.8",
"",
"- УложитьСписокОбъектов() мог уложить в таблицу не все идентификаторы удовлетворяющие условию.
  Исправлено: укладывает все.

- ПолучитьРезультатыВ_ТЗ(): если выборка пуста и параметр инициализации=1, то ТЗ не инициализируется.
  Исправлено: в этом случае таблица инициализируется, т.е. колонки создаются.

- Не работает отладка в Выполнить().
  Исправлено: работает.

- СтрокОбработано() возвращает значение от предыдущего запроса, если последний не обработал ни одной
  строки.
  Исправлено: в этом случае возвращается 0.

- Виртуальное значение $ПоследнееЗначение - ошибка в подзапросе при указании времени и/или
  идентификатора документа.
  Исправлено: запрос поправлен.

- Подготовить(): если имеет место Meta name parser error, то функция возвращает не 0, а значение
  неопределенного типа.
  Исправлено: возвращает 0.

- По документации Выполнить() - функция.
  Исправлено: теперь - функция, при ошибке в запросе не формируется исключение, а возвращается 0/1,
  аналогично функции Открыть().

- ВТ оборотов: при периодичности Документ и установленых одном из флажков Быстрая обработка движений 
или
  Отбор движений в запросе неоправданно участвует _1sjourn.
  Исправлено: в этом случае _1sjourn не участвует в запросе.

- УложитьСписокОбъектов: при передаче первым параметром группы справочника происходила ошибка.
  Исправлено: ошибка не происходит, в таблицу укладываются подчиненые элементы.

- Снято ограничение на обработку препроцессором модулей внешних отчетов

- Методы ЗагрузитьМодуль и ВыгрузитьМодуль объекта СервисРасшФормы объявлены устаревшими и в 
следующих
  версиях могут быть удалены.
"
    },
    {"Item","AST","Версия 1.7.1.9","",
"Версия 1.7.1.9",
"",
"- Исправлена ошибка: неожиданное окончание работы 1С в некоторых случаях, вывода отчета,
  даже если не использовался функционал ВК.
"
    },
    {"Item","AST","Версия 1.7.2.0","",
"Версия 1.7.2.0",
"",
"- Сделано объеденение с компонентой FormEx 1.9:
  * полностью переписан функционал раскраски таблиц;
  * в функционал управляющей строки раскраски добавлен мактос INDENT[...], позволяющий задавать смещение 
начала раскраски от текущей колонки;
  * имена макросов управляющей строки раскраски теперь регистронезависимы;
  * полностью переписан функционал присоединения формы;
  * объект РасширениеФормы: добавлен метод ОтсоединитьФорму(...) для отсоединения присоединенной 
формы;
  * объект РасширениеФормы: добавлена возможность обращения к атрибутам формы как к атрибутам объекта;
  * объект РасширениеФормы: добавлен метод УстановитьАвтоширинуВТаблице(...) для установки/сброса флага 
автоширины колонок в таблицах;
  * объект СервисРасшФормы: добавлен метод ВысотаСтрокиТаблицы(...) для вычисления высоты строк в 
объекте Таблица;
  * объект СервисРасшФормы: добавлен метод ПрятатьТаблицу(...) для задания невидимости открытому окну 
объекта Таблица;
  * объект АтрибутФормы: атрибут Видимость теперь работает и для многострочной части формы;
  * в предопределенные процедуры добавлен флаг стандартной обработки, который позволяет отменить 
обработку события движком 1С;
  * исправлены некоторые мелкие глюки;

- Исправлена ошибка: после повторного открытия любой формы объекта 1С не вызывались обработчики 
событий.
- Внимание: для использования событий во внешнем отчете необходимо использовать методы ЗагрузитьМодуль 
(в предопределенной процедуре формы ПриОткрытии()) 
  и ВыгрузитьМодуль (в предопределенной процедуре формы ПриЗакрытии()) объекта СервисРасшФормы.
"
    },
    },
 {"Folder","AST","Приложение А. Спецификация метаимен и параметров в запросах","",
    {"Item","AST","Описание условных обозначений","",
"",
"",
"Идентификаторы 1С, как они заданы в конфигураторе
·       Константа - идентификатор константы;
·       Справочник - идентификатор справочника;
·       Документ - идентификатор документа;
·       ВидПеречисления - идентификатор вида перечисления; 
·       Регистр - идентификатор регистра;
·       ЖурналДокументов - идентификатор журнала документов;
·       Последовательность - идентификатор последовательности документов;
·       ЖурналРасчетов - идентификатор журнала расчетов;
·       ГрафаОтбора - идентификатор графы отбора;
·       Реквизит - идентификатор реквизита справочника, регистра или журнала 
расчетов;
·       РеквизитШапки - идентификатор реквизита шапки документа;
·       РеквизитТабличнойЧасти - идентификатор реквизита табличной части 
документа;
·       Измерение - идентификатор измерения регистра;
·       Ресурс - идентификатор ресурса регистра;
·       ПериодическийРеквизит - идентификатор периодического реквизита;
·       ОбщийРеквизит - идентификатор общего реквизита;
·       ВидРасчета - идентификатор вида расчета;
·       ГрафаОтбораЖР - идентификатор графы отбора журнала расчетов;
·       Календарь - идентификатор календаря;
"
    },
    {"Item","AST","Специальные обозначения","",
"",
"",
"Специальные обозначения
·       ХХХХ - внутренний идентификатор объекта метаданных (десятичное 
представление); 
·       ZZZZ - внутренний идентификатор объекта метаданных 
(тридцатишестиричное представление);
·       Alias - псевдоним таблицы в SQL запросе;
·       ИмяПараметра - имя параметра.
Для обозначения начала метаимени в тексте запроса используется символ “$”.
Для обозначения начала имени текстового параметра в тексте запроса используется 
символ “:”.
Для обозначения начала имени SQL параметра в тексте запроса используется символ 
“?”.
Метаимена транслируются только в теле запроса, т.е. не транслируются в 
комментариях, текстовых литералах. Метаимена также не транслируются в 
квадратных скобках [ … ] (расширенных идентификаторах MS SQL).
Замечание! На текст запроса накладывается дополнительное ограничение: 
псевдонимы таблиц, имена которых транслируются из метаимен, не должны 
повторяться, иначе трансляция метаимени полей через псевдоним таблицы 
может быть неверной.
"
    },
    {"Item","AST","Спецификация метаимен","",
"",
"",
"Получение имен таблиц
Получение имени таблицы справочника
${Справочник|Reference}.<Справочник> = scXXXX
Получение имени таблицы шапок документов
${Документ|Document}.<Документ> = dhXXXX
Получение имени таблицы строк документов
${ДокументСтроки|DocumentStrings}.<Документ> = dtXXXX
Получение имени таблицы движений регистра
${Регистр|Register}.<Регистр> = raXXXX
Получение имени таблицы итогов (остатков/оборотов) регистра
${РегистрИтоги|RegisterTotals}.<Регистр> = rgXXXX
Получение имени таблицы журнала расчетов
${ЖурналРасчетов|CalcJournal}.<ЖурналРасчетов> = cjXXXX
Получение имен полей
Получение имени поля таблицы справочника
${Справочник|Reference}.<Справочник>.<Реквизит> = spХХХХ
Получение имени поля таблицы шапок документов
${Документ|Document}.<Документ>.<РеквизитШапки> = spХХХХ
Получение имени поля таблицы строк документов
${ДокументСтроки|DocumentStrings}.<Документ>.
<РеквизитТабличнойЧасти> = spХХХХ
Получение имени поля таблицы движений регистра
${Регистр|Register}.<Регистр>.<Измерение | Ресурс | 
Реквизит> = spХХХХ
Получение имени поля таблицы итогов (остатков/оборотов) регистра
${РегистрИтоги|RegisterTotals}.<Регистр>.<Измерение | 
Ресурс> = spХХХХ
Получение имени поля по псевдониму таблицы
$<Alias>.<Реквизит | РеквизитШапки | 
РеквизитТабличнойЧасти | Измерение | Ресурс> = 
<Alias>.spХХХХ
Получение имени поля общего реквизита
${ОбщийРеквизит|CommonProperty}.<ОбщийРеквизит> = spХХХХ
Получение имени поля флага движений по регистру
${ФлагРегистра|RegisterFlag}.<Регистр> = rfХХХХ
Получение имени поля последовательности
${Последовательность|Sequence}.<Последовательность> = 
dsХХХХ
Получение имени поля реквизита журнала расчетов
${ЖурналРасчетов|CalcJournal}.<ЖурналРасчетов>.<Реквизит> 
= spXXXX
Получение имени поля графы отбора журнала расчетов
${ГрафаЖурналаРасчетов|ColumnCalcJournal}.
<ЖурналРасчетов>.<ГрафаОтбораЖР> = ffXXXX
Получение внутренних идентификаторов
Идентификатор константы
${Константа|Constant}.<Константа> = XXXX
Идентификатор вида справочника
${ВидСправочника36|ReferenceKind36}.<Справочник>
char(4): = 'ZZZZ'
Идентификатор вида документа
${ВидДокумента|DocumentKind}.<Документ>
Зависит от формата ИБ:
SQL - литерал типа int: = XXXX
DBF: литерал типа char(4): = 'ZZZZ'

${ВидДокумента36|DocumentKind36}.<Документ>
char(4): = 'ZZZZ'
Идентификатор вида перечисления
${ВидПеречисления36|EnumKind36}.<ВидПеречисления>
char(4): = 'ZZZZ'
Идентификатор периодического реквизита
${ИсторияРеквизита|PropertyHistory}.<Справочник>.
<ПериодическийРеквизит> = ХХХХ
Идентификатор журнала документов
${ЖурналДокументов|DocsJournal}.<ЖурналДокументов> = ХХХХ
Идентификатор графы отбора
${ГрафаОтбора|SelectionColumn}.<ГрафыОтбора> = ХХХХ
Идентификатор календаря
${Календарь|Calendar}.<Календарь> = ХХХХ
Идентификатор праздников
${Праздники|Holidays} = ХХХХ
Идентификатор журнала расчетов
${ВидЖурналаРасчетов|CalcJournalKind}.<ЖурналРасчетов> = 
XXXX
Идентификатор вида расчета
${ВидРасчета|Algorithm}.<ВидРасчета>
Зависит от формата ИБ.
SQL: литерал типа int: = XXXX
DBF: литерал типа char(4): = 'ZZZZ'
Идентификаторы пустых значений
${ПустойИД|EmptyID} = '     0   '
${ПустойИД13|EmptyID13} = '   0     0   '
"
    },
 {"Folder","AST","Виртуальные таблицы","Виртуальные таблицы",
    {"Item","AST","РегистрОстатки","RegisterRests",
"$РегистрОстатки.<?>(<?>,
        <?>,
        <?>,
        <?>,
        <?>
)",
"$RegisterRests.<?>(<?>,
        <?>,
        <?>,
        <?>,
        <?>
)",
"Виртуальные таблицы поддерживаются только для SQL формата ИБ.
Виртуальная таблица остатков
@Синтаксис:
$РегистрОстатки.<ИмяРегистра>([<ГраницаРасчета>] [, 
<Соединение>] [,<Условие>] [,<Измерение>] [,<Ресурс>]) [as 
<Алиас>]

Используется для получения остатков. Определена только для регистров остатков.

@Параметры:
<ГраницаРасчета>
Тип: значение.
Строка, представляющая период или момент времени во внутреннем формате 1С.
Если передан период времени (дата или позиция документа), остатки 
рассчитываются на
начало периода. Для того чтобы рассчитать остатки на конец периода необходимо
передавать момент времени. Для этого можно воспользоваться вторым 
модификатором типа Дата, что соответствует моменту времени конца этой даты. Для 
формирования моментов времени также можно воспользоваться позицией 
документа: процедурой СформироватьПозициюДокумента() синтаксис 1, указывая не 
нулевой ФлагСмещения; или СформироватьПозициюДокумента() синтаксис 2.Если 
граница расчета больше ТА, то будут получены остатки по ТА;
По умолчанию остатки на точку актуальности.

<Соединение>
Тип: конструкция типа join. На языке SQL можно описать дополнительные 
соединения с таблицами, которые могут быть необходимы для формирования 
условий в следующем параметре. Можно оперировать полями измерений регистра, 
обращаясь к ним по идентификатору 1С.
По умолчанию отсутствует.

<Условие>
Тип: конструкция типа where. На языке SQL можно описать условие для ограничения 
выборки. Можно оперировать полями измерений регистра, обращаясь к ним по 
идентификатору 1С, а также полями таблиц, соединения с которыми были описаны 
в предыдущем параметре.
По умолчанию отсутствует.

<Измерение>
Тип: конструкция типа список идентификаторов. Указывается список измерений по 
которым нужно рассчитать остатки.
По умолчанию по всем.

<Ресурс>
Тип: конструкция типа список идентификаторов. Указывается список ресурсов 
которые нужно рассчитать.
По умолчанию по всем.

@Поля:
<ИмяИзмерения>
имена измерений указанных к расчету;
<ИмяРесурса>Остаток
имена ресурсов с добавлением слова Остаток указанных к расчету.

@Пример:
Имеем регистр:
        Имя: Взаиморасчеты
        Измерения: Фирма, Контрагент, Договор, РасчДокумент
        Ресурсы: Сумма, НДС, НП, Себестоимость
Задача: рассчитать остатки по измерениям Контрагент, РасчДокумент в ресурсе 
Сумма, при условии что вид контрагента - Поставщик, и только по фирмам которые 
платят НДС.
Текст запроса для решения:
select *
from $РегистрОстатки.Взаиморасчеты(
        :ДатаРасчета,
        inner join $Справочник.Контрагенты as СпрКонтрагенты 
on            
СпрКонтрагенты.id = Контрагент
        inner join $Справочник.Фирмы as СпрФирмы on 
СпрФирмы.id = Фирма,
$СпрКонтрагенты.ВидКонтрагента = :ВидПоставщик and 
$СпрФирмы.ВидФирмы 
= :ВидПлатитНДС,
        (Контрагент, РасчДокумент),
        Сумма
) as ОстаткиПоРасчетам

@Оптимизация расчета:
+ при получении остатков по ТА, используется только таблица итогов;
+ при получении остатков по дату конца периода сохранения остатков,
        используется только таблица итогов;
+ при получении остатков на дату начала периода сохранения остатков,
        используется только таблица итогов;
+ при получении остатков на дату начала или конца периода сохранения остатков,
и расчет идет по всем измерениям, используется только таблица итогов без 
группирования (без предложения group by в запросе);
+ при получении остатков на или по дату близкую к концу текущего периода
        сохранения остатков, используются остатки на конец текущего периода и
        обороты от границы расчета до конца текущего периода (обратный расчет);
+ при получении остатков на или по дату в актуальном периоде сохранения остатков
        близкую к дате ТА, используются актуальные остатки и обороты от границы 
расчета по ТА (обратный расчет).
"
    },
    {"Item","AST","РегистрОбороты","RegisterTurnovers",
"$РегистрОбороты.<?>(<?>, <?>, <?>,
        <?>,
        <?>,
        <?>,
        <?>
)",
"$RegisterTurnovers.<?>(<?>, <?>, <?>,
        <?>,
        <?>,
        <?>,
        <?>
)",
"Виртуальная таблица оборотов
@Синтаксис:
$РегистрОбороты.<ИмяРегистра>([<НачалоПериода>][, 
<КонецПериода>][, <Периодичность>][, <Соединение>][,
<Условие>][,<Измерение>][,<Ресурс>]) [as <Алиас>]

Используется для получения оборотов.

@Параметры:
<НачалоПериода>
Тип: значение.
Строка, представляющая период или момент времени во внутреннем формате 1С.
По умолчанию начало ведения учета.

<КонецПериода>
Тип: значение.
Строка, представляющая период или момент времени во внутреннем формате 1С. 
Если передан период времени (дата, позиция документа), он в расчет не включается. 
Для того чтобы он включался в расчет нужно воспользоваться модификатором, или 
предварительно сформировать момент времени (См. 
СформироватьПозициюДокумента()).
По умолчанию точка актуальности.

<Периодичность>
Тип: конструкция типа ключевое слово.
Указывается дополнительный разворот итогов по периодичности. Задается один из 
следующих вариантов:
Период (Period) - только за период (не разворачивать);
Документ (Document) - разворачивать по документу;
День (Day) - разворачивать по дням;
Неделя (Week) - разворачивать по неделям;
Месяц (Month) - разворачивать по месяцам;
Квартал (Quarter) - разворачивать по кварталам;
Год (Year) - разворачивать по годам.
По умолчанию Период.

<Соединение>
Тип: конструкция типа join. На языке SQL можно описать дополнительные 
соединения с таблицами, которые могут быть необходимы для формирования 
условий в следующем параметре. Можно оперировать полями измерений и 
реквизитов регистра, обращаясь к ним по идентификатору 1С.
По умолчанию отсутствует.

<Условие>
Тип: конструкция типа where. На языке SQL можно описать условие для ограничения 
выборки. Можно оперировать полями измерений  и реквизитов регистра, обращаясь 
к ним по идентификатору 1С, а также полями таблиц, соединения с которыми были 
описаны в предыдущем параметре.
По умолчанию отсутствует.

<Измерение>
Тип: конструкция типа список идентификаторов. Указывается список измерений по 
которым нужно рассчитать обороты.
По умолчанию по всем.

<Ресурс>
Тип: конструкция типа список идентификаторов. Указывается список ресурсов 
которые нужно рассчитать.
По умолчанию по всем.

@Поля:
<ИмяИзмерения>
имена измерений указанных к расчету; тип определяется типом измерения регистра;
<ИмяРесурса>Приход
имена ресурсов с добавлением слова Приход указанных к расчету; тип определяется 
типом ресурса регистра; существует только для регистра остатков;
<ИмяРесурса>Расход
имена ресурсов с добавлением слова Расход указанных к расчету; тип определяется 
типом ресурса регистра; существует только для регистра остатков;
<ИмяРесурса>Оборот
имена ресурсов с добавлением слова Оборот указанных к расчету; тип определяется 
типом ресурса регистра; существует только для регистра оборотов;
<Период>
тип datetime; дата начала периода по которому происходит разворот оборотов; 
существует только в том случае если указана периодичность День, Неделя, Месяц, 
Квартал, Год;
<ПозицияДокумента>
тип char(23); строка в формате date_time_iddoc (8+6+9); существует только в том 
случае если указана периодичность Документ;
<ВидДокумента>
тип int; идентификатор вида документа; существует только в том случае если указана 
периодичность Документ.

@Оптимизация расчета:
- существует только для оборотного регистра;
+ при получении оборотов за период в который входят один или несколько 
периодов сохранения оборотов, используется таблица итогов;
+ если период получения оборотов состоит только из периодов сохранения 
оборотов, используется только таблица итогов;
+ если заданная периодичность расчета позволяет использовать таблицу итогов, она 
используется;
- если в соединении или условии были использованы реквизиты регистра 
оптимизация невозможна.
"
    },
    {"Item","AST","РегистрОстаткиОбороты","RegisterRestsTurnovers",
"$РегистрОстаткиОбороты.<?>(<?>, <?>, <?>,
        <?>,
        <?>,
        <?>,
        <?>,
        <?>
)",
"$RegisterRestsTurnovers.<?>(<?>, <?>, <?>,
        <?>,
        <?>,
        <?>,
        <?>,
        <?>
)",
"Виртуальная таблица остатков и оборотов
@Синтаксис:
$РегистрОстаткиОбороты.<ИмяРегистра>([<НачалоПериода>][, 
<КонецПериода>][, <Периодичность>][,<МетодДополнения>][,
<Соединение>][,<Условие>]
[,<Измерение>][,<Ресурс>]) [as <Алиас>]

Используется для получения остатков и оборотов. Определена только для регистра 
остатков.

@Параметры:
<НачалоПериода>
Тип: значение.
Строка, представляющая период или момент времени во внутреннем формате 1С.
По умолчанию начало ведения учета.

<КонецПериода>
Тип: значение.
Строка, представляющая период или момент времени во внутреннем формате 1С. 
Если передан период времени (дата, позиция документа), он в расчет не включается. 
Для того чтобы он включался в расчет нужно воспользоваться модификатором, или 
предварительно сформировать момент времени (См. 
СформироватьПозициюДокумента()).
По умолчанию точка актуальности.

<Периодичность>
Тип: конструкция типа ключевое слово.
Указывается дополнительный разворот итогов по периодичности. Задается один из 
следующих вариантов:
Период (Period) - только за период (не разворачивать);
Документ (Document) - разворачивать по документу;
День (Day) - разворачивать по дням;
Неделя (Week) - разворачивать по неделям;
Месяц (Month) - разворачивать по месяцам;
Квартал (Quarter) - разворачивать по кварталам;
Год (Year) - разворачивать по годам.
По умолчанию Период.

<МетодДополнения>
Тип: конструкция типа ключевое слово.
Имеет смысл только когда используется разворот по периодам.
Задается один из следующих вариантов:
Движения (Actions) - в таблицу включаются обороты по каждому периоду движений, 
и текущие остатки, только по тем комбинациям измерений, по которым были 
движения в период расчета;
ДвиженияИГраницыПериода (ActionsAndPeriodBoundaries) - в таблицу включаются 
обороты по каждому периоду движений, и текущие остатки; а также таблица 
дополняется записями о ненулевых остатках на начало и/или конец на границы 
периода расчета.
 
<Соединение>
Тип: конструкция типа join. На языке SQL можно описать дополнительные 
соединения с таблицами, которые могут быть необходимы для формирования 
условий в следующем параметре. Можно оперировать полями измерений регистра, 
обращаясь к ним по идентификатору 1С.
По умолчанию отсутствует.

<Условие>
Тип: конструкция типа where. На языке SQL можно описать условие для ограничения 
выборки. Можно оперировать полями измерений регистра, обращаясь к ним по 
идентификатору 1С, а также полями таблиц, соединения с которыми были описаны 
в предыдущем параметре.
По умолчанию отсутствует.

<Измерение>
Тип: конструкция типа список идентификаторов. Указывается список измерений по 
которым нужно рассчитать остатки и обороты.
По умолчанию по всем.

<Ресурс>
Тип: конструкция типа список идентификаторов. Указывается список ресурсов 
которые нужно рассчитать.
По умолчанию по всем.

@Поля:
<ИмяИзмерения>
имена измерений указанных к расчету; тип определяется типом измерения регистра;
<ИмяРесурса>НачальныйОстаток
имена ресурсов с добавлением слова НачальныйОстаток указанных к расчету; тип 
определяется типом ресурса регистра;
<ИмяРесурса>Приход
имена ресурсов с добавлением слова Приход указанных к расчету; тип определяется 
типом ресурса регистра;
<ИмяРесурса>Расход
имена ресурсов с добавлением слова Расход указанных к расчету; тип определяется 
типом ресурса регистра;
<ИмяРесурса>КонечныйОстаток
имена ресурсов с добавлением слова НачальныйОстаток указанных к расчету; тип 
определяется типом ресурса регистра;
<Период>
тип datetime; дата начала периода по которому происходит разворот оборотов; 
существует только в том случае если указана периодичность День, Неделя, Месяц, 
Квартал, Год;
<ПозицияДокумента>
тип char(23); строка в формате date_time_iddoc (8+6+9); существует только в том 
случае если указана периодичность Документ;
<ВидДокумента>
тип int; идентификатор вида документа; существует только в том случае если указана 
периодичность Документ.

@Оптимизация расчета:
+ по таблицам итогов и движений рассчитывается всегда только один из остатков, 
другой вычисляется из оборотов при агрегировании;
+ рассчитывается тот остаток (начальный конечный), который получить легче, 
исходя из оптимизации расчета остатков См. выше описание виртуальной таблицы 
остатков;
"
    },
    {"Item","AST","Замечание!","Замечание!",
"",
"",
"Замечание! Порядок следования записей во всех виртуальных таблицах никак 
не определяется настоящей спецификацией, автор настоятельно рекомендует 
не использовать существующий порядок записей, а всегда в запросе 
использовать предложение для упорядочивания (order by).
"
    },
    },
 {"Folder","AST","Виртуальные значения","",
    {"Item","AST","ПоследнееЗначение","LastValue",
"$ПоследнееЗначение.<?>.<?>(<?>, <?>, <?>, <?>)",
"$LastValue.<?>.<?>(<?>, <?>, <?>, <?>)",
"Виртуальные значения поддерживаются только для SQL формата ИБ.
Получение наиболее позднего периодического значения
@Синтаксис:
$ПоследнееЗначение.<ИмяСправочника >| Константа.<ИмяРеквизита | 
ИмяКонстанты>(<ИдОбъекта>, <Дата>[, <Время>[, <ИДДокумента>]])
Позволяет получить последнее значение на указанную дату.

@Параметры:
<ИдОбъекта>
Тип конструкция типа выражение MS T-SQL; внутренний идентификатор элемента 
справочника или 0 для константы.
<Дата>
Тип конструкция типа выражение MS T-SQL; дата на которую нужно получить 
последнее значение.
<Время>
Тип конструкция типа выражение MS T-SQL; время на которое нужно получить 
последнее значение.
<ИДДокумента>
Тип конструкция типа выражение MS T-SQL; идентификатор документа на позицию 
которого нужно получить последнее значение.
"
    },
    {"Item","AST","НачалоПериода","BeginOfPeriod",
"$НачалоПериода.<?>(<?>,<?>)",
"$BeginOfPeriod.<?>(<?>,<?>)",
"Получение начала периода
@Синтаксис:
$НачалоПериода.<Период>(<ИсходнаяДата>[,<ТипПредставления>])
Позволяет получить значение типа datetime соответствующее началу периода 
<Период>.
<Период> - ключевое слово:
День (Day);
Неделя (Week);
Месяц (Month);
Квартал (Quarter);
Год (Year).

@Параметры:
<ИсходнаяДата>
Тип: конструкция типа выражение MS T-SQL; дата по которой определять период.
<ТипПредставления>
Тип: конструкция типа ключевое слово; представление даты в первом параметре:
Строка - char(8).
Дата - datetime.
По умолчанию Строка.
"
    },
    },
    {"Item","AST","Спецификация параметров","",
"",
"",
"Существует два вида параметров: текстовые и SQL параметры.
Текстовые параметры
Синтаксис:
:<ИмяПараметра> [<Модификатор>]

Текстовые параметры преобразуются в литералы (константы MS SQL). Текстовые 
параметры  могут повторяться в тескте запроса (т.е. будет использовано одно и то же 
значение), причем они могут быть использованы в разных местах запроса с разными 
модификаторами типа.
SQL параметры
Синтаксис:
:[<ИмяПараметра>] [<Модификатор>]

SQL параметры в тексте запроса преобразуются в символ «?» (символ подстановки). 
Имя параметра может быть либо пустым (т. е. вообще не указано (для обратной 
совместимости)), либо должно быть уникальным на запрос.

<Модификатор>
В общем случае тип значения параметра определяется типом значения 1С 
переданного при установке параметра, и в общем же случае этого недостаточно, 
поэтому существует возможность указать модификатор типа 1С. Для краткости: 
модификатор.
"
    },
    {"Item","AST","Правила обозначения модификаторов","",
"",
"",
"В тексте запроса модификаторы обозначаются символами “~” или “*” после имени 
параметра. Количество символов “~” после имени параметра определяет номер 
модификатора. Если после имени параметра не указан модификатор, то номер 
модификатора равен 0. Так как типом «Неопределенный» (char(23)) можно выразить 
любой тип 1С, для этого существует специальный модификатор, обозначаемый 
символом “*”, который определен для любого передаваемого типа 1С. Его номер 20.
Модификаторы определены для следующих типов 1С:
Строка
0: char() - строка как есть;
1: char(23) - должна быть передана позиция документа, из которой будет 
сформирована строка в формате date_time_iddoc;
Дата
0: char(8) - каноническое представление даты;
1: char(9) - каноническое представление даты + символ “Z” (используется для 
обозначения момента времени конца этой даты);
2: datetime.
Агрегатные типы (Перечисление, Справочник, Документ, ВидРасчета, Счет)
        0: char(9) - внутренний идентификатор объекта (короткая строка 6+3);
        1: char(13) - внутренний идентификатор объекта с видом (длинная строка 4+6
+3);
        2: char(15) - внутренний идентификатор объекта с видом и типом (2+4+6+3) 
(на самом деле такой тип нигде в 1С не используется, модификатор существует 
исключительно для обратной совместимости);
ВидРасчета
Кроме 0 и 1, которые работают как для всех агрегатных типов, 2-й определен особо:
2: Зависит от формата ИБ.
SQL: int - идентификатор вида расчета;
DBF: char(4) - 36-й идентификатор вида расчета;

Примеры:

Передано значение типа число
:ФлагУчастияВРасчетах = 1
:ФлагУчастияВРасчетах * = 'N                     1'

Передано значение типа дата
:ДатаНачала = '20030613'
:ДатаКонца ~ = '20030613Z'
:ДатаКонца ~~ = {d '2003-06-13'}

Передано значение типа Справочник.Контрагенты
:Контрагент = '    H6   '
:Контрагент ~ = '  1W    H6   '
:Контрагент * = 'B1  1W    H6           '
"
    },
    {"Item","AST","Типизация колонок типами 1С в тексте запроса.","Типизация колонок типами 1С в тексте запроса.",
"",
"",
"Для получения в наборе данных агрегатных типов 1С, возможна типизация колонок 
в тексте запроса. Для этого необходимо использовать специальный типизирующий 
псевдоним (алиас) колонки.
Формат типизирующего псевдонима
[<ИмяПоля> $<Тип1С>]
ИмяПоля - имя, которое будет доступно для обращения к полю методами этого 
класса.
Тип1С - строка, представляющая тип 1С, который будет назначен полю, в формате 
применяющемся в методе SetTypeColumn1C.
Спецификация типизирующих имен
Типизирующее имя        Допустимые SQL типы в наборе 
данных  
Строка  Любой   
Дата    Любой   
Число   Любой   
{Справочник|Reference}  Char(13)        
{Справочник|Reference}.<Справочник>     Char(9) 
{Документ|Document}     Char(13) Char(9) - Идентификатор 
объекта, кроме того, в наборе данных должна находиться колонка с именем 
составленным из имени этой колонки и суффикса {_вид|_kind} (чувствительно к 
регистру), в которой должны содержаться идентификаторы видов документов. Тип 
колонки SQL: Int, DBF: Char(4)  
{Документ|Document}.<Документ>  Char(9) 
{Перечисление|Enum}     Char(13)        
{Перечисление|Enum}.<ВидПеречисления>   Char(9) 
{Неопределенный|Undefine}       Char(23)        
{ВидРасчета|CalculationKind}    Int - идентификатор в журнале 
расчетов SQL формат; Char(4) - идентификатор в журнале расчетов DBF формат; Char
(13) - в остальных таблицах, где вид расчета содержится как реквизит;   
{Календарь|Calendar}    Char(13)        
"
    },
    {"Item","AST","Поддержка пользователей DBF формата ИБ","Поддержка пользователей DBF формата ИБ",
"",
"",
"Для пользователей DBF формата ИБ, рекомендуется использовать следующую строку 
подключения: DRIVER = {Microsoft Visual FoxPro Driver}; Deleted = No; Null = Yes; 
Collate = RUSSIAN; Exclusive = No; SourceType = DBF; SourceDB = <КаталогИБ>
В запросах допустимы комментарии типа -- и /* */, при DBF формате ИБ они будут 
вырезаны парсером перед передачей текста на драйвер.
В запросах допустима типизация колонок набора данных по общим правилам.
"
    },
    },
    },
}
